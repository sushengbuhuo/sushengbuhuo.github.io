---
title: golang 学习笔记
date: 2019-03-18 20:39:59
tags:
- golang
---
### interface 接口 
```javascript
//https://learnku.com/articles/25488
type Pet interface {
    SetName(name string)
    Name() string
    Category() string
}

type Dog struct {
    name string
}

func (dog *Dog) SetName(name string) {
    dog.name = name
}

func (dog Dog) Name() string {
    return dog.name
}

func (dog Dog) Category() string {
    return "dog"
}

func TestDog(t *testing.T) {
    dog := Dog{"little pig"}
    _, ok := interface{}(dog).(Pet)
    fmt.Printf("Dog implements interface Pet: %v\n", ok) // Dog implements interface Pet: false
    _, ok = interface{}(&dog).(Pet)
    fmt.Printf("*Dog implements interface Pet: %v\n", ok) // *Dog implements interface Pet: true
    var pet Pet = &dog
    fmt.Printf("This pet is a %s, the name is %q.\n",
        pet.Category(), pet.Name()) //  This pet is a dog, the name is "little pig".

    dog.SetName("monster")
    fmt.Printf("This pet is a %s, the name is %q.\n",
        pet.Category(), pet.Name()) // This pet is a dog, the name is "monster".
}
```
### Go 陷阱之 for 循环迭代变量
```javascript
var slice []func()
//https://learnku.com/articles/26861
func main() {
    sli := []int{1, 2, 3, 4, 5}
    for _, v := range sli {
        fmt.Println(&v)
        slice = append(slice, func(){
            fmt.Println(v * v) // 直接打印结果
        })
    }

    for _, val  := range slice {
        val()
    }
}
// 输出 25 25 25 25 25

var slice []func()

func main() {
    sli := []int{1, 2, 3, 4, 5}
    for _, v := range sli {
        temp := v // 其实很简单 引入一个临时局部变量就可以了，这样就可以将每次的值存储到该变量地址上
        fmt.Println(&temp) // 这里内存地址是不同的
        slice = append(slice, func(){
            fmt.Println(temp *  temp) // 直接打印结果
        })
    }

    for _, val  := range slice {
        val()
    }
}
// 输出 1, 4, 9, 16, 25 预期结果
for i, v := range
i, v 都是只创建一次，然后循环中赋值。
另外，循环的数组或 Map，是在开始前的镜像，循环中添加或移除元素不改变其循环次数。
关于循环还可以引申的是 Map 时是无序的
```
### Struct 与 面向对象
```javascript
type Human struct {
    name string
    age int
}
var tom Human
// 通过赋值初始化 https://learnku.com/articles/25094
tom.name, tom.age = "Tom", 18
// 详细初始化
jerry := Human{age:25, name:"Jerry"}
// 按照结构体声明顺序
peter := Human{"Peter", 34}
// 通过 . 访问
fmt.Printf("%s is %d old\n", tom.name, tom.age)

type Staff struct {
    Human // 隐式的引入 Human 的字段
    wage int
    age float32 // 覆盖 Human 的 age
}
tom := Staff{Human{"Tom", 18}, 1000, 18.5}
jerr := Staff{Human:Human{age:32, name:"Jerr"}, wage: 2000, age: 32.5}
fmt.Printf("%s is %f old，%d years, wage is %d", tom.name, tom.Human.age, tom.age, tom.wage)
fmt.Printf("%s is %f old，%d years, wage is %d", jerr.name, jerr.Human.age, jerr.age, jerr.wage)
type Human struct {
    name string
    age int
}

type Employee struct {
    Human
    wage int
}

func (h *Human) Say() {
    fmt.Printf("Hi, I am %s, My age is %d", h.name, h.age)
}

// Employee 重写 Say
func (e *Employee) Say() {
    fmt.Printf("Hi, I am %s, %d old year, wage is %d per mothn", e.name, e.age, e.wage)
}
```
### 异常处理
```javascript
func TestPanic(t *testing.T) {
    defer func() {
        fmt.Println("最后结果依旧执行!") // 这一部分的代码依旧执行
    }()
    fmt.Println("执行开始")
    panic(errors.New("错误信息!"))
}
// 输出大致结果如下
开始
最后结果依旧执行!
--- FAIL: TestPanic (0.00s)
panic: 错误信息! [recovered]
panic: 错误信息!
```
###  rand.Intn () 生成的是伪随机数
```javascript
rand.Intn() 函数是个伪随机函数, 不管运行多少次都只会返回同样的随机数, 因为它默认的资源就是单一值, 所以必须调用 rand.Seed(), 并且传入一个变化的值作为参数, 如 time.Now().UnixNano() , 就是可以生成时刻变化的值.

package main

import ("fmt"
        "math/rand"
        "time")

func main() {
    // 初始化随机数的资源库, 如果不执行这行, 不管运行多少次都返回同样的值https://learnku.com/articles/26011
    rand.Seed(time.Now().UnixNano())
    fmt.Println("A number from 1-100", rand.Intn(81))
}
```
###  beego 框架 model curd
```javascript
定义要连接的数据库 main.go https://learnku.com/articles/26029#topnav

package  main
import  (
  _  "newgo/routers"
  "github.com/astaxie/beego"
  "github.com/astaxie/beego/orm"
  _  "github.com/go-sql-driver/mysql"
)
func  init()  {
  orm.RegisterDriver("mysql",  orm.DRMySQL)
  orm.RegisterDataBase("default",  "mysql",  "root:root@tcp(127.0.0.1:3306)/go?charset=utf8")
}
func  main()  {
  beego.Run()
}
定义路由 router.go

beego.Router("/type", &controllers.ClassifyController{}, "GET:Type")
beego.Router("/classifyinsert", &controllers.ClassifyController{}, "POST:ClassifyInsert")
beego.Router("/classifyupdate", &controllers.ClassifyController{}, "GET:ClassifyUpdate")
beego.Router("/classifysave", &controllers.ClassifyController{}, "POST:ClassifySave")
beego.Router("/classifydel", &controllers.ClassifyController{}, "GET:ClassifyDel")
model书写

package  models
import  (
  "github.com/astaxie/beego/orm"
)
type  Classify  struct  {
  Id  int
  Name  string
  Content  string
}
func  init()  {
  orm.RegisterModel(new(Classify))
}
//增加操作
func  InsertClassify(name  string,  content  string)  (int64,  error)  {
  o  :=  orm.NewOrm()
  var  clasinfo  Classify
  clasinfo.Name  =  name
  clasinfo.Content  =  content
  id,  err  :=  o.Insert(&clasinfo)
  return  id,  err
}
//删除操作
func  ClassifyDel(id  int)  ([]Classify,  int64,  error)  {
  o  :=  orm.NewOrm()
  var  lists  []Classify
  num,  err  :=  o.QueryTable("classify").Filter("Id",  id).Delete()
  o.QueryTable("inventory").Filter("Cid",  id).Delete()
  return  lists,  num,  err
}
//展示
func  ClassifyList()  ([]Classify,  int64,  error)  {
  o  :=  orm.NewOrm()
  var  lists  []Classify
  num,  err  :=  o.QueryTable("classify").All(&lists)
  return  lists,  num,  err
}
//修改
func  ClassifyUpdate(id  int,  name  string,  content  string)  ([]Classify,  int64,  error)  {
  o  :=  orm.NewOrm()
  var  lists  []Classify
  num,  err  :=  o.QueryTable("classify").Filter("Id",  id).Update(orm.Params{
  "name":  name,
  "content":  content,
  })
  return  lists,  num,  err
}
控制器

package  controllers
import  (
  "fmt"
  "newgo/models"
  "strings"
  "github.com/astaxie/beego/orm"
  "github.com/astaxie/beego"
)
type  ClassifyController  struct  {
  beego.Controller
}
func  (c  *ClassifyController)  Get()  {
  c.TplName  =  "index.html"
}
func  (c  *ClassifyController)  Type()  {
  list,  num,  err  :=  models.ClassifyList()
  if  err  ==  nil  {
  fmt.Println(list)
  fmt.Println(num)
  }
  c.Data["comment"]  =  list
  fmt.Println(list)
  c.TplName  =  "type.html"
}
//添加post
func  (c  *ClassifyController)  ClassifyInsert()  {
  content  :=  strings.TrimSpace(c.GetString("content"))
  name  :=  strings.TrimSpace(c.GetString("name"))
  models.InsertClassify(name,  content)
  c.Ctx.Redirect(302,  "/type")
}
//修改get展示
func  (c  *ClassifyController)  ClassifySave()  {
  id,  _  :=  c.GetInt("id")
  fmt.Println(id)
  content  :=  strings.TrimSpace(c.GetString("content"))
  name  :=  strings.TrimSpace(c.GetString("name"))
  models.ClassifyUpdate(id,  name,  content)
  c.Ctx.Redirect(302,  "/type")
}
//删除
func  (c  *ClassifyController)  ClassifyDel()  {
  id,  _  :=  c.GetInt("id")
  models.ClassifyDel(id)
  c.Ctx.WriteString("200")
}
//修改post方法
func  (c  *ClassifyController)  ClassifyUpdate()  {
  id,  _  :=  c.GetInt("id")
  o  :=  orm.NewOrm()
  type  Comment  struct  {
  Id  int
  Name  string
  Content  string
  }
  var  comments  []Comment
  var  com  []Comment
  num,  err  :=  o.Raw("select  *  from  classify  where  id=?",  id).QueryRows(&comments)
  o.Raw("select  *  from  classify").QueryRows(&com)
  if  err  ==  nil  {
  fmt.Println(num)
  fmt.Println(comments)
  fmt.Println(com)
  c.Data["updates"]  =  comments
  c.Data["comment"]  =  com
  }  else  {
  fmt.Println("查询报错")
  }
  c.TplName  =  "type.html"
}
```
### php go的类
```javascript
<?php
namespace App;
class Animal
{
    public $name;
    public $height;
    public $weight;
    public function __construct($name, $height, $weight)
    {
        $this->name = $name;
        $this->height = $height;
        $this->weight = $weight;
    }
    public function getInfo()
    {
        return [
            'name'   => $this->name,
            'height' => $this->height,
            'weight' => $this->weight,
        ];
    }
}
//https://learnku.com/articles/26056
package main
type Animal struct {
    Name string
    Height uint
    Weight uint
}
func NewAnimal(name string, height, weight uint) Animal {
    return Animal{
        Name: name,
        Height: height,
        Weight: weight,
    }
}
func (a *Animal) GetInfo() map[string]interface{} {
    return map[string]interface{}{
        "name": a.Name,
        "height": a.Height,
        "weight": a.Weight,
    }
}

```
### Go for PHP Developers: Structs vs Classes
```javascript
package main
type Animal struct {
    Name string
    Height uint
    Weight uint
}
func NewAnimal(name string, height, weight uint) Animal {
    return Animal{
        Name: name,
        Height: height,
        Weight: weight,
    }
}
//https://learnku.com/articles/26056#reply85350 定义不同类似的结构体
func (a *Animal) GetInfo() map[string]interface{} {
    return map[string]interface{}{
        "name": a.Name,
        "height": a.Height,
        "weight": a.Weight,
    }
}
package main
type AnimalContract interface {
    GetInfo() map[string]interface{}
}
type Animal struct {
    // Struct def...
}
func (a *Animal) GetInfo() map[string]interface{} {
    // Method body... 继承AnimalContract 如果我们定义一个定义该接口的结构，它将隐式继承它。
}
package main
import "fmt"
func main(){
   var array = [9]interface{}{1,3,4,6,7,8,9,10,"index"}
   fmt.Print(array)
}
```
### append 扩容
```javascript
package array

import (
    "fmt"
)

/**
 * arr 底层扩容知识点https://learnku.com/articles/27630#topnav
 */
func ArrayAppend() []int {
    arr := make([]int,5)
    fmt.Printf("arr.len: %d; arr.cap: %d \n", len(arr),cap(arr))
    arr = append(arr,10)
    //问现在 arr 结果是什么
    fmt.Printf("arr.len: %d; arr.cap: %d \n", len(arr),cap(arr))
    return arr
}
```
### go build
```javascript
工作区是 Go 便捷管理项目的方式。一言以蔽之，它就是你系统上的一个目录，Go 可以在此 查找源码 文件，管理依赖包 还有 分发二进制文件。 当 Go 程序命中 import 语句，它就会去 Go 标准库 (*$GOROOT/src*) 中寻找响应的包。如果没找到，然后 Go 就会引用环境变量 GOPATH ，它是 Go 工作区目录的路径，然后再去 $GOPATH/src 目录下寻找这个包。

你可以按需指定多个工作区，只要你保证 GOPATH 环境变量指向你的工作区目录即可。
一个 Go 工作区目录必须有三个子目录也就是: src, pkg and bin
src 目录包含 Package. Package 包括一个包含 Go 源代码 (*.go* files) 。 任何使用 'go get' 命令安装的包也将驻留在这里 (及其依赖包)。

在 Go 中，每个程序都包含在一个包中。 因此，无论何时您将使用新的 Go 项目，您都需要在 $GOPATH/src 中创建新目录并向上工作。
当执行 go run hello.go 命令时，Go 编译器会首先编译 hello.go 文件，然后执行里面的二进制代码。

Go 程序支持输出二进制文件，执行 go build <package-name> (main 包) 或 go build program/path.go 命令即可在当前文件夹创建二进制文件。
执行 go install 命令就可以创建这些文件。 go install 命令会触发底层的 go build 命令，然后将这些文件保存到 bin 目录中。通常情况下，这个目录是在系统的可执行路径中。因此，这个目录中的所有文件都是可以通过终端来操作的。
https://learnku.com/golang/t/26863
go run main.go 
go build main.go
go install test #main.go在test目录

```
###  for 循环迭代变量
```javascript
var slice []func()

func main() {
	sli := []int{1, 2, 3, 4, 5}
	for _, v := range sli {
		fmt.Println(&v)
		slice = append(slice, func(){
			fmt.Println(v * v) // 直接打印结果
		})
	}
	//v 在 for 循环引进的一个块作用域内进行声明。在循环里创建的所有函数变量共享相同的变量，就是一个可访问的存储位置，而不是固定的值。(你会惊奇的发现 &v 的内存地址是一样的)https://www.njphper.com/posts/974e86a6.html
	for _, val  := range slice {
		val()
	}
}
// 输出 25 25 25 25 25
var slice []func()

func main() {
	sli := []int{1, 2, 3, 4, 5}
	for _, v := range sli {
	    temp := v // 其实很简单 引入一个临时局部变量就可以了，这样就可以将每次的值存储到该变量地址上
		fmt.Println(&temp) // 这里内存地址是不同的
		slice = append(slice, func(){
			fmt.Println(temp *  temp) // 直接打印结果
		})
	}
	
	for _, val  := range slice {
		val()
	}
}
// 输出 1, 4, 9, 16, 25 预期结果
```
### 实现 PHP 的密码加密解密
```javascript
package main
#https://www.njphper.com/posts/f3f0ab9c.html
import (
    "fmt"
    "log"
    "golang.org/x/crypto/bcrypt"
)

func main() {
    for {
       // 输入密码 获取 hash 值
        pwd := getPwd()
        hash := hashAndSalt(pwd)
       // 再次输入密码验证
        pwd2 := getPwd()
        pwdMatch := comparePasswords(hash, pwd2)
        fmt.Println("Passwords Match?", pwd)
    }
}

func getPwd() []byte {
    fmt.Println("Enter a password")
    var pwd string
    _, err := fmt.Scan(&pwd)
    if err != nil {
        log.Println(err)
    }
    return []byte(pwd)
}


func hashAndSalt(pwd []byte) string {
    hash, err := bcrypt.GenerateFromPassword(pwd, bcrypt.MinCost)
    if err != nil {
        log.Println(err)
    }
    return string(hash)
}

func comparePasswords(hashedPwd string, plainPwd []byte) bool {
    byteHash := []byte(hashedPwd)

    err := bcrypt.CompareHashAndPassword(byteHash, plainPwd)
    if err != nil {
        log.Println(err)
        return false
    }
    return true
}
str := `{"page": 1, "fruits": ["apple", "peach"]}`
实例化了一个 json 字符串，fruits 对应的是一个数组。
在 Go 语言中，字符串字面量可以使用双引号 "" 或者反引号 ' 来创建
```
### 截取中文
```javascript
first := "fisrt"
fmt.Println([]rune(first))
fmt.Println([]byte(first))
[]rune(s), 它可以将字符串转化成 unicode 码点
byte 表示一个字节，rune 表示四个字节
first := "社区"
fmt.Println([]rune(first))
fmt.Println([]byte(first))
[31038 21306] //输出结果[]rune
[231 164 190 229 140 186]//输出结果[]byte
s := "截取中文"
//试试这样能不能截取?
fmt.Println(s[:2])

s := "截取中文"
//试试这样能不能截取? https://www.njphper.com/posts/c251fcd3.html
res := []rune(s)
fmt.Println(string(res[:2]))

```
### 动态规划
```javascript
硬币问题：如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？https://blog.mutoe.com/2019/dynamic-programming/
// CoinChange: coins 硬币, amount 期望的金额, 返回最少需要的硬币数量，如果不可解返回-1
func CoinChange(coins []int, amount int) int {
  dp := make([]int, amount+1)
  dp[0] = 0

  for i := 1; i <= amount; i++ {
    dp[i] = amount + 1
    for _, coin := range coins {
      if coin <= i && dp[i-coin] != -1 && dp[i-coin]+1 < dp[i] {
        dp[i] = dp[i-coin] + 1
      }
    }
    if dp[i] > amount {
      dp[i] = -1
    }
  }

  return dp[amount]
}


```
### go php 对比学习
```javascript
https://learnku.com/golang/t/23385/from-a-php-engineers-point-of-view-go

first, second = second, first
func getName() (string, string) {
    return "hello", "world"
}

first, last = getName()
// foreach ($bookings as $key => $booking) {}
for key, booking := range bookings {}

// for ($i = 0; $i < count($bookings); $i++) {}
for i := 0; i < len(bookings); i++ {}

// while ($i < count($bookings)) {}
for i < len(bookings) {}

// do {} while (true);
for {}
type rect struct { // 定义一个结构体
    width  int
    height int
}

func (r *rect) area() int { // 在结构体上添加方法
    return r.width * r.height
}

r := rect{width: 10, height: 15} // 初始化
fmt.Print(r.area())
type Employee struct {
    Name string
    Job  Job
}

type Job struct {
    Employer string
    Position string
}

// 并去结构化它
e := Employee{
    Name: "Sobit",
    Job: {
        Employer: "GetYourGuide",
        Position: "Software Engineer",
    },
}func heartbeat() {
     for {
         time.Sleep(time.Second)
         fmt.Println("I'm still running...")
     }
 }
 现在， 我们怎样才能让这个函数在后台执行并且允许我们并行的做其他事呢？ 答案比你想象中要简单， 只需要在执行函数前加一个 go :
 
 go heartbeat()
 
 // 继续做其他事
 Go 自带开箱即用关注代码风格的 go fmt 工具。 不再需要分享 IDE 的配置文件， 不用尝试记住大括号应该是在同一行还是再起一行。
 
 可以使用 go doc 去阅读源码包文档， 而 go vet 将会协助我们查找代码中的问题。 安装第三方包只需要执行 go get [github.com/[vendor]/[package](http://github.com/[vendor]/[package)] 指令， 测试只需要执行 go test [package] 指令。
 

```
### 用Golang写爬虫
```javascript
package main
import (
	"fmt"
	"io/ioutil"
	"net/http"
)
func main() {
	fmt.Println("Hello, world")
	url := "http://www.baidu.com/"
	download(url)
}
func download(url string) {
	client := &http.Client{}
	req, _ := http.NewRequest("GET", url, nil)
	// 自定义Header
	req.Header.Set("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)")
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("http get error", err)
		return
	}
	//函数结束后关闭相关链接https://zhangslob.github.io/2019/01/16/Golang%E5%86%99%E7%88%AC%E8%99%AB/
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("read error", err)
		return
	}
	fmt.Println(string(body))
}

package main
import (
	"fmt"
	"github.com/jackdanger/collectlinks"
	"net/http"
)
func main() {
	fmt.Println("Hello, world")
	url := "http://www.baidu.com/"
	download(url)
}
func download(url string) {
	client := &http.Client{}
	req, _ := http.NewRequest("GET", url, nil)
	// 自定义Header
	req.Header.Set("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)")
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("http get error", err)
		return
	}
	//函数结束后关闭相关链接
	defer resp.Body.Close()
	links := collectlinks.All(resp.Body)
	for _, link := range links {
		fmt.Println("parse url", link)
	}
}
```
[完整视频代码及学习资料-Zinx 框架-Golang 轻量级 TCP 并发服务](https://github.com/aceld/zinx)

[go基础库之解析以逗号分隔的数据](https://www.ganymedenil.com/2019/05/27/go-standard-library-by-parse-data-separated-by-commas.html)

[Golang(Go语言)简明教程](https://jiajunhuang.com/tutorial/golang/index.md)

[Golang+gin+vue+MySQL blog https:/www.iphpt.com](https://github.com/izghua/go-blog)

[Go Modules 详解](https://www.njphper.com/posts/8b58ea6d.html)

[markdown博客](https://github.com/xusenlin/ForestBlog)

[YouTube download library and CLI written in Go](https://github.com/rylio/ytdl)

[根据手机号识性别](https://github.com/dchaofei/phone-identifies-gender)

[Go 学习之路](https://github.com/developer-learning/learning-golang)

[Golang 中的面向对象继承](https://www.njphper.com/posts/b2d15c51.html)

[Laravel 博客替换成了 Go 写的博客](https://github.com/broqiang/mdblog)

[Go 语言 Excel 类库 Excelize](https://github.com/360EntSecGroup-Skylar/excelize)

[Golang 中的面向对象](https://learnku.com/articles/26817)

[httprouter 源码分析](https://learnku.com/articles/27591)

[Go for PHP Developers](https://learnku.com/articles/26056)

[ golang 实现的泛型数组](https://github.com/JeffreyBool/array)

[ go-Laravel-broadcast 实现 Laravel 的即时通讯](https://58hualong.cn/blog/post/liyong-go-laravel-broadcast-shixian-laravel-de-jishi-tongxun)

[Golang 新手可能会踩的 50 个坑](https://learnku.com/articles/27808#topnav)

[使用 Go 语言的开源项目和公司](https://learnku.com/golang/wikis/27748)

[Go 如何实现 PHP 的密码加密解密](https://learnku.com/articles/27561)

[golang 实现斗地主棋牌游戏](https://github.com/dwg255/landlord)

[Go 编写 Web 应用](https://learnku.com/articles/26715)

[模仿 Laravel 的项目结构和风格](https://github.com/Away0x/gin_weibo)

[HTTP 客户端](https://broqiang.com/posts/http-client-base)

[golang国内镜像](https://golang.google.cn/)

[golang工具](https://www.alexedwards.net/blog/an-overview-of-go-tooling)

[Golang 使用 Map](https://learnku.com/articles/27691)

[奔跑的 Go](https://learnku.com/golang/t/27592)

[Go 如何实现 PHP 的密码加密解密](https://learnku.com/articles/27561#topnav)

[GOLANG 超大文件读取的两个方案](https://www.zhanggaoyuan.com/article/8)

[《 刻意学习 Golang - 标准库源码分析 》](https://learnku.com/articles/25470#topnav)

[专为微服务架构定制的高性能网关](https://github.com/EpochCloud/quick)

[go扫盲](https://github.com/Kirk-Wang/Hello-Gopher/)

[对 Go 语言的综合评价](http://www.yinwang.org/blog-cn/2014/04/18/golang)

[miniblink+golang 开发 Windows gui 应用](https://learnku.com/golang/t/26104)

[通过实例入门Golang](https://huoding.com/2017/06/09/623)

[中文:文档首页](https://go-zh.org/doc/)

[Go Modules 详解使用](https://learnku.com/articles/27401)

[Golang 的轻量级 TCP 并发服务器框架](https://learnku.com/golang/t/28729#replies)