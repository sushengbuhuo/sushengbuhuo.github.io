---
title: 面试资料收集
date: 2019-02-28 19:51:19
tags:
- 面试
---
###鉴别出那瓶水有毒
```javascript
有1000瓶水，其中有一瓶有毒，小白鼠只要尝一点带毒的水24小时后就会死亡，至少要多少只小白鼠才能在24小时时鉴别出那瓶水有毒
链接：https://www.nowcoder.com/questionTerminal/84726a200b4a4a0d95b9565b4c6eb216
来源：牛客网

每个老鼠只有死或活2种状态，因此每个老鼠可以看作一个bit，取0或1
N个老鼠可以看作N个bit，可以表达2^N种状态（其中第i个状态代表第i个瓶子有毒）
例如：当N＝2时，可以表达4种状态
0，0（ 一号老鼠活，二号老鼠活）
0，1（ 一号老鼠活，二号老鼠死）
1，0（ 一号老鼠死，二号老鼠活）
1，1（ 一号老鼠死，二号老鼠死）
具体来说，有A、B、C、D这4个瓶子，一号老鼠喝A和B， 二号老鼠喝B和C
如果 0，0 （ 一号老鼠活，二号老鼠活），说明是D有毒，第0个状态代表第4个瓶子有毒
如果 0，1 （ 一号老鼠活，二号老鼠死） ，说明是C有毒 ，第1个状态代表第3个瓶子有毒
如果 1，0 （ 一号老鼠死，二号老鼠活） ，说明是A有毒 ，第2个状态代表第1个瓶子有毒
如果 1，1 （ 一号老鼠死，二号老鼠死） ，说明是B有毒 ，第3个状态代表第2个瓶子有毒
可以想象成用2进制来表示1000个数最少需要多少位
```
### Cookie 禁用了，Session 还能用吗
```javascript
你第一次访问网站时，
https://learnku.com/articles/25858 
服务端脚本中开启了Sessionsession_start();，

服务器会生成一个不重复的 SESSIONID 的文件session_id();，比如在/var/lib/php/session目录

并将返回(Response)如下的HTTP头 Set-Cookie:PHPSESSIONID=xxxxxxx

客户端接收到Set-Cookie的头，将PHPSESSIONID写入cookie

当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端

服务器识别PHPSESSIONID这个cookie，然后去session目录查找对应session文件，

找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置
如果一个Cookie都没接收到，基本上可以预判客户端禁用了Cookie，那将session_id附带在每个网址后面(包括POST)，
比如：

GET http://www.xx.com/index.php?session_id=xxxxx
POST http://www.xx.com/post.php?session_id=xxxxx
然后在每个页面的开头使用session_id($_GET['session_id'])，来强制指定当前session_id
所以Laravel等框架中，内部实现了Session的所有逻辑，并将PHPSESSIONID设置为httponly并加密，这样，前端JS就无法读取和修改这些敏感信息，降低了被盗用的风险。

```
### 如何进行防 SQL 注入
```javascript
1 表单尽量用 post 提交,核心用户验证都走 post,避开 get容易暴露客户数据
2 使用HTTP_REFERER 检查源文件是否来自本系统
3 开启addslashes在特殊符号前加\
4 使用htmlspecialchars对字符串转实体
5 用户授权登录
6 使用PDO
```
### 大流量高并发量网站的解决方案
```javascript
对比现实中饭店一下子同一个时间段来吃饭 比方中午https://learnku.com/articles/25886
1 把这个店面面积扩大点，增加同时吃饭人数
   服务器优化：我们把apache服务器只支持（3000并发）可以换成nginx服务器（3w并发）
2 多找点服务员和厨师嘛  
   服务器优化：修改apache，nginx的默认配置，把其中的并发数调到最高嘛
3 多开一些店 连锁店
   服务器优化：多增加几台服务器同时对客户提供网络服务 lvs nginx 做负载均衡
4 限时客户在我们店吃饭的时间 不能让他们吃完还打牌把
   服务器优化：减少客户在服务器上的连接断开时间 比方mysql 的连接断开时间 wait_timeout这个参数最多的连接时间 不能让客户恶意一直连着
5 给厨师培训 增加他的上菜时间
   那就要给php代码做优化
6 让厨师叫手下把菜提前做好 放到冰箱里面
   redis 缓存 文件缓存
```
### sql分组
```javascript
1) 算出每个班级中的学生，按照成绩降序排序;https://learnku.com/articles/25903#topnav
select name,class,score from student order by class,score desc;

2) 查出每个班的及格人数和不及格人数，格式为:class、及格人数、不及格人数;

SELECT class,
SUM(CASE WHEN score>=60 THEN 1 ELSE 0 END),
SUM(CASE WHEN score<60 THEN 1 ELSE 0 END)
FROM tb1 GROUP BY class
这边主要先分组 在聚合在加入判断条件

3) 用 PHP 写入连接数据库("localhost","msuser","mspass")、执行以上 SQL、显示结果、 判断错误、关闭数据库的过程
$conn=mysql_connect(‘localhost’,'msuser ’,’mspass′);//链接数据库
Mysql_select_db(‘test’);
$sql=" SELECT class,
SUM(CASE WHEN score>=60 THEN 1 ELSE 0 END), SUM(CASE WHEN score<60 THEN 1 ELSE 0 END)
FROM tb1 GROUP BY class";
if($result=Mysql_query($sql)){
     while($row=mysql_fetch_assoc($result)){
     print_r($row);
} }
Mysql_close($conn);

```
###  GET 与 POST 的区别
```javascript
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中

GET产生一个TCP数据包；POST产生两个TCP数据包。https://learnku.com/articles/25881


对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。

因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

1. GET与POST都有自己的语义，不能随便混用。

2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

浏览器有没有默认发送 Expect:100-continue 的请求头就不清楚, 但是 curl 是默认会发送的. 具体的解释可以看鸟哥的博客: http://www.laruence.com/2011/01/20/1840.html

摘抄一下重点:

在使用curl做POST的时候, 当要POST的数据大于1024字节的时候, curl并不会直接就发起POST请求, 而是会分为俩步,

 1. 发送一个请求, 包含一个Expect:100-continue, 询问Server使用愿意接受数据
 2. 接收到Server返回的100-continue应答以后, 才把数据POST给Server

并不是所有的Server都会正确应答100-continue, 比如lighttpd, 就会返回417 “Expectation Failed”, 则会造成逻辑出错.
因此, 在使用 curl 时可以考虑增加一步处理, 既在请求头中将 Expect 值置空. 鸟哥给出的 demo 是这样

curl_setopt($ch, CURLOPT_HTTPHEADER, array('Expect:'));
guzzle 的做法是:

// If the Expect header is not present, prevent curl from adding it
if (!$request->hasHeader('Expect')) {
    $conf[CURLOPT_HTTPHEADER][] = 'Expect:';
}
```
### nginx 配置 
```javascript
server {
    # 监听 HTTP 协议默认的 [80] 端口。https://learnku.com/articles/25861
    listen 80;
    # 绑定主机名 [example.com]。
    server_name example.com;
    # 服务器站点根目录 [/example.com/public]。
    root /example.com/public;

    # 添加几条有关安全的响应头；与 Google+ 的配置类似，详情参见文末。
    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";

    # 站点默认页面；可指定多个，将顺序查找。
    # 例如，访问 http://example.com/ Nginx 将首先尝试「站点根目录/index.html」是否存在，不存在则继续尝试「站点根目录/index.htm」，以此类推...
    index index.html index.htm index.php;

    # 指定字符集为 UTF-8
    charset utf-8;

    # Laravel 默认重写规则；删除将导致 Laravel 路由失效且 Nginx 响应 404。
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    # 关闭 [/favicon.ico] 和 [/robots.txt] 的访问日志。
    # 并且即使它们不存在，也不写入错误日志。
    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }

    # 将 [404] 错误交给 [/index.php] 处理，表示由 Laravel 渲染美观的错误页面。
    error_page 404 /index.php;

    # URI 符合正则表达式 [\.php$] 的请求将进入此段配置
    location ~ \.php$ {
        # 配置 FastCGI 服务地址，可以为 IP:端口，也可以为 Unix socket。
        fastcgi_pass unix:/var/run/php/php7.2-fpm.sock;
        # 配置 FastCGI 的主页为 index.php。
        fastcgi_index index.php;
        # 配置 FastCGI 参数 SCRIPT_FILENAME 为 $realpath_root$fastcgi_script_name。
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
        # 引用更多默认的 FastCGI 参数。
        include fastcgi_params;
    }
    # 通俗地说，以上配置将所有 URI 以 .php 结尾的请求，全部交给 PHP-FPM 处理。

    # 除符合正则表达式 [/\.(?!well-known).*] 之外的 URI，全部拒绝访问
    # 也就是说，拒绝公开以 [.] 开头的目录，[.well-known] 除外
    location ~ /\.(?!well-known).* {
        deny all;
    }
}
```
###判断两个有序数组是否有公共元素
```javascript
// https://github.com/chunlintang/interview/blob/master/src/algorithms/common.php
function common($arr1, $arr2)
{
	$len1 = count($arr1);
	$len2 = count($arr2);
	$common = [];
	$i = $j = 0;
	while ($i < $len1 && $j < $len2) {
		if ($arr1[$i] > $arr2[$j]) {
			$j++;
		} elseif ($arr1[$i] < $arr2[$j]) {
			$i++;
		} else {
			array_push($common, $arr1[$i]);
			$i++;
			$j++;
		}
	}
	return $common;
}
```
### 猴子选大王，约瑟夫环
```javascript
// 
function monkeyKing($n, $m)
{
	$arr = [1, $n];
	$i = 0;
	while (count($arr) > 1) {
		$i++;
		$survice = array_shift($arr);
		if ($i % $m != 0) {
			array_push($arr, $survice);
		}
	}
	return $arr[0];
}
```
### 质数
```javascript
// 质数
function prime($n)
{
	$prime = [2];
	for ($i = 3; $i < $n; $i += 2) {
		$sqrt = intval(sqrt($i));
		for ($j = 3; $j <= $sqrt; $j += 2) {
			if ($i % $j == 0) {
				break;
			}
		}
		if ($i > $sqrt) {
			array_push($prime, $i);
		}
	}
	return $prime;
}

/**
 * 获取所有的质数
 * @param array $arr
 * @return array
 */
function get_prime_number($arr = []) {
    // 质数数组
    $primeArr = [];
    // 循环所有备选数
    foreach ($arr as $value) {
        // 备选数和备选数的中间数以下的数字整除比较
        for ($i = 2; $i <= floor($value / 2); $i++) {
            // 能够整除，则不是质数，退出循环
            if ($value % $i == 0) {
                break;
            }
        }
        // 被除数$j比备选数的中间数大的则为质数
        // 这样判断的依据：
        // 假如备选数为质数，则内层的for循环不会break退出，则执行完毕，$i会继续+1，即最后$i = floor($value / 2) + 1
        // 假如备选数不为质数，则内层的for循环遇到整除就会break退出，$i不会继续+1，即最后$i <= floor($value / 2)
        if ($value != 1 && $i > floor($value / 2)) {
            $primeArr[] = $value;
        }
    }
    return $primeArr;
}

/**
 * 获取所有的质数
 * @param array $arr
 * @return array
 */
function get_prime_number($arr = []) {
    // 质数数组
    $primeArr = [];
    // 循环所有备选数
    foreach ($arr as $value) {
        // 备选数和备选数的中间数以下的数字整除比较
        for ($i = 2; $i <= floor($value / $i); $i++) {
            // 能够整除，则不是质数，退出循环
            if ($value % $i == 0) {
                break;
            }
        }
        // 被除数$j比备选数的中间数大的则为质数
        // 这样判断的依据：
        // 假如备选数为质数，则内层的for循环不会break退出，则执行完毕，$i会继续+1，即最后$i = floor($value / $i) + 1
        // 假如备选数不为质数，则内层的for循环遇到整除就会break退出且$i不会继续+1，即最后$i <= floor($value / $i)
        if ($value != 1 && $i > floor($value / $i)) {
            $primeArr[] = $value;
        }
    }
    return $primeArr;
}
/**
 * 获取所有的质数
 * @param array $arr
 * @return array
 */
function get_prime_number_three($arr = []) {
    // 质数数组
    $primeArr = $arr;
    // 循环所有备选数
    foreach ($primeArr as $key => $value) {
        if ($value == 1) {
            unset($primeArr[$key]);
            continue;
        }
        // 备选数和备选数的中间数以下的数字整除比较
        for ($i = 2; $i <= floor($value / $i); $i++) {
            // 能够整除，则不是质数，从数组中删除且退出循环
            if ($value % $i == 0) {
                unset($primeArr[$key]);
                break;
            }
        }
    }
    // 重置数组索引返回
    return array_values($primeArr);
}
// 所有备选数数组
$numberArr = range(1, 100, 1);
// 获取备选数中的所有质数
$primeNumberArr = get_prime_number($numberArr);
// 输出打印
print_r($primeNumberArr);
// 所有备选数数组
$numberArr = [11, 22, 33, 66, 77, 3, 8, 10, 99];
// 获取备选数中的所有质数
$primeNumberArr = get_prime_number($numberArr);
// 输出打印http://blog.y0701.com/2018/09/18/PHP%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E8%B4%A8%E6%95%B0/
print_r($primeNumberArr);
```
### PHP算法之二分查找
```javascript
/**
 * 二分查找算法
 * @param array $arr 待查找区间
 * @param int $number 查找数
 * @return int        返回找到的键
 */
function binary_search($arr, $number) {
    // 非数组或者数组为空，直接返回-1
    if (!is_array($arr) || empty($arr)) {
        return -1;
    }
    // 初始变量值
    $len = count($arr);
    $lower = 0;
    $high = $len - 1;
    // 最低点比最高点大就退出
    while ($lower <= $high) {
        // 以中间点作为参照点比较
        $middle = intval(($lower + $high) / 2);
        if ($arr[$middle] > $number) {
            // 查找数比参照点小，舍去右边
            $high = $middle - 1;
        } else if ($arr[$middle] < $number) {
            // 查找数比参照点大，舍去左边
            $lower = $middle + 1;
        } else {
            // 查找数与参照点相等，则找到返回
            return $middle;
        }
    }
    // 未找到，返回-1
    return -1;
}
/**
 * @param array $arr 待查找区间
 * @param int $number 查找数
 * @param int $lower 区间最低点
 * @param int $high 区间最高点
 * @return int
 */
function binary_search_recursion(&$arr, $number, $lower, $high) {
    // 以区间的中间点作为参照点比较
    $middle = intval(($lower + $high) / 2);
    // 最低点比最高点大就退出
    if ($lower > $high) {
        return -1;
    }
    if ($number > $arr[$middle]) {
        // 查找数比参照点大，舍去左边继续查找
        return binary_search_recursion($arr, $number, $middle + 1, $high);
    } elseif ($number < $arr[$middle]) {
        // 查找数比参照点小，舍去右边继续查找
        return binary_search_recursion($arr, $number, $lower, $middle - 1);
    } else {
        return $middle;
    }
}
// 待查找区间
$arr = [1, 3, 7, 9, 11, 57, 63, 99];
// 非递归查找66所在的位置
$find_key = binary_search($arr, 57);
// 递归查找66所在的位置
$find_key_r = binary_search_recursion($arr, 57, 0, count($arr));
// 输出打印
print_r($find_key);
print_r($find_key_r);http://blog.y0701.com/2018/09/20/PHP%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/
```
[看云文档](https://www.kancloud.cn/explore)



[程序员的自我修养](https://www.kancloud.cn/kancloud/a-programmer-prepares/78223)

[PHP 面试知识点汇总](https://github.com/wudi/PHP-Interview-Best-Practices-in-China)

[正向代理为客户端做代理，反向代理为服务器做代理](https://learnku.com/articles/25837)

[计算机网络知识总结](https://juejin.im/post/5ac05aab6fb9a028e25db037)

[排序算法全总结](https://juejin.im/post/5ac49b5c518825556e5e5060)

[面试中关于Redis的问题看这篇就够了](https://juejin.im/post/5ad6e4066fb9a028d82c4b66)

[Mysql锁机制简单了解一下](https://juejin.im/post/5b192314e51d45067d407822)

[消息队列其实很简单](https://juejin.im/post/5c1731466fb9a049af6d2a83)

[一份最适合你的后端面试指南](https://juejin.im/post/5ba591386fb9a05cd31eb85f)

[面试必备之乐观锁与悲观锁](https://juejin.im/post/5b4977ae5188251b146b2fc8)

[搞定计算机网络面试，看这篇就够了](https://juejin.im/post/5b7be0b2e51d4538db34a51e)

[程序员简历之道](https://juejin.im/post/5b59c9f6e51d4535a65add84)

[前端&后端程序员必备的Linux基础知识](https://juejin.im/post/5b3b19856fb9a04fa42f8c71)

[技术人员成长必备！](https://github.com/Snailclimb/programmer-advancement)

[技术面试中常见的几道智力题 ](https://juejin.im/post/5b2dffb851882574eb598896)

[关于MySQL的知识点与面试常见问题都在这里](https://juejin.im/post/5b24cf7e51882574c020bd56)

[一份涵盖大部分Java程序员所需要掌握的核心知识](https://github.com/Snailclimb/JavaGuide)

[php面试](https://github.com/chunlintang/interview)

[图标生成器](https://www.qingwei.tech/somehub/)

[程序猿面试应知道的8种数据结构](https://www.qingwei.tech/programe-develops/1171.html)

[历经 20 天，我终于完成了这份专为程序员编写的英语学习指南](https://juejin.im/post/5c368a7df265da612e28d5c7)

[如何"有计划，高效率，优简历"应对面试](https://learnku.com/articles/27430#topnav)

[小土刀的面试刷题笔记](https://wdxtub.com/interview/14520847747820.html)

[我本以为你们会写简历](https://segmentfault.com/a/1190000018378234)

 [《数据结构与算法之美》复杂度分析](https://learnku.com/articles/27738#topnav)

[《软技能：代码之外的生存准则》读后感](https://haoruijie.art/2019/04/02/book-soft-skill-review.html)

[Redis和mysql数据怎么保持数据一致的](https://juejin.im/post/5c96fb795188252d5f0fdff2?utm_source=coffeephp.com)

[Nginx高并发下的优化](https://segmentfault.com/a/1190000011405320)

[笔试面试知识整理](https://github.com/HIT-Alibaba/interview)

[PHPer 面试可能会遇到的问题](https://learnku.com/laravel/t/6138/share-some-of-the-problems-that-larvel-and-phper-interviews-may-encounter)

[画江湖之算法篇【排序算法】冒泡排序](https://learnku.com/articles/25842)

[从零开始打造自己的PHP框架 ](https://www.imooc.com/learn/696)

[Laravel 从入门到精通教程代码](https://github.com/nonfu/laravel-tutorial-code)

[Laravel 从入门到精通系列教程](https://laravelacademy.org/laravel-tutorial-5_7)

[程序员内功修炼系列 2019 版](https://laravelacademy.org/programmer-internal-skills-series)

[ PHP 面试的资料](https://github.com/xianyunyh/PHP-Interview)

[简聊 Session 与 Token 身份验证](https://learnku.com/articles/17867)

[画江湖之数据结构【第二话:队列】队列](https://learnku.com/articles/25814)

[面试前必须要知道的 Redis 面试内容](https://learnku.com/articles/22363)

[【简易图解】『 OAuth2.0』 猴子都能懂的图解](https://learnku.com/articles/20031)

[面试之 Redis 基础、高级特性与性能调优](https://learnku.com/articles/25070#topnav)

[收集的干货，持续更新](https://learnku.com/articles/22538)

[PHP面试常考之设计模式——建造者模式](https://segmentfault.com/a/1190000018447170?utm_source=tag-newest)

[PHP 详细面试总结 (二 HTTP 请求全过程)](https://learnku.com/articles/25252#topnav)

[lua](https://www.fanhaobai.com/2017/09/lua.html)

[代理与反向代理、负载均衡和缓存](https://learnku.com/articles/26686)

[PHP-FPM 与 Nginx 的通信机制总结](https://segmentfault.com/a/1190000018464303?utm_source=tag-newest)

[从一道百度面试题说起](http://fanqieto.top/2018/08/03/%E4%BB%8E%E4%B8%80%E9%81%93%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%B4%E8%B5%B7/)

[笔试面试常用排序算法总结](http://fanqieto.top/2018/07/26/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/)

[PHP 详细面试总结](https://learnku.com/articles/25204)

[面试的技巧（上）：听懂别人的问题](http://fanqieto.top/2018/06/23/%E9%9D%A2%E8%AF%95%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%90%AC%E6%87%82%E5%88%AB%E4%BA%BA%E7%9A%84%E9%97%AE%E9%A2%98/)

[leetcode题解（数组问题）](http://fanqieto.top/2018/06/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%85%B6%E5%AE%9E%E6%9C%80%E5%B8%B8%E8%A7%81/)

[如何准备算法面试](http://fanqieto.top/2018/06/14/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/)

[高并发下给数据库性能有哪些影响？](http://fanqieto.top/2017/10/12/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%BB%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BD%B1%E5%93%8D/)

[大话后端开发的奇淫技巧大集合](http://blog.thankbabe.com/2018/05/23/shared-experience/#top)

[聪明人应该如何背英语单词？](https://zhuanlan.zhihu.com/p/26175433)

[20K+的高级PHP面试题汇总](http://www.sangeng.org/blog/detail_563.html)

[阿里云Redis开发规范 ](https://mp.weixin.qq.com/s/OzAnRVPUDtoiIXqeC7YL6g)

[php解决高并发问题](https://www.cnblogs.com/walblog/articles/8476579.html)

[面试最让你手足无措的一个问题：你的系统如何支撑高并发](https://learnku.com/laravel/t/24359)

[面试 (MySQL 索引为啥要选择 B+ 树)](https://learnku.com/articles/25879)

[MySQL 避坑宝典](https://github.com/XiaoMi/soar/blob/master/doc/heuristic.md)

[深入 Nginx 之配置篇](https://learnku.com/articles/24795#topnav)

[PHP 面试踩过的坑](https://learnku.com/articles/28716)

[PHP 面试详解之技术篇](https://learnku.com/articles/28772)

[PHP面试总结](http://blog.y0701.com/2018/09/11/PHP%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/)

[记录开发或面试中可能遇到的知识点](https://github.com/duiying/php-notes)

[程序员常见的编码和转义](http://qinghua.github.io/encoding-and-escaping/)


[当你在浏览器中输入“google.com”并回车，会发生什么](https://betacat.online/posts/2019-01-25/what-happens-when-you-type-googlecom-into-your-browser-and-return/)


[反向代理和内网穿透frp ngrok](https://betacat.online/posts/2019-02-22/reverse-proxy-and-intranet-through/)

[TCP 协议简单说明](https://learnku.com/articles/29685)

[最近去腾讯面试了，分享一波面试题](https://learnku.com/articles/28896)

[PHP面试准备的资料](https://github.com/xianyunyh/PHP-Interview)






