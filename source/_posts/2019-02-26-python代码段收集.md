---
title: python代码段收集
date: 2019-02-26 19:45:56
tags:
- python
---
### 5 行代码入门 Python 爬虫
```javascript
import requests
import pandas as pd
from bs4 import BeautifulSoup
from lxml import etree
import time
import pymysql
from sqlalchemy import create_engine
from urllib.parse import urlencode  # 编码 URL 字符串https://www.makcyun.top/web_scraping_withpython18.html

start_time = time.time()  #计算程序运行时间
def get_one_page(i):
	try:
		headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36'
        }
		paras = {
		'reportTime': '2017-12-31',
		#可以改报告日期，比如2018-6-30获得的就是该季度的信息
		'pageNum': i   #页码
		}
		url = 'http://s.askci.com/stock/a/?' + urlencode(paras)
		response = requests.get(url,headers = headers)
		if response.status_code == 200:
			return response.text
		return None
	except RequestException:
		print('爬取失败')

def parse_one_page(html):
	soup = BeautifulSoup(html,'lxml')
	content = soup.select('#myTable04')[0] #[0]将返回的list改为bs4类型
	tbl = pd.read_html(content.prettify(),header = 0)[0]
	# prettify()优化代码,[0]从pd.read_html返回的list中提取出DataFrame
	tbl.rename(columns = {'序号':'serial_number', '股票代码':'stock_code', '股票简称':'stock_abbre', '公司名称':'company_name', '省份':'province', '城市':'city', '主营业务收入(201712)':'main_bussiness_income', '净利润(201712)':'net_profit', '员工人数':'employees', '上市日期':'listing_date', '招股书':'zhaogushu', '公司财报':'financial_report', '行业分类':'industry_classification', '产品类型':'industry_type', '主营业务':'main_business'},inplace = True)
	return tbl

def generate_mysql():
	conn = pymysql.connect(
		host='localhost',
		user='root',
		password='******',
		port=3306,
		charset = 'utf8',  
		db = 'wade')
	cursor = conn.cursor()

	sql = 'CREATE TABLE IF NOT EXISTS listed_company (serial_number INT(20) NOT NULL,stock_code INT(20) ,stock_abbre VARCHAR(20) ,company_name VARCHAR(20) ,province VARCHAR(20) ,city VARCHAR(20) ,main_bussiness_income VARCHAR(20) ,net_profit VARCHAR(20) ,employees INT(20) ,listing_date DATETIME(0) ,zhaogushu VARCHAR(20) ,financial_report VARCHAR(20) , industry_classification VARCHAR(20) ,industry_type VARCHAR(100) ,main_business VARCHAR(200) ,PRIMARY KEY (serial_number))'
	cursor.execute(sql)
	conn.close()
	
def write_to_sql(tbl, db = 'wade'):
    engine = create_engine('mysql+pymysql://root:******@localhost:3306/{0}?charset=utf8'.format(db))
    try:
    	tbl.to_sql('listed_company2',con = engine,if_exists='append',index=False)
    	# append表示在原有表基础上增加，但该表要有表头
    except Exception as e:
    	print(e)

def main(page):
    generate_mysql()
	for i in range(1,page):  
		html = get_one_page(i)
		tbl = parse_one_page(html)
		write_to_sql(tbl)
		
# # 单进程
if __name__ == '__main__':	
	main(178)
	endtime = time.time()-start_time
	print('程序运行了%.2f秒' %endtime)
	
# 多进程
from multiprocessing import Pool
if __name__ == '__main__':
 	pool = Pool(4)
 	pool.map(main, [i for i in range(1,178)])  #共有178页
	endtime = time.time()-start_time
	print('程序运行了%.2f秒' %(time.time()-start_time))
	
import pandas as pd
import csv
for i in range(1,178):  # 爬取全部页
	tb = pd.read_html('http://s.askci.com/stock/a/?reportTime=2017-12-31&pageNum=%s' % (str(i)))[3] 
	tb.to_csv(r'1.csv', mode='a', encoding='utf_8_sig', header=1, index=0)	
	
```
### 时间处理
```javascript
# -*- coding: utf-8 -*-
# author:           inpurer(月小水长)
# pc_type           lenovo
# create_date:      2018/12/3
# file_name:        timetest.py
# description:      月小水长，热血未凉

import time

t0 = time.time()
#description:   输出当前时间距离1970.1.1的秒数,精确到小数点后6位，也叫做时间戳
#output sample: 1543799532.602318
print(t0)

t1 = time.localtime(t0)
#description:   把时间戳转成元组,包含七个元素,前六个见名知意,tm_wday是指今天是当前周的第几天(index from 0),tm_yday类似,tm_isdst是否是夏令时,不用关心
#output sample: time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=22, tm_sec=24, tm_wday=0, tm_yday=337, tm_isdst=0)
print(t1)
#so,可以这样输出今天是今年的第多少天
print(t1[-2]+1)


#下面是对该元组的格式化

#description:   简单可读形式
#output sample: Mon Dec  3 09:31:18 2018
t2 = time.asctime(t1)
print(t2)

#description:   可通过参数设置成各种形式，下面是一种标准形式,各参数见名知意
#output sample: 2018-12-03 09:33:36
t3 = time.strftime("%Y-%m-%d %H:%M:%S", t1)
print(t3)
#%y 两位数的年份表示（00-99）
# %Y 四位数的年份表示（000-9999）
# %m 月份（01-12）
# %d 月内中的一天（0-31）
# %H 24小时制小时数（0-23）
# %I 12小时制小时数（01-12）
# %M 分钟数（00=59）
# %S 秒（00-59）
#
# %a 本地简化星期名称
# %A 本地完整星期名称
# %b 本地简化的月份名称
# %B 本地完整的月份名称
# %c 本地相应的日期表示和时间表示
# %j 年内的一天（001-366）
# %p 本地A.M.或P.M.的等价符
# %U 一年中的星期数（00-53）星期天为星期的开始
# %w 星期（0-6），星期天为星期的开始
# %W 一年中的星期数（00-53）星期一为星期的开始
# %x 本地相应的日期表示
# %X 本地相应的时间表示
# %Z 当前时区的名称
# %% %号本身


# 下面是把格式化字符串转成元组
# description:      第一个参数个格式化后的字符串,后一个参数和格式化对应，便于反格式化
# output sample:    time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=47, tm_sec=7, tm_wday=0, tm_yday=337, tm_isdst=-1)
t4 = time.strptime(t3,'%Y-%m-%d %H:%M:%S')
print(t4)

# 把元组转成时间戳
#description:   是time.localtime的反函数,不过由于格式化的原因，精度有所下降
#output sample: 1543801627.0
t5 = time.mktime(t4)
print(t5)

# -*- coding: utf-8 -*-
# author:           inpurer(月小水长)
# pc_type           lenovo
# create_date:      2018/12/3
# file_name:        timetest.py
# description:      月小水长，热血未凉

import datetime

#通过datetime.datetime.now()可以获得当前日期时间的一个实例
#这个实例是一个datetime类对象而不是字符串
#虽然直接打印该实例输出的是一个字符串,只是调用datetime实现的__str__方法而已
t0 = datetime.datetime.now()
print(t0)           #print: 2018-12-03 12:55:49.905971
print(type(t0))     #print: <class 'datetime.datetime'>

#然后就可以通过对象名.的方法输出各个时间信息,该信息是一个int类型
print(t0.year)          #print: 2018
print(type(t0.year))    #print: <class 'int'>
print(t0.month)
print(t0.day)
print(t0.hour)
print(t0.minute)
print(t0.second)

import datetime
t0 = datetime.datetime.now()
#注意year/month/day都是int类型，不像java那样可以直接拼接字符串和数字
wanted_time = str(t0.year)+"-"+str(t0.month)+"-"+str(t0.day)
#https://inspurer.github.io/2018/12/03/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Apython%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/
import time
t0 = time.localtime()
wanted_time = time.strftime("%Y-%m-%d",t0)
```
### error: Microsoft Visual C++ 14.0 is required
```javascript
源码安装，但是没有 C++ 的编译环境

 
error: Microsoft Visual C++ 14.0 is required. Get it with "Microsoft Visual
C++ Build Tools": http://landinghub.visualstudio.com/visual-cpp-build-tools
如果是 Python 27 可以安装 Microsoft Visual C++ Compiler for Python  2.7 https://www.microsoft.com/en-us/download/details.aspx?id=44266
如果是 Python 3 可以安装 Visual C++ 2015 Build Tools http://landinghub.visualstudio.com/visual-cpp-build-tools
或者使用下载编译好的 exe 文件
或者使用 whl 格式的包
```
### 逗号引发的悲剧
```javascript
>>> a = [
...     'foo'
...     'bar',
...     'tree'
... ]
>>>
>>> b = 'foo' 'bar'
>>>
>>> print a
['foobar', 'tree']
>>> print b
foobar
>>>
也就是说 'foo' + 'bar' 等价于 'foo' 'bar'

再来看另外一个例子，注意第二行后面的逗号
 
>>> a = {'foo': 'bar'}
>>> b = a.get('foo'),
>>> c = a.get('foo')
>>> print(b)
('bar',)
>>> print(c)
bar
>>>
本来 b 应该是一个字符串，结果硬是变成了元组。https://www.restran.net/2015/11/07/python-comma-issue/
```
### Python获取Bing图片做壁纸
```javascript
http://jeffyang.top/Python/python%E8%8E%B7%E5%8F%96Bing%E5%9B%BE%E7%89%87%E5%81%9A%E5%A3%81%E7%BA%B8/
def get_url(day=0):
    url = "https://www.bing.com/HPImageArchive.aspx?format=js&idx=" + str(day) + "&n=1&nc=1509675905008&pid=hp&video=1"
    return url
def get_img(url, path="D://wallpaper/"):
    isExists = os.path.exists(path)#https://github.com/JianFengY/BingSpider
    if not isExists:
        os.makedirs(path) 
    html = requests.get(url)
    content = html.json()
    src = "https://www.bing.com" + content['images'][0]['url']
    urlretrieve(src, path + content['images'][0]['enddate'] + '.jpg')
def set_wallpaper_from_bmp(bmp_path):  
    reg_key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER, "Control Panel\\Desktop", 0, win32con.KEY_SET_VALUE)    
    win32api.RegSetValueEx(reg_key, "WallpaperStyle", 0, win32con.REG_SZ, "2")  
    win32api.RegSetValueEx(reg_key, "TileWallpaper", 0, win32con.REG_SZ, "0")  
    win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, bmp_path, win32con.SPIF_SENDWININICHANGE)  
def set_wallpaper(img_path):  
    isExists = os.path.exists(img_path)
    if isExists:
        img_dir = os.path.dirname(img_path)  
        bmpImage = Image.open(img_path)  
        new_bmp_path = os.path.join(img_dir, 'wallpaper.bmp')  
        bmpImage.save(new_bmp_path, "BMP")  
        set_wallpaper_from_bmp(new_bmp_path)  
        return True
    else:
        return False    
```
### 自动化测试工具from selenium import webdriver

```javascript
           from selenium.webdriver.common.by import By
           from selenium.webdriver.common.keys import Keys
           from selenium.webdriver.support import expected_conditions as EC
           from selenium.webdriver.support.wait import WebDriverWait
           
           browser = webdriver.Chrome()
           try:
               browser.get('https://www.baidu.com')
               input = browser.find_element_by_id('kw')
               input.send_keys('Python')
               input.send_keys(Keys.ENTER)
               wait = WebDriverWait(browser, 10)
               wait.until(EC.presence_of_element_located((By.ID, 'content_left')))
               print(browser.current_url)
               print(browser.get_cookies())
               print(browser.page_source)
           finally:
               browser.close()

browser = webdriver.Chrome()
browser.get('https://www.zhihu.com/explore')
browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')
browser.execute_script('alert("To Bottom")')

browser = webdriver.Chrome()
browser.implicitly_wait(10)
browser.get('https://www.zhihu.com/explore')
input = browser.find_element_by_class_name('zu-top-add-question')
print(input)

try:
    browser.get('https://www.baidu.com')
except TimeoutException:
    print('Time Out')
try:
    browser.find_element_by_id('hello')
except NoSuchElementException:
    print('No Element')
finally:
    browser.close()
    
    http://jeffyang.top/Python/%E7%88%AC%E8%99%AB/Python%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E5%BA%93selenium%E8%AF%A6%E8%A7%A3/
```
### 取交集，并集和差集
```javascript
a = ['a','b','c']，b = ['b','c','d']

交集:

print list(set(a).intersection(set(b)))

#或者
isec = [val for val in a if val in b]
print isec

并集
print list(set(a).union(set(b)))
差集
print list(set(b).difference(set(a))) # b-a
a = [[1,2],[3,4],[1,4]]
b = [x for j in a for x in j]
print b
[1, 2, 3, 4, 1, 4]
```
### list分割成固定长度子list
```javascript
def splite_list(splist, s):
    """splite a list to sub list contain s"""
    return [splist[i:i + s] for i in range(len(splist)) if i % s == 0]

#test
list1 = range(10)
splite_list(list1,2)
[[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]
```
### 生成英文字母表
```javascript
小写字母表
list(map(chr,list(range(97, 123))))

大写字母
list(map(chr,list(range(65, 91))))

小写字母表
import string
string.ascii_uppercase

大写字母
import string
string.ascii_lowercase
```
### 字典排序
```javascript
按键排序
dic = {'a':11 , 'b':5 , 'c': 7}

# 升序排序
sorted(dic.keys())

#　降序排序
sorted(dic.keys(), reverse=True)

按值排序
dic = {'a':11 , 'b':5 , 'c': 7}

# 升序
sorted(dic.items(), key = lambda x:x[1])

# 降序
sorted(dic.items(), key = lambda x:x[1],reverse =True)
```
### 微信公众号或网页自动导出
```javascript
https://juejin.im/post/5b4cc601f265da0f5a2545a9
https://github.com/MartinHan01/webpage2img
pip install pillow
init_filelist()
    #首先初始化webdirver
    driver = webdriver.Chrome()
    #设置输出路径
    dir = './result'
    
    for item in filelist:
        try:
            #获取图片路径，标题，以及输出路径
            #自动滚动，并截图保存
            pic_path,title = save_url(driver, item, dir)
            #开始合并我们刚刚截的所有图
            package_picture(pic_path, os.path.abspath(dir), title)
        except Exception as e :
            print(e)
python crop.py

```
### 批量压缩图片 
```javascript
pip install --upgrade tinify

import tinify
import os

tinify.key = '此处填入你的key'
path = "xxx" # 图片存放的路径

for dirpath, dirs, files in os.walk(path):
    for file in files:
        imgpath = os.path.join(dirpath, file)
        print("compressing ..."+ imgpath)
        tinify.from_file(imgpath).to_file(imgpath)
```
### 重试
```javascript
import random
from tenacity import retry
@retry
def do_something_unreliable():
    if random.randint(0, 10) > 1:
        raise IOError("Broken sauce, everything is hosed!!!111one")
    else:
        return "Awesome sauce!"
print(do_something_unreliable())

from tenacity import *
@retry(stop=(stop_after_delay(10) | stop_after_attempt(5)), wait=wait_fixed(2))
def stop_after_10_s_or_5_retries():
    print("Stopping after 10 seconds or 5 retries")
    raise Exception
    
 重试5次，每次间隔10秒，重试前等待2秒
   def func():
       pass
   for _ in range(0,100):
       while True:
           try:
               func()
           except SomeSpecificException:
               continue
           break
 def verify_url(url):
     import requests
     try:
         requests.get(url, timeout=10)
         return True
     except requests.exceptions.ConnectTimeout:
         return False
 def main():
     for _ in range(5):
         try:
             if verify_url(''):
                 return
             else:
                 continue
         except KeyError:
             continue
 if __name__ == '__main__':
     main()          
    https://zhangslob.github.io/2019/01/14/Python%E9%87%8D%E8%AF%95%E7%9A%84%E5%A4%9A%E9%87%8D%E6%96%B9%E6%B3%95/        
```
### 登录GitHub
```javascript
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import re
import requests
headers = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
    'Accept-Encoding': 'gzip, deflate, br',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    'Connection': 'keep-alive',
    'Host': 'github.com',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36'
}
s = requests.session()
s.headers.update(headers)
def get_token():
    url = 'https://github.com/login'
    response = s.get(url)
    pat = 'name=\"authenticity_token\" value=\"(.*?)\"'
    authenticity_token = re.findall(pat, response.text)[0]
    return authenticity_token
def login(authenticity_token, account, password):
    payload = {
        'commit': 'Sign in',
        'utf8': '\u2713',
        'authenticity_token': authenticity_token,
        'login': account,
        'password': password,
    }
    url = 'https://github.com/session'
    response = s.post(url, data=payload)
    print(response)
    # do whatever you want
if __name__ == '__main__':
    account, password = 'account', 'password'
    authenticity_token = get_token()
    login(authenticity_token, account, password)
    
```
### 多线程和多进程
```javascript
import concurrent.futures
import urllib.request
URLS = ['http://www.foxnews.com/',
        'http://www.cnn.com/',
        'http://europe.wsj.com/',
        'http://www.bbc.co.uk/',
        'http://some-made-up-domain.com/']
# Retrieve a single page and report the URL and contents
def load_url(url, timeout):
    with urllib.request.urlopen(url, timeout=timeout) as conn:
        return conn.read()
# We can use a with statement to ensure threads are cleaned up promptly
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Start the load operations and mark each future with its URL
    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}
    for future in concurrent.futures.as_completed(future_to_url):
        url = future_to_url[future]
        try:
            data = future.result()
        except Exception as exc:
            print('%r generated an exception: %s' % (url, exc))
        else:
            print('%r page is %d bytes' % (url, len(data)))
            
 import concurrent.futures
 import math
 PRIMES = [
     112272535095293,
     112582705942171,
     112272535095293,
     115280095190773,
     115797848077099,
     1099726899285419]
 def is_prime(n):
     if n % 2 == 0:
         return False
     sqrt_n = int(math.floor(math.sqrt(n)))
     for i in range(3, sqrt_n + 1, 2):
         if n % i == 0:
             return False
     return True
 def main():
     with concurrent.futures.ProcessPoolExecutor() as executor:
         for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
             print('%d is prime: %s' % (number, prime))
 if __name__ == '__main__':
     main()
     
     
     https://zhangslob.github.io/2018/07/03/%E5%BF%AB%E9%80%9F%E5%86%99%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB/           
```
###  Pandas 做数据分析
```javascript
import pandas as pd
import numpy as np

url = ('https://raw.github.com/pandas-dev/pandas/master/pandas/tests/data/tips.csv')
tips = pd.read_csv(url)
output = tips.head()
>>> output
   total_bill   tip     sex smoker  day    time  size
0       16.99  1.01  Female     No  Sun  Dinner     2
1       10.34  1.66    Male     No  Sun  Dinner     3
2       21.01  3.50    Male     No  Sun  Dinner     3
3       23.68  3.31    Male     No  Sun  Dinner     2
4       24.59  3.61  Female     No  Sun  Dinner     4

sql 语句： SELECT total_bill, tip, smoker, time FROM tips LIMIT 5;。

output = tips[['total_bill', 'tip', 'smoker', 'time']].head(5)

https://learnku.com/articles/29825


```
### 多线程
```javascript
线程 (Thread) 是操作系统能够进行运算调度的最小单位。它被包含在进程中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。同一进程中的多个线程共享进程中的全部系统资源。
以下演示使用多线程对一个变量值进行修改，在循环的次数不多时修改后变量的值是符合预期的，当增加循环次数后，变量最终的值并不符合预期。由此可见：线程之间资源是存在竞争的，修改同一份资源必须加互斥锁，同时需要避免死锁。

# coding=utf-8
import threading

# 定义一个字段。多线程执行+1操作
balance = 0

def worker1():
    global balance
    for i in range(1000):
        balance += 1
    print('线程1执行完成，balance='+str(balance))

def worker2():
    global balance
    for i in range(1000):
        balance += 1
    print('线程2执行完成，balance='+str(balance))

def main():
    # 构造线程对象
    t1 = threading.Thread(target=worker1)
    t2 = threading.Thread(target=worker2)
    # 开始执行
    t1.start()
    t2.start()

    """
    循环次数为1000时，程序输出：
        线程1执行完成，balance=1000
        线程2执行完成，balance=2000
    循环次数为1000000时，程序输出：
        线程1执行完成，balance=1180919
        线程2执行完成，balance=1179703
    """    

if __name__ == '__main__':
    main()
要想解决以下的问题，需要使用线程的锁对象，只需要对 worker1 和 woker2 方法进行修改。

# 创建一个互斥锁，默认是未锁定状态
mutex = threading.Lock()

def worker1():
    global balance
    for i in range(1000000):
        mutex.acquire()
        balance += 1
        mutex.release()
    print('线程1执行完成，balance=' + str(balance))

def worker2():
    global balance
    for i in range(1000000):
        mutex.acquire()
        balance += 1
        mutex.release()
    print('线程2执行完成，balance=' + str(balance))

"""
加了互斥锁之后的输出：
    线程1执行完成，balance=1941343
    线程2执行完成，balance=2000000
"""
特点：

线程执行的顺序是不确定的
主线程【进程】会等待所有子线程结束后才会退出，主线程【进程】结束么子线程必然结束
线程间共享资源
修改资源必要时需要加锁，同时避免死锁
占用的资源比进程少
线程并不是越多越快
由于 GIL 的原因，多线程并不是真正的并发，只是交替执行
https://learnku.com/articles/29367
```
### 尾递归 
```javascript
# 例子代码
def tail_recursion(n, total=0):
    if n == 0:
        return total
    else:
        return tail_recursion(n-1, total+n)
# 执行结果：
tail_recursion(5)
tail_recursion(4, 5)
tail_recursion(3, 9)
tail_recursion(2, 12)
tail_recursion(1, 14)
tail_recursion(0, 15)
5+4+3+2+1=15
```
### 获取公众号全部文章
```javascript
https://mp.weixin.qq.com/s/nkW2sYLcdsNTYTkk-4BeLA
import requests
import json
import time
from pymongo import MongoClient

url = 'http://mp.weixin.qq.com/mp/xxx'（公众号不让添加主页链接，xxx表示profile_ext)
#url='https://mp.weixin.qq.com/mp/profile_ext?action=getmsg&__biz=MzIyMjg2ODExMA==&f=json&offset=21&count=10&is_ok=1&scene=124&uin=NjQ3OTQwMTAy&key=a90c16d3bbfeedd04adeeda7bfc81049f486e81712f95a347e33fccfb9fe00841ec6a4d0984ce32f72fe5e8c479fd13c6680b5496cda322ab1bb2b81417a10ae277a861ad580e77cdf78edbf86212c08&pass_ticket=2vonvdf3N4L67te2BCa4ZqvIs1ed2MoeBqoznvfNSL%2BeKqF4YgHUvNEWLNczZovz&wxtoken=&appmsg_token=1015_jLHC7BDStvidMqo9YO55XLerjoP9z6UM70Q5vw~~&x5=0&f=json'
# Mongo配置
conn = MongoClient('127.0.0.1', 27017)
db = conn.wx  #连接wx数据库，没有则自动创建
mongo_wx = db.article  #使用article集合，没有则自动创建

def get_wx_article(biz, uin, key, index=0, count=10):
    offset = (index + 1) * count
    params = {
        '__biz': biz,
        'uin': uin,
        'key': key,
        'offset': offset,
        'count': count,
        'action': 'getmsg',
        'f': 'json'
    }

    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'
    }

    response = requests.get(url=url, params=params, headers=headers)
    resp_json = response.json()
    if resp_json.get('errmsg') == 'ok':
        resp_json = response.json()
        # 是否还有分页数据， 用于判断return的值
        can_msg_continue = resp_json['can_msg_continue']
        # 当前分页文章数
        msg_count = resp_json['msg_count']
        general_msg_list = json.loads(resp_json['general_msg_list'])
        list = general_msg_list.get('list')
        print(list, "**************")
        for i in list:
            app_msg_ext_info = i['app_msg_ext_info']
            # 标题
            title = app_msg_ext_info['title']
            # 文章地址
            content_url = app_msg_ext_info['content_url']
            # 封面图
            cover = app_msg_ext_info['cover']

            # 发布时间
            datetime = i['comm_msg_info']['datetime']
            datetime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(datetime))

            mongo_wx.insert({
                'title': title,
                'content_url': content_url,
                'cover': cover,
                'datetime': datetime
            })
        if can_msg_continue == 1:
            return True
        return False
    else:
        print('获取文章异常...')
        return False


if __name__ == '__main__':
    biz = 'Mzg4MTA2Nzg0NA=='
    uin = 'NDIyMTI5NDM1'
    key = '20a680e825f03f1e7f38f326772e54e7dc0fd02ffba17e92730ba3f0a0329c5ed310b0bd55b3c0b1f122e5896c6261df2eaea4036ab5a5d32dbdbcb0a638f5f3605cf1821decf486bb6eb4d92d36c620'
    index = 0
    while 1:
        print(f'开始抓取公众号第{index + 1} 页文章.')
        flag = get_wx_article(biz, uin, key, index=index)
        # 防止和谐，暂停8秒
        time.sleep(8)
        index += 1
        if not flag:
            print('公众号文章已全部抓取完毕，退出程序.')
            break

        print(f'..........准备抓取公众号第{index + 1} 页文章.')

```
### PHP 与 Python 代码对比
```javascript
# -*- coding: utf-8 -*-
n = 0
https://learnku.com/articles/30958
while n < 3:
    #累计次数,用于循环条件
    n = n + 1
    #定义账号和密码
    uname = 'tangqingsong'
    pwd = '123123'
    #接收参数
    username = input('请输入用户名:')
    password = input('请输入密码:')

    #判断用户输入的账号和密码是否正确，正确将提示成功，并且退出循环体
    if uname == username and pwd == password:
        print ('恭喜你，登陆成功~')
        break
    #三次机会用完的时候,提示错误次数，并告知即将退出
    elif n == 3:
        print('已错误', n, '次，即将退出...')
    #如果在三次以内,提示还剩下几次机会
    else:
        print('抱歉，账号或密码不正确，你还有', 3 - n, '次机会')
        
 $n = 0;
 
 while ($n < 3) {
     #累计次数,用于循环条件
     $n = $n + 1;
     #定义账号和密码
     $uname = 'tangqingsong';
     $pwd = '123123';
     #接收参数
     fwrite(STDOUT, '请输入用户名：');
     $username = trim(fgets(STDIN));
     fwrite(STDOUT, '请输入密码：');
     $password = trim(fgets(STDIN));
 
     #判断用户输入的账号和密码是否正确，正确将提示成功，并且退出循环体
     if ($uname == $username and $pwd == $password) {
         print_r('恭喜你，登陆成功~');
         break;
         #三次机会用完的时候,提示错误次数，并告知即将退出
     } elseif ($n == 3) {
         print_r("已错误{$n}次，即将退出...");
     } else {
         #如果在三次以内,提示还剩下几次机会
         $j = 3 - $n;
         print_r("抱歉，账号或密码不正确，你还有{$j}次机会");
     }
 }       
```
### python2与3的编码
```javascript
Python2有两种表示字符序列的类型，分别叫做str和Unicode，str实例包含原始的8位值；而Unicode的实例，则包含Unicode字符。

str格式本质含义是“某种编码格式”，绝大多数情况下，被引号框起来的字符串，就是str，这时的字符串编码类型，其实就是你Python文件的编码类型，比如在Windows里，默认用的是GBK编码。
Unicode格式的含义就是“用unicode编码的字符串”。Python在进入2.0版后正式定义了了Unicode字符串这个奇怪的特性，目的就是为了处理太多种语言编码的文本。从那时开始，Python语言中的字符串类型就分为两种：一种是传统的Python字符串（各种花样编码），另一种则是新出现的Unicode
Python3也有两种表示字符序列的类型：bytes和str。前者的实例包含原始的8位值，后者的实例包含Unicode字符,可以说python3的str，就是python2的Unicode

str格式的定义变更为”Unicode类型的字符串“，也就是说在默认情况下，被引号框起来的字符串，是使用Unicode编码的。
而“不是Unicode的某种编码格式”，比如UTF-8、GBK，这些编码方式被定义为了bytes，这里的bytes和py2中的str有很多相似的地方
我们需要编写两个辅助（helper）函数，以便在这两种情况之间转换，使得转换后的输入数据能够符合开发者的预期

#在Python3中，我们需要编写接受str或bytes，并总是返回str的方法：
def to_str(bytes_or_str):
  if isinstance(bytes_or_str, bytes):
    value = bytes_or_str.decode('utf-8')
  else:
    value = bytes_or_str
  return value # Instance of str
  
#另外，还需要编写接受str或bytes，并总是返回bytes的方法：
def to_bytes(bytes_or_str):
  if isinstance(bytes_or_str, str):
    value = bytes_or_str.encode('utf-8)
  else:
    value = bytes_or_str
  return value # Instance of bytes
  
#在Python2中，需要编写接受str或unicode，并总是返回unicode的方法：
#python2
def to_unicode(unicode_or_str):
  if isinstance(unicode_or_str, str):
    value = unicode_or_str.decode('utf-8')
  else:
    value = unicode_or_str
  return value # Instance of unicode
  
#另外，还需要编写接受str或unicode，并总是返回str的方法：
#Python2
def to_str(unicode_or_str):
  if isinstance(unicode_or_str, unicode):
    value = unicode_or_str.encode('utf-8')
  else:
    value = unicode_or_str
  reutrn vlaue # Instance of str
  https://xin053.github.io/2016/10/30/Python%E5%AD%A6%E4%B9%A0%E9%87%8D%E7%82%B9%E6%91%98%E8%AE%B0/
  
   str包含一个encode方法，使用特定编码将该字符串其转换为一个bytes，这称之为编码
  。bytes类包含了一个decode方法，也接受一个编码作为单个必要参数，并返回一个str，
  这称之为解码。
 
  s='n排球①’
  b1=s.encode（'utf-8'）
  b2=s.encode（）
  print（b1）
  print（b2）
  b\xcf\x80\xe6\x8e\x92\xe7\x9e\x83\xe3\×8l\xae'
  b'\xcf\×80\xe6\x8e\x92\xe7\x9e\x83\xe3\x8l\xae'
  
  inport sys 
  print（sys.platform）
  print（sys.getdefaultencoding（））
  win32utf-8
  可以看出我这个平台默认选择的就是utf-8编码方式。
  b=b'\xe6lx8e\x92\xe7\x9e\x83'
  s1=b.decode（encoding='utf-8"）
  s2=b.decode（）
  s3=b.decode（encoding='latin-1'）
  print（s1）
  print（s2）
  print（s3）
  排球
  排球
  e2'cf
  
  >>> '请'.encode('unicode-escape')
  b'\\u8bf7'
  >>> b'\u8bf7'.decode('unicode-escape')
  '请'
  
  s='apple'
  b=b'apple'
  print（b）
  print（type（b））
  print（s）
  print（type（s））
  b'apple'
  <class'bytes'>
  apple
  <class'str'>
  再近距离的看看bytes类型字节字符串，本质上它就是一串单字节16进制数b=b'apple' https://www.zhihu.com/question/35584979
  print（b[0]）
  print（b[1：]）
  print（1ist（b））
  97
  b'pple'
  [97，112，112，188，101]
  
  s=' AABec'
  with open(' utf-8data','w', encoding=' utf-8") as f: ' +
   'f. urite(s)
  with open(' utf-8data','r', encoding=' utf-8') as f: 
  u_str=f. read()
  print(u_str)
  AABeC
  with open(' utf-8data",' rb') as f: byte_str=f. read()
  print(byte_str)
  print(byte_str. decode(encoding=' utf-8))
  b'A\ XC3\X84B\ xC3\ xa8c'
  AABeC
```
### Win10 下 Python2 与 Python3 兼容问题
```javascript
新旧2个文件，加入环境变量
python2.bat

@echo off

rename "C:\Program Files\Python37\python.exe" python.exe.disabled
rename "C:\Program Files\Python37\Scripts\pip.exe" pip.exe.disabled
python3.bat

@echo off

rename "C:\Program Files\Python37\python.exe.disabled" python.exe
rename "C:\Program Files\Python37\Scripts\pip.exe.disabled" pip.exe

https://learnku.com/articles/31141
```
### 剪刀、石头、布
```javascript
#剪刀、石头、布
import random
guess_list = ["石头", "剪刀", "布"]
win_combination = [["布", "石头"], ["石头", "剪刀"], ["剪刀", "布"]]
while True:
    people = input('请输入：石头,剪刀,布\n').strip()
    computer = random.choice(guess_list)
    print('电脑出拳：'+computer)
    if people not in guess_list:
        print('咦~~弄啥类你！~~~')
        continue
    if computer == people:
        print ('平手，再玩一次！')
    elif [computer, people] in win_combination:
        print ('电脑获胜！继续吧~~~')
    else:
        print ('你获胜！')
        break
    print('---------------------------------')

print('Press any key to exit');
input();                                        #防止控制台输出秒退
```
### md5和sha1加密
```javascript

import hashlib
 
data =  'This a md5 test!'
hash_md5 = hashlib.md5(data)

hash_md5.hexdigest()
MD5不仅仅是上面这个例子这样用来处理字符串，还有更广泛的用途：
加密网站注册用户的密码。 （但去年的各大网站密码泄漏事件确实让人蛋疼……）
网站用户上传图片 / 文件后，计算出MD5值作为文件名。（MD5可以保证唯一性）
key-value数据库中使用MD5值作为key。
比较两个文件是否相同。（大家在下载一些资源的时候，就会发现网站提供了MD5值，就是用来检测文件是否被篡改）
用MD5来检测两个文件是否相同，但想想，如果是两个很大的文件，担心内存不够用，这时怎么办？
这就要使用 update 方法了。代码如下：
import hashlib

def get_file_md5(f):
    m = hashlib.md5()

    while True:
        data = f.read(10240)
        if not data:
            break

        m.update(data)
    return m.hexdigest()


with open(YOUR_FILE, 'r') as f:
    file_md5 = get_file_md5(f)
(windows 用户 要使用 'rb'方式打开文件)
大家可以用下面这段代码验证一下：
import hashlib

x = hashlib.md5()
x.update('hello, ')
x.update('python')
x.hexdigest()

hashlib.md5('hello, python').hexdigest()
这两次的输出是一样的。
SHA1 也是一样的用法。https://p0sec.net/index.php/archives/33/

```
###  concat 组合 dataframe
```javascript
import pandas as pd
india_weather = pd.DataFrame({
    'city': ['mumbai', 'delhi', 'banglore'],
    'temperature': [32, 34, 30],
    'humidity': [80, 60, 72]
})
us_weather = pd.DataFrame({
    'city': ['newyork', 'chicago', 'orlando'],
    'temperature': [21, 24, 32],
    'humidity': [68, 65, 70]
})
df = pd.concat([india_weather, us_weather])
df = pd.concat([india_weather, us_weather], ignore_index=True)

df = pd.concat([india_weather, us_weather], keys=['india', 'us'])

df.loc['india']
df = pd.concat([temperature_df, windspeed_df], axis=1)
https://learnku.com/articles/26025

```
### 数学问题
```javascript
数学问题：假如一个星球有 100 人，每年人数翻一倍。那么，多少年之后人数才有 100 万人
>>> p=100
>>> y=0
>>> while p<1000000:
...       p*=2
...       y+=1
...
>>> y
14

```
[python3文档](https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html)

[从零开始的 TensorFlow tensorflow.google.cn/](https://learnku.com/articles/31315)

[Redis 结合 flask 及 vue 实现 SSE 在线聊天](https://learnku.com/articles/30542)

[Python社区文章](http://www.python88.com/user/6732)

[python版-批量中文文件名转英文](http://martinhan.site/2017-04-15/python%E7%89%88-%E6%89%B9%E9%87%8F%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E8%BD%AC%E8%8B%B1%E6%96%87.html)

[模拟登录一些知名的网站，为了方便爬取需要登录的网站fuck login](https://github.com/xchaoinfo/fuck-login)

[pandas](https://finthon.com/data-processing/pandas/)

[Python 快速打包发布软件PyPi上](https://yangfangs.github.io/2018/08/06/python-distribution-packages/)

[Python进阶](https://finthon.com/python-advance/)

[Python 进程管理工具 Supervisor 使用教程](https://www.restran.net/2015/10/04/supervisord-tutorial/)

[Python 入门教程 - 课程大纲](https://www.restran.net/2017/02/25/python-tutorial-outline/)

[网易云音乐歌曲评论爬虫]()

[爬取豆瓣短评之《后来的我们》](http://python.jobbole.com/89161/)

[python奇技淫巧](https://www.techug.com/post/python-tips-and-trick.html)

[爆破的方式收集子域名https://5alt.me/tools/](https://github.com/5alt/ZeroScan)

[python模拟登陆一些大型网站，还有一些简单的爬虫](https://github.com/CriseLYJ/awesome-python-login-model)


[python教程](http://www.liujiangblog.com/course/python/1)