---
title: python代码段收集
date: 2019-02-26 19:45:56
tags:
- python
---
### 5 行代码入门 Python 爬虫
```javascript
import requests
import pandas as pd
from bs4 import BeautifulSoup
from lxml import etree
import time
import pymysql
from sqlalchemy import create_engine
from urllib.parse import urlencode  # 编码 URL 字符串https://www.makcyun.top/web_scraping_withpython18.html

start_time = time.time()  #计算程序运行时间
def get_one_page(i):
	try:
		headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36'
        }
		paras = {
		'reportTime': '2017-12-31',
		#可以改报告日期，比如2018-6-30获得的就是该季度的信息
		'pageNum': i   #页码
		}
		url = 'http://s.askci.com/stock/a/?' + urlencode(paras)
		response = requests.get(url,headers = headers)
		if response.status_code == 200:
			return response.text
		return None
	except RequestException:
		print('爬取失败')

def parse_one_page(html):
	soup = BeautifulSoup(html,'lxml')
	content = soup.select('#myTable04')[0] #[0]将返回的list改为bs4类型
	tbl = pd.read_html(content.prettify(),header = 0)[0]
	# prettify()优化代码,[0]从pd.read_html返回的list中提取出DataFrame
	tbl.rename(columns = {'序号':'serial_number', '股票代码':'stock_code', '股票简称':'stock_abbre', '公司名称':'company_name', '省份':'province', '城市':'city', '主营业务收入(201712)':'main_bussiness_income', '净利润(201712)':'net_profit', '员工人数':'employees', '上市日期':'listing_date', '招股书':'zhaogushu', '公司财报':'financial_report', '行业分类':'industry_classification', '产品类型':'industry_type', '主营业务':'main_business'},inplace = True)
	return tbl

def generate_mysql():
	conn = pymysql.connect(
		host='localhost',
		user='root',
		password='******',
		port=3306,
		charset = 'utf8',  
		db = 'wade')
	cursor = conn.cursor()

	sql = 'CREATE TABLE IF NOT EXISTS listed_company (serial_number INT(20) NOT NULL,stock_code INT(20) ,stock_abbre VARCHAR(20) ,company_name VARCHAR(20) ,province VARCHAR(20) ,city VARCHAR(20) ,main_bussiness_income VARCHAR(20) ,net_profit VARCHAR(20) ,employees INT(20) ,listing_date DATETIME(0) ,zhaogushu VARCHAR(20) ,financial_report VARCHAR(20) , industry_classification VARCHAR(20) ,industry_type VARCHAR(100) ,main_business VARCHAR(200) ,PRIMARY KEY (serial_number))'
	cursor.execute(sql)
	conn.close()
	
def write_to_sql(tbl, db = 'wade'):
    engine = create_engine('mysql+pymysql://root:******@localhost:3306/{0}?charset=utf8'.format(db))
    try:
    	tbl.to_sql('listed_company2',con = engine,if_exists='append',index=False)
    	# append表示在原有表基础上增加，但该表要有表头
    except Exception as e:
    	print(e)

def main(page):
    generate_mysql()
	for i in range(1,page):  
		html = get_one_page(i)
		tbl = parse_one_page(html)
		write_to_sql(tbl)
		
# # 单进程
if __name__ == '__main__':	
	main(178)
	endtime = time.time()-start_time
	print('程序运行了%.2f秒' %endtime)
	
# 多进程
from multiprocessing import Pool
if __name__ == '__main__':
 	pool = Pool(4)
 	pool.map(main, [i for i in range(1,178)])  #共有178页
	endtime = time.time()-start_time
	print('程序运行了%.2f秒' %(time.time()-start_time))
	
import pandas as pd
import csv
for i in range(1,178):  # 爬取全部页
	tb = pd.read_html('http://s.askci.com/stock/a/?reportTime=2017-12-31&pageNum=%s' % (str(i)))[3] 
	tb.to_csv(r'1.csv', mode='a', encoding='utf_8_sig', header=1, index=0)	
	
```
### 时间处理
```javascript
# -*- coding: utf-8 -*-
# author:           inpurer(月小水长)
# pc_type           lenovo
# create_date:      2018/12/3
# file_name:        timetest.py
# description:      月小水长，热血未凉

import time

t0 = time.time()
#description:   输出当前时间距离1970.1.1的秒数,精确到小数点后6位，也叫做时间戳
#output sample: 1543799532.602318
print(t0)

t1 = time.localtime(t0)
#description:   把时间戳转成元组,包含七个元素,前六个见名知意,tm_wday是指今天是当前周的第几天(index from 0),tm_yday类似,tm_isdst是否是夏令时,不用关心
#output sample: time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=22, tm_sec=24, tm_wday=0, tm_yday=337, tm_isdst=0)
print(t1)
#so,可以这样输出今天是今年的第多少天
print(t1[-2]+1)


#下面是对该元组的格式化

#description:   简单可读形式
#output sample: Mon Dec  3 09:31:18 2018
t2 = time.asctime(t1)
print(t2)

#description:   可通过参数设置成各种形式，下面是一种标准形式,各参数见名知意
#output sample: 2018-12-03 09:33:36
t3 = time.strftime("%Y-%m-%d %H:%M:%S", t1)
print(t3)
#%y 两位数的年份表示（00-99）
# %Y 四位数的年份表示（000-9999）
# %m 月份（01-12）
# %d 月内中的一天（0-31）
# %H 24小时制小时数（0-23）
# %I 12小时制小时数（01-12）
# %M 分钟数（00=59）
# %S 秒（00-59）
#
# %a 本地简化星期名称
# %A 本地完整星期名称
# %b 本地简化的月份名称
# %B 本地完整的月份名称
# %c 本地相应的日期表示和时间表示
# %j 年内的一天（001-366）
# %p 本地A.M.或P.M.的等价符
# %U 一年中的星期数（00-53）星期天为星期的开始
# %w 星期（0-6），星期天为星期的开始
# %W 一年中的星期数（00-53）星期一为星期的开始
# %x 本地相应的日期表示
# %X 本地相应的时间表示
# %Z 当前时区的名称
# %% %号本身


# 下面是把格式化字符串转成元组
# description:      第一个参数个格式化后的字符串,后一个参数和格式化对应，便于反格式化
# output sample:    time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=47, tm_sec=7, tm_wday=0, tm_yday=337, tm_isdst=-1)
t4 = time.strptime(t3,'%Y-%m-%d %H:%M:%S')
print(t4)

# 把元组转成时间戳
#description:   是time.localtime的反函数,不过由于格式化的原因，精度有所下降
#output sample: 1543801627.0
t5 = time.mktime(t4)
print(t5)

# -*- coding: utf-8 -*-
# author:           inpurer(月小水长)
# pc_type           lenovo
# create_date:      2018/12/3
# file_name:        timetest.py
# description:      月小水长，热血未凉

import datetime

#通过datetime.datetime.now()可以获得当前日期时间的一个实例
#这个实例是一个datetime类对象而不是字符串
#虽然直接打印该实例输出的是一个字符串,只是调用datetime实现的__str__方法而已
t0 = datetime.datetime.now()
print(t0)           #print: 2018-12-03 12:55:49.905971
print(type(t0))     #print: <class 'datetime.datetime'>

#然后就可以通过对象名.的方法输出各个时间信息,该信息是一个int类型
print(t0.year)          #print: 2018
print(type(t0.year))    #print: <class 'int'>
print(t0.month)
print(t0.day)
print(t0.hour)
print(t0.minute)
print(t0.second)

import datetime
t0 = datetime.datetime.now()
#注意year/month/day都是int类型，不像java那样可以直接拼接字符串和数字
wanted_time = str(t0.year)+"-"+str(t0.month)+"-"+str(t0.day)
#https://inspurer.github.io/2018/12/03/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Apython%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/
import time
t0 = time.localtime()
wanted_time = time.strftime("%Y-%m-%d",t0)
```
### error: Microsoft Visual C++ 14.0 is required
```javascript
源码安装，但是没有 C++ 的编译环境

 
error: Microsoft Visual C++ 14.0 is required. Get it with "Microsoft Visual
C++ Build Tools": http://landinghub.visualstudio.com/visual-cpp-build-tools
如果是 Python 27 可以安装 Microsoft Visual C++ Compiler for Python  2.7 https://www.microsoft.com/en-us/download/details.aspx?id=44266
如果是 Python 3 可以安装 Visual C++ 2015 Build Tools http://landinghub.visualstudio.com/visual-cpp-build-tools
或者使用下载编译好的 exe 文件
或者使用 whl 格式的包
```
### 逗号引发的悲剧
```javascript
>>> a = [
...     'foo'
...     'bar',
...     'tree'
... ]
>>>
>>> b = 'foo' 'bar'
>>>
>>> print a
['foobar', 'tree']
>>> print b
foobar
>>>
也就是说 'foo' + 'bar' 等价于 'foo' 'bar'

再来看另外一个例子，注意第二行后面的逗号
 
>>> a = {'foo': 'bar'}
>>> b = a.get('foo'),
>>> c = a.get('foo')
>>> print(b)
('bar',)
>>> print(c)
bar
>>>
本来 b 应该是一个字符串，结果硬是变成了元组。https://www.restran.net/2015/11/07/python-comma-issue/
```
### Python获取Bing图片做壁纸
```javascript
http://jeffyang.top/Python/python%E8%8E%B7%E5%8F%96Bing%E5%9B%BE%E7%89%87%E5%81%9A%E5%A3%81%E7%BA%B8/
def get_url(day=0):
    url = "https://www.bing.com/HPImageArchive.aspx?format=js&idx=" + str(day) + "&n=1&nc=1509675905008&pid=hp&video=1"
    return url
def get_img(url, path="D://wallpaper/"):
    isExists = os.path.exists(path)#https://github.com/JianFengY/BingSpider
    if not isExists:
        os.makedirs(path) 
    html = requests.get(url)
    content = html.json()
    src = "https://www.bing.com" + content['images'][0]['url']
    urlretrieve(src, path + content['images'][0]['enddate'] + '.jpg')
def set_wallpaper_from_bmp(bmp_path):  
    reg_key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER, "Control Panel\\Desktop", 0, win32con.KEY_SET_VALUE)    
    win32api.RegSetValueEx(reg_key, "WallpaperStyle", 0, win32con.REG_SZ, "2")  
    win32api.RegSetValueEx(reg_key, "TileWallpaper", 0, win32con.REG_SZ, "0")  
    win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, bmp_path, win32con.SPIF_SENDWININICHANGE)  
def set_wallpaper(img_path):  
    isExists = os.path.exists(img_path)
    if isExists:
        img_dir = os.path.dirname(img_path)  
        bmpImage = Image.open(img_path)  
        new_bmp_path = os.path.join(img_dir, 'wallpaper.bmp')  
        bmpImage.save(new_bmp_path, "BMP")  
        set_wallpaper_from_bmp(new_bmp_path)  
        return True
    else:
        return False    
```
### 自动化测试工具from selenium import webdriver

```javascript
           from selenium.webdriver.common.by import By
           from selenium.webdriver.common.keys import Keys
           from selenium.webdriver.support import expected_conditions as EC
           from selenium.webdriver.support.wait import WebDriverWait
           
           browser = webdriver.Chrome()
           try:
               browser.get('https://www.baidu.com')
               input = browser.find_element_by_id('kw')
               input.send_keys('Python')
               input.send_keys(Keys.ENTER)
               wait = WebDriverWait(browser, 10)
               wait.until(EC.presence_of_element_located((By.ID, 'content_left')))
               print(browser.current_url)
               print(browser.get_cookies())
               print(browser.page_source)
           finally:
               browser.close()

browser = webdriver.Chrome()
browser.get('https://www.zhihu.com/explore')
browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')
browser.execute_script('alert("To Bottom")')

browser = webdriver.Chrome()
browser.implicitly_wait(10)
browser.get('https://www.zhihu.com/explore')
input = browser.find_element_by_class_name('zu-top-add-question')
print(input)

try:
    browser.get('https://www.baidu.com')
except TimeoutException:
    print('Time Out')
try:
    browser.find_element_by_id('hello')
except NoSuchElementException:
    print('No Element')
finally:
    browser.close()
    
    http://jeffyang.top/Python/%E7%88%AC%E8%99%AB/Python%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E5%BA%93selenium%E8%AF%A6%E8%A7%A3/
```
### 取交集，并集和差集
```javascript
a = ['a','b','c']，b = ['b','c','d']

交集:

print list(set(a).intersection(set(b)))

#或者
isec = [val for val in a if val in b]
print isec

并集
print list(set(a).union(set(b)))
差集
print list(set(b).difference(set(a))) # b-a
a = [[1,2],[3,4],[1,4]]
b = [x for j in a for x in j]
print b
[1, 2, 3, 4, 1, 4]
```
### list分割成固定长度子list
```javascript
def splite_list(splist, s):
    """splite a list to sub list contain s"""
    return [splist[i:i + s] for i in range(len(splist)) if i % s == 0]

#test
list1 = range(10)
splite_list(list1,2)
[[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]
```
### 生成英文字母表
```javascript
小写字母表
list(map(chr,list(range(97, 123))))

大写字母
list(map(chr,list(range(65, 91))))

小写字母表
import string
string.ascii_uppercase

大写字母
import string
string.ascii_lowercase
```
### 字典排序
```javascript
按键排序
dic = {'a':11 , 'b':5 , 'c': 7}

# 升序排序
sorted(dic.keys())

#　降序排序
sorted(dic.keys(), reverse=True)

按值排序
dic = {'a':11 , 'b':5 , 'c': 7}

# 升序
sorted(dic.items(), key = lambda x:x[1])

# 降序
sorted(dic.items(), key = lambda x:x[1],reverse =True)
```
### 微信公众号或网页自动导出
```javascript
https://juejin.im/post/5b4cc601f265da0f5a2545a9
https://github.com/MartinHan01/webpage2img
pip install pillow
init_filelist()
    #首先初始化webdirver
    driver = webdriver.Chrome()
    #设置输出路径
    dir = './result'
    
    for item in filelist:
        try:
            #获取图片路径，标题，以及输出路径
            #自动滚动，并截图保存
            pic_path,title = save_url(driver, item, dir)
            #开始合并我们刚刚截的所有图
            package_picture(pic_path, os.path.abspath(dir), title)
        except Exception as e :
            print(e)
python crop.py

```
### 批量压缩图片 
```javascript
pip install --upgrade tinify

import tinify
import os

tinify.key = '此处填入你的key'
path = "xxx" # 图片存放的路径

for dirpath, dirs, files in os.walk(path):
    for file in files:
        imgpath = os.path.join(dirpath, file)
        print("compressing ..."+ imgpath)
        tinify.from_file(imgpath).to_file(imgpath)
```
### 重试
```javascript
import random
from tenacity import retry
@retry
def do_something_unreliable():
    if random.randint(0, 10) > 1:
        raise IOError("Broken sauce, everything is hosed!!!111one")
    else:
        return "Awesome sauce!"
print(do_something_unreliable())

from tenacity import *
@retry(stop=(stop_after_delay(10) | stop_after_attempt(5)), wait=wait_fixed(2))
def stop_after_10_s_or_5_retries():
    print("Stopping after 10 seconds or 5 retries")
    raise Exception
    
 重试5次，每次间隔10秒，重试前等待2秒
   def func():
       pass
   for _ in range(0,100):
       while True:
           try:
               func()
           except SomeSpecificException:
               continue
           break
 def verify_url(url):
     import requests
     try:
         requests.get(url, timeout=10)
         return True
     except requests.exceptions.ConnectTimeout:
         return False
 def main():
     for _ in range(5):
         try:
             if verify_url(''):
                 return
             else:
                 continue
         except KeyError:
             continue
 if __name__ == '__main__':
     main()          
    https://zhangslob.github.io/2019/01/14/Python%E9%87%8D%E8%AF%95%E7%9A%84%E5%A4%9A%E9%87%8D%E6%96%B9%E6%B3%95/        
```
### 登录GitHub
```javascript
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import re
import requests
headers = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
    'Accept-Encoding': 'gzip, deflate, br',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    'Connection': 'keep-alive',
    'Host': 'github.com',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36'
}
s = requests.session()
s.headers.update(headers)
def get_token():
    url = 'https://github.com/login'
    response = s.get(url)
    pat = 'name=\"authenticity_token\" value=\"(.*?)\"'
    authenticity_token = re.findall(pat, response.text)[0]
    return authenticity_token
def login(authenticity_token, account, password):
    payload = {
        'commit': 'Sign in',
        'utf8': '\u2713',
        'authenticity_token': authenticity_token,
        'login': account,
        'password': password,
    }
    url = 'https://github.com/session'
    response = s.post(url, data=payload)
    print(response)
    # do whatever you want
if __name__ == '__main__':
    account, password = 'account', 'password'
    authenticity_token = get_token()
    login(authenticity_token, account, password)
    
```
### 多线程和多进程
```javascript
import concurrent.futures
import urllib.request
URLS = ['http://www.foxnews.com/',
        'http://www.cnn.com/',
        'http://europe.wsj.com/',
        'http://www.bbc.co.uk/',
        'http://some-made-up-domain.com/']
# Retrieve a single page and report the URL and contents
def load_url(url, timeout):
    with urllib.request.urlopen(url, timeout=timeout) as conn:
        return conn.read()
# We can use a with statement to ensure threads are cleaned up promptly
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Start the load operations and mark each future with its URL
    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}
    for future in concurrent.futures.as_completed(future_to_url):
        url = future_to_url[future]
        try:
            data = future.result()
        except Exception as exc:
            print('%r generated an exception: %s' % (url, exc))
        else:
            print('%r page is %d bytes' % (url, len(data)))
            
 import concurrent.futures
 import math
 PRIMES = [
     112272535095293,
     112582705942171,
     112272535095293,
     115280095190773,
     115797848077099,
     1099726899285419]
 def is_prime(n):
     if n % 2 == 0:
         return False
     sqrt_n = int(math.floor(math.sqrt(n)))
     for i in range(3, sqrt_n + 1, 2):
         if n % i == 0:
             return False
     return True
 def main():
     with concurrent.futures.ProcessPoolExecutor() as executor:
         for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
             print('%d is prime: %s' % (number, prime))
 if __name__ == '__main__':
     main()
     
     
     https://zhangslob.github.io/2018/07/03/%E5%BF%AB%E9%80%9F%E5%86%99%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB/           
```
###  Pandas 做数据分析
```javascript
import pandas as pd
import numpy as np

url = ('https://raw.github.com/pandas-dev/pandas/master/pandas/tests/data/tips.csv')
tips = pd.read_csv(url)
output = tips.head()
>>> output
   total_bill   tip     sex smoker  day    time  size
0       16.99  1.01  Female     No  Sun  Dinner     2
1       10.34  1.66    Male     No  Sun  Dinner     3
2       21.01  3.50    Male     No  Sun  Dinner     3
3       23.68  3.31    Male     No  Sun  Dinner     2
4       24.59  3.61  Female     No  Sun  Dinner     4

sql 语句： SELECT total_bill, tip, smoker, time FROM tips LIMIT 5;。

output = tips[['total_bill', 'tip', 'smoker', 'time']].head(5)

https://learnku.com/articles/29825


```
### 多线程
```javascript
线程 (Thread) 是操作系统能够进行运算调度的最小单位。它被包含在进程中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。同一进程中的多个线程共享进程中的全部系统资源。
以下演示使用多线程对一个变量值进行修改，在循环的次数不多时修改后变量的值是符合预期的，当增加循环次数后，变量最终的值并不符合预期。由此可见：线程之间资源是存在竞争的，修改同一份资源必须加互斥锁，同时需要避免死锁。

# coding=utf-8
import threading

# 定义一个字段。多线程执行+1操作
balance = 0

def worker1():
    global balance
    for i in range(1000):
        balance += 1
    print('线程1执行完成，balance='+str(balance))

def worker2():
    global balance
    for i in range(1000):
        balance += 1
    print('线程2执行完成，balance='+str(balance))

def main():
    # 构造线程对象
    t1 = threading.Thread(target=worker1)
    t2 = threading.Thread(target=worker2)
    # 开始执行
    t1.start()
    t2.start()

    """
    循环次数为1000时，程序输出：
        线程1执行完成，balance=1000
        线程2执行完成，balance=2000
    循环次数为1000000时，程序输出：
        线程1执行完成，balance=1180919
        线程2执行完成，balance=1179703
    """    

if __name__ == '__main__':
    main()
要想解决以下的问题，需要使用线程的锁对象，只需要对 worker1 和 woker2 方法进行修改。

# 创建一个互斥锁，默认是未锁定状态
mutex = threading.Lock()

def worker1():
    global balance
    for i in range(1000000):
        mutex.acquire()
        balance += 1
        mutex.release()
    print('线程1执行完成，balance=' + str(balance))

def worker2():
    global balance
    for i in range(1000000):
        mutex.acquire()
        balance += 1
        mutex.release()
    print('线程2执行完成，balance=' + str(balance))

"""
加了互斥锁之后的输出：
    线程1执行完成，balance=1941343
    线程2执行完成，balance=2000000
"""
特点：

线程执行的顺序是不确定的
主线程【进程】会等待所有子线程结束后才会退出，主线程【进程】结束么子线程必然结束
线程间共享资源
修改资源必要时需要加锁，同时避免死锁
占用的资源比进程少
线程并不是越多越快
由于 GIL 的原因，多线程并不是真正的并发，只是交替执行
https://learnku.com/articles/29367
```
### 尾递归 
```javascript
# 例子代码
def tail_recursion(n, total=0):
    if n == 0:
        return total
    else:
        return tail_recursion(n-1, total+n)
# 执行结果：
tail_recursion(5)
tail_recursion(4, 5)
tail_recursion(3, 9)
tail_recursion(2, 12)
tail_recursion(1, 14)
tail_recursion(0, 15)
5+4+3+2+1=15
```
### 获取公众号全部文章
```javascript
https://mp.weixin.qq.com/s/nkW2sYLcdsNTYTkk-4BeLA
import requests
import json
import time
from pymongo import MongoClient

url = 'http://mp.weixin.qq.com/mp/xxx'（公众号不让添加主页链接，xxx表示profile_ext)
#url='https://mp.weixin.qq.com/mp/profile_ext?action=getmsg&__biz=MzIyMjg2ODExMA==&f=json&offset=21&count=10&is_ok=1&scene=124&uin=NjQ3OTQwMTAy&key=a90c16d3bbfeedd04adeeda7bfc81049f486e81712f95a347e33fccfb9fe00841ec6a4d0984ce32f72fe5e8c479fd13c6680b5496cda322ab1bb2b81417a10ae277a861ad580e77cdf78edbf86212c08&pass_ticket=2vonvdf3N4L67te2BCa4ZqvIs1ed2MoeBqoznvfNSL%2BeKqF4YgHUvNEWLNczZovz&wxtoken=&appmsg_token=1015_jLHC7BDStvidMqo9YO55XLerjoP9z6UM70Q5vw~~&x5=0&f=json'
# Mongo配置
conn = MongoClient('127.0.0.1', 27017)
db = conn.wx  #连接wx数据库，没有则自动创建
mongo_wx = db.article  #使用article集合，没有则自动创建

def get_wx_article(biz, uin, key, index=0, count=10):
    offset = (index + 1) * count
    params = {
        '__biz': biz,
        'uin': uin,
        'key': key,
        'offset': offset,
        'count': count,
        'action': 'getmsg',
        'f': 'json'
    }

    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'
    }

    response = requests.get(url=url, params=params, headers=headers)
    resp_json = response.json()
    if resp_json.get('errmsg') == 'ok':
        resp_json = response.json()
        # 是否还有分页数据， 用于判断return的值
        can_msg_continue = resp_json['can_msg_continue']
        # 当前分页文章数
        msg_count = resp_json['msg_count']
        general_msg_list = json.loads(resp_json['general_msg_list'])
        list = general_msg_list.get('list')
        print(list, "**************")
        for i in list:
            app_msg_ext_info = i['app_msg_ext_info']
            # 标题
            title = app_msg_ext_info['title']
            # 文章地址
            content_url = app_msg_ext_info['content_url']
            # 封面图
            cover = app_msg_ext_info['cover']

            # 发布时间
            datetime = i['comm_msg_info']['datetime']
            datetime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(datetime))

            mongo_wx.insert({
                'title': title,
                'content_url': content_url,
                'cover': cover,
                'datetime': datetime
            })
        if can_msg_continue == 1:
            return True
        return False
    else:
        print('获取文章异常...')
        return False


if __name__ == '__main__':
    biz = 'Mzg4MTA2Nzg0NA=='
    uin = 'NDIyMTI5NDM1'
    key = '20a680e825f03f1e7f38f326772e54e7dc0fd02ffba17e92730ba3f0a0329c5ed310b0bd55b3c0b1f122e5896c6261df2eaea4036ab5a5d32dbdbcb0a638f5f3605cf1821decf486bb6eb4d92d36c620'
    index = 0
    while 1:
        print(f'开始抓取公众号第{index + 1} 页文章.')
        flag = get_wx_article(biz, uin, key, index=index)
        # 防止和谐，暂停8秒
        time.sleep(8)
        index += 1
        if not flag:
            print('公众号文章已全部抓取完毕，退出程序.')
            break

        print(f'..........准备抓取公众号第{index + 1} 页文章.')

```
[Redis 结合 flask 及 vue 实现 SSE 在线聊天](https://learnku.com/articles/30542)

[Python社区文章](http://www.python88.com/user/6732)

[python版-批量中文文件名转英文](http://martinhan.site/2017-04-15/python%E7%89%88-%E6%89%B9%E9%87%8F%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E8%BD%AC%E8%8B%B1%E6%96%87.html)

[模拟登录一些知名的网站，为了方便爬取需要登录的网站fuck login](https://github.com/xchaoinfo/fuck-login)

[pandas](https://finthon.com/data-processing/pandas/)

[Python 快速打包发布软件PyPi上](https://yangfangs.github.io/2018/08/06/python-distribution-packages/)

[Python进阶](https://finthon.com/python-advance/)

[Python 进程管理工具 Supervisor 使用教程](https://www.restran.net/2015/10/04/supervisord-tutorial/)

[Python 入门教程 - 课程大纲](https://www.restran.net/2017/02/25/python-tutorial-outline/)

[网易云音乐歌曲评论爬虫]()

[爬取豆瓣短评之《后来的我们》](http://python.jobbole.com/89161/)

[python奇技淫巧](https://www.techug.com/post/python-tips-and-trick.html)

[爆破的方式收集子域名https://5alt.me/tools/](https://github.com/5alt/ZeroScan)

[python模拟登陆一些大型网站，还有一些简单的爬虫](https://github.com/CriseLYJ/awesome-python-login-model)


[python教程](http://www.liujiangblog.com/course/python/1)