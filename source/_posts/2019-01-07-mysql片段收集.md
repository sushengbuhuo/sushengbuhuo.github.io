---
title: mysql片段收集
date: 2019-01-07 15:13:54
tags:
- mysql
---
### Mysql使用别名多表查询join时问题
```javascript
SELECT * FROM t1, t2 LEFT JOIN t3 ON (t1.id=t3.id) WHERE t1.id=t2.id
但是在执行的时候报错“Unknown column t1.id”,以前博主习惯利用AS 表别名来进行多表关联查询，这让博主很凌乱，一时不知道如何下手解决了
实际上执行 SELECT * FROM t1,( t2 LEFT JOIN t3 ON (t1.id=t3.id)) WHERE t1.id=t2.id

SELECT * FROM t1 INNER JOIN t2 LEFT JOIN t3 ON (t1.id=t3.id) WHERE t1.id=t2.id
```
### 重置root密码
```javascript
kill `cat /mysql-data-directory/host_name.pid`
#ps方法
ps aux|grep 'mysql'
#这里把%pid%替换为上面ps给的进程id
sudo kill %pid%
#5.7.6和以后版本
ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass';
#5.7.6以前版本
SET PASSWORD FOR 'root'@'localhost' = PASSWORD('MyNewPass');
#官网手册命令，mac用户不推荐
 
mysqld_safe --init-file=/home/me/mysql-init &
 
#mac用户推荐命令
 
sudo /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid --init-file=/Users/king/sql/alter_root.sql &
1. 停止mysql服务:
systemctl stop mysqld

2. 设置mysql的环境变量参数 
systemctl set-environment MYSQLD_OPTS="--skip-grant-tables"

3. 启动mysql服务
systemctl start mysqld

4. root无密码登录
mysql -u root

5. 更新root密码
mysql> UPDATE mysql.user SET authentication_string = PASSWORD('MyNewPassword')
    -> WHERE User = 'root' AND Host = 'localhost';
mysql> FLUSH PRIVILEGES;
mysql> quit

6. 关闭mysql服务
systemctl stop mysqld

7. 删除mysql环境参数
systemctl unset-environment MYSQLD_OPTS

8. 再次启动:
systemctl start mysqld

9. 用root登录:
. mysql -u root -p
```
### mysql5.7无法远程连接问题
```javascript
mysql -uroot -p
 
use mysql;
 
select * from user\G;
sudo iptables -L #查看防火墙规则列表
 
sudo iptables -F  #清空防火墙列表
vi /etc/mysql/mysql.conf.d/mysqld.cnf
#bind-address = 127.0.0.1
bind-address = 0.0.0.0
```
### select *导致的mysql线程sending data
```javascript
当有大量的”select * from xxx”存在时，虽然这个表的数据量不是很大，只有区区几千条记录记录，但是大量的查询引起mysql线程状态卡在”sending data”时，服务器的负载就上来了。

那么什么是”sending data”状态哪?其实这是一个很容易引起误导的状态说明，”sending data”是包含读取数据+发送数据的。这里以innodb存储引擎来说，我们在使用索引找到我们所需的记录时，期初得到是索引列信息和主键信息，如果我们查询的信息索引列中已经包含，那么万事大吉，mysql会把这些信息发送给客户端。但是如果像我的例子中的是使用”select *”这种情况，或者要索引列中未包含我们需要需要的更多信息，那么这时mysql就会拿着主键id去数据行获取信息，然后再把些信息发送给客户端。

现在回到上面的问题，我们数据表记录数不多，为什么会引起”sending data”哪?我们活动信息表有几个字段是MEDIUMTEXT或者VARCHAR(3000)类似这种要存储比较长字符串内容的字段，所以在使用”select *”时我们把本来不需要，但是却占用很大空间的字段也返回了，造成了大量无用的IO操作，这里包含读取数据和发送数据。由于接口我们使用的是被动缓存，所以活动刚开始时这些请求都打到了数据库，后面接口缓存生效以后数据库压力就降下来了。

开发框架使用的是Lumen,而且我们主要使用的是里面的ORM-Elopment,有些地方没有注意查询时设定字段就引起了这个问题，说句实话以前在使用ORM时，我一直没有养成限制返回字段的习惯。希望看到这篇文章的同学也能引以为戒，以后尽量不要使用”seleect *”这样粗暴的查询方式。
```
### lumen数据库时区设置
```javascript
http://www.helpergarden.com/2018/05/lumen%e6%95%b0%e6%8d%ae%e5%ba%93%e6%97%b6%e5%8c%ba%e8%ae%be%e7%bd%ae.html
timestamp里面居然保存的居然是带时区的
查看ORM源码，它的注释里面说日期类型的字符创会转化成“DateTime/Carbon”实例，然后再进一步处理是输出或者存入数据库。

我们可以通过在.env中设置”DB_TIMEZONE”来解决时区不一致的问题。

DB_TIMEZONE=+8:00
一般来说要保证我们设置DB_TIMEZONE和APP_TIMEZONE一致的，所以一般配置文件都是这样的。

APP_TIMEZONE=Asia/Shanghai
DB_TIMEZONE=+8:00
```
### nginx跨域设置
```javascript
location / {
       index  index.html index.htm index.php;
       autoindex on;
       try_files $uri $uri/ /index.php?$query_string;
}

include cors.conf;
vi cors.conf 
add_header Access-Control-Allow-Origin *;
add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';

if ($request_method = 'OPTIONS') {
    return 204;
}
```
### swoole process父子进程使用队列通信
```javascript
<?php
//http://www.helpergarden.com/2018/05/swoole-process%e7%88%b6%e5%ad%90%e8%bf%9b%e7%a8%8b%e4%bd%bf%e7%94%a8%e9%98%9f%e5%88%97%e9%80%9a%e4%bf%a1.html
$worker_num = 2;
$process_pool = [];

$process= null;
$pid = posix_getpid();

function sub_process(swoole_process $worker)
{
    sleep(1); //防止父进程还未往消息队列中加入内容直接退出
    echo "worker ".$worker->pid." started".PHP_EOL;
    while($msg = $worker->pop()){
        if ($msg === false) {
            break;
        }
        $sub_pid = $worker->pid;
        echo "[$sub_pid] msg : $msg".PHP_EOL;
        sleep(1);//这里的sleep模拟必须，否则可能1个worker就把所有信息全接受了
    }
    echo "worker ".$worker->pid." exit".PHP_EOL;
    $worker->exit(0);
}

$customMsgKey = 1;//默认为空，这个地方可以随便填的
$mod = 2 | swoole_process::IPC_NOWAIT;//这里设置队列为非阻塞模式

//创建worker进程
for($i=0;$i<$worker_num; $i++) {
    $process=new swoole_process('sub_process');
    $process->useQueue($customMsgKey, $mod);
    $process->start();
    $pid = $process->pid;
    $process_pool[$pid] = $process;
}

$messages = [
    "Hello World!",
    "Hello Cat!",
    "Hello King",
    "Hello Leon",
    "Hello Rose"
];
//由于所有进程是共享使用1个消息队列，所以只需向一个字进程发送消息即可
$process = current($process_pool);
foreach ($messages as $msg) {
    $process->push($msg);
}

swoole_process::wait();
swoole_process::wait();

echo "master exit".PHP_EOL;
```
### yum安装elasticsearch
```javascript
//http://www.helpergarden.com/2018/03/yum%e5%ae%89%e8%a3%85elasticsearch.html
yum install java
yum makecache
yum install elasticsearch
cd /usr/share/elasticsearch
./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip
  systemctl start elasticsearch
curl http://127.0.0.1:9200
访问“http://127.0.0.1:9200/_cat/plugins”可以查看es安装的插件。

curl http://127.0.0.1:9200/_cat/plugins
```
### grant
```javascript
mysql>grant select,delete,update,create,drop on *.* to test@"%" identified by "1234";

     //test用户对所有数据库都有select,delete,update,create,drop 权限。https://laravel-china.org/articles/22147
　 @"%" 表示对所有非本地主机授权，不包括localhost。

　对localhost授权：加上一句grant all privileges on testDB.* to test@localhost identified by '1234';即可
```
###  EXPLAIN 查看SQL执行计划
```javascript
EXPLAIN SELECT ……
EXPLAIN EXTENDED SELECT ……
将执行计划"反编译"成SELECT语句，运行SHOW WARNINGS，可得到被MySQL优化器优化后的查询语句。
EXPLAIN PARTITIONS SELECT ……
用于分区表的EXPLAIN生成QEP的信息
```
### 卸载mysql8
```javascript
[root@VM_0_14_centos ~]# rpm -qa|grep mysql

mysql80-community-release-el7-1.noarch
mysql-community-client-8.0.13-1.el7.x86_64
mysql-community-libs-8.0.13-1.el7.x86_64
mysql-community-libs-compat-8.0.13-1.el7.x86_64
php70w-mysqlnd-7.0.32-1.w7.x86_64
mysql-community-common-8.0.13-1.el7.x86_64
mysql-community-server-8.0.13-1.el7.x86_64

yum remove mysql80-community-release-el7-1.noarch
[root@VM_0_14_centos ~]# find / -name mysql
/etc/selinux/targeted/tmp/modules/100/mysql
/etc/selinux/targeted/active/modules/100/mysql
/var/lib/mysql
/var/lib/mysql/mysql
/var/lib/docker/volumes/68a07333528e60edd5980282ae6b0a3ce2324021eb8ca2f1963adb5a199ade7a/_data/mysql
/var/lib/docker/volumes/f17d91c72d0178c3746414175662884b29c462146c18fcf775c139a875dbd746/_data/mysql
/var/lib/docker/volumes/f8f07e5586d9f47cb5ec67a6b1fcd174c60446091e75ad0a920d58afefc8c405/_data/mysql
/var/lib/docker/overlay2/68559b409701bd076a41a3a062d786093709ba872db563d90ce969222990e3ff/merged/etc/init.d/mysql
/var/lib/docker/overlay2/68559b409701bd076a41a3a062d786093709ba872db563d90ce969222990e3ff/merged/etc/mysql
/var/lib/docker/overlay2/68559b409701bd076a41a3a062d786093709ba872db563d90ce969222990e3ff/merged/var/lib/mysql
/var/lib/docker/overlay2/68559b409701bd076a41a3a062d786093709ba872db563d90ce969222990e3ff/merged/var/log/mysql
/var/lib/docker/overlay2/68559b409701bd076a41a3a062d786093709ba872db563d90ce969222990e3ff/merged/usr/bin/mysql
/var/lib/docker/overlay2/68559b409701bd076a41a3a062d786093709ba872db563d90ce969222990e3ff/merged/usr/lib/mysql
/var/lib/docker/overlay2/68559b409701bd076a41a3a062d786093709ba872db563d90ce969222990e3ff/merged/usr/share/mysql

rm -rf /var/lib/mysql
rm -rf /etc/my.cnf
rm -rf /var/log/mysqld.log

```
### 安装mysql5.7
```javascript
wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm
yum localinstall mysql57-community-release-el7-8.noarch.rpm
yum repolist enabled | grep "mysql.*-community.*"
mysql> system yum repolist enabled | grep "mysql.*-community.*"
Repository epel is listed more than once in the configuration
mysql-connectors-community/x86_64 MySQL Connectors Community                  74
mysql-tools-community/x86_64      MySQL Tools Community                       74
mysql57-community/x86_64          MySQL 5.7 Community Server                 307
 [root@VM_0_14_centos ~]# yum install mysql-community-server
 grep 'temporary password' /var/log/mysqld.log
 Loaded plugins: fastestmirror, langpacks
 Repository epel is listed more than once in the configuration
 Determining fastest mirrors
  * nux-dextop: li.nux.ro
  * webtatic: us-east.repo.webtatic.com
 Package mysql-community-server-5.7.24-1.el7.x86_64 already installed and latest version
 Nothing to do
     [root@VM_0_14_centos ~]# grep 'temporary password' /var/log/mysqld.log
     [root@VM_0_14_centos ~]#
     [root@VM_0_14_centos ~]# service mysqld restart
     Redirecting to /bin/systemctl restart  mysqld.service
     
     [root@VM_0_14_centos ~]# /bin/systemctl restart  mysqld.service
     [root@VM_0_14_centos ~]# ps aux|grep mysql
     systemd+   765  0.0  0.2 1121296 4316 ?        Ssl   2018  38:00 mysqld
     mysql    11499  0.3  8.8 1119512 166152 ?      Sl   17:47   0:00 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid
     root     11769  0.0  0.0 112708   964 pts/3    R+   17:49   0:00 grep --color=auto mysql
     [root@VM_0_14_centos ~]# which mysqld
     /usr/sbin/mysqld
     [root@VM_0_14_centos ~]# lsof -i:3306
     COMMAND   PID  USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
     mysqld  11499 mysql   18u  IPv6 60264974      0t0  TCP *:mysql (LISTEN)
     [root@VM_0_14_centos ~]# grep 'password' /var/log/mysqld.log
     2019-01-14T09:46:16.712229Z 1 [Note] A temporary password is generated for root@localhost: RpvpdgHKZ5;*
     2019-01-14T09:47:39.920810Z 0 [Note] Shutting down plugin 'validate_password'
     2019-01-14T09:47:41.646659Z 0 [Note] Shutting down plugin 'sha256_password'
     2019-01-14T09:47:41.646662Z 0 [Note] Shutting down plugin 'mysql_native_password'
     [root@VM_0_14_centos ~]# mysql -uroot -p
     Enter password:
     Welcome to the MySQL monitor.  Commands end with ; or \g.
     Your MySQL connection id is 2
     Server version: 5.7.24
mysql> use mysql
ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.
mysql>  ALTER USER 'root'@'localhost' IDENTIFIED BY '*SUsheng*';
ERROR 1819 (HY000): Your password does not satisfy the current policy requirements
mysql>  ALTER USER 'root'@'localhost' IDENTIFIED BY '*SUsheng123*';
Query OK, 0 rows affected (0.00 sec)
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'YourPassword9#' WITH GRANT OPTION;
修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置
vim /etc/my.cnf
[mysqld]
character_set_server=utf8
init_connect='SET NAMES utf8'
λ mysql -h 118.24.158.116 -uroot -p
Enter password: ***********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.7.24 MySQL Community Server (GPL)

mysql5.7 以后的争强了安全机制,所以使用yum安装,启动会系统会自动生成一个随机的密码，并且不能设置简单密码。所以需要修改 mysql 全局参数

先用日志密码登录 mysql 

grep 'temporary password' /var/log/mysqld.log

会输出结果: A temporary password is generated for root@localhost: ******

使用此密码登录后 执行 SHOW VARIABLES LIKE 'validate_password%‘;  查看 mysql 密码策略

+--------------------------------------+--------+
| Variable_name                        | Value  |
+--------------------------------------+--------+
| validate_password_check_user_name    | OFF    | 
| validate_password_dictionary_file    |        |
| validate_password_length             | 8      |
| validate_password_mixed_case_count   | 1      |
| validate_password_number_count       | 1      |
| validate_password_policy             | MEDIUM | 
| validate_password_special_char_count | 1      |
+--------------------------------------+--------+

执行 set global validate_password_policy=LOW;  修改密码策略

执行 set global validate_password_length=6; 修改验证密码长度

切换 user 库

update user set authentication_string = password('root'), password_expired = 'N', password_last_changed = now() where user = 'root';

重启 mysqld 服务，再用新密码登录即可

如果无法登录,提示Access denied for user 'root'@'localhost'

重新更新 root 用户的 plugin 字段

update user set plugin='mysql_native_password' where user = 'root';

更新成功后.重新执行更新密码操作

刷新权限  flush privileges;
```
### 查看实时执行的SQL语句
```javascript
mysql> SHOW VARIABLES LIKE "general_log%";
如下general_log值为OFF说明没有开启：

+------------------+----------------------------------+
| Variable_name    | Value                            |
+------------------+----------------------------------+
| general_log      | OFF                              |
| general_log_file | /var/lib/mysql/galley-pc.log |
+------------------+----------------------------------+
2 rows in set (0.00 sec)
mysql> SET GLOBAL general_log = 'ON';
mysql> SET GLOBAL general_log_file = '/var/log/mysql/general_log.log';
永久有效需要配置my.cnf文件，加入下面两行：

general_log = 1
general_log_file = /var/log/mysql/general_sql.log
$ tail -f /var/lib/mysql/general_sql.log
/usr/sbin/mysqld, Version: 5.7.24 (MySQL Community Server (GPL)). started with:
Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock
Time                 Id Command    Argument
2019-01-15T08:45:47.794791Z       137 Query     SHOW VARIABLES LIKE 'general%'

直接使用 /etc/mysql/debian.cnf 文件中 [client] 节提供的用户名和密码
mysql -u*** -p
切换到 mysql 数据库
use mysql;
更新密码
update user set authentication_string = password('root'), password_expired = 'N', password_last_changed = now() where user = 'root';
刷新权限 flush privileges;
重启 mysqld 服务，再用新密码登录即可
如果无法登录,提示 Access denied for user 'root'@'localhost'
重新更新 root 用户的 plugin 字段
update user set plugin='mysql_native_password' where user = 'root';
更新成功后.重新执行更新密码操作
```
### Can't connect to local MySQL server
```javascript
[root@localhost app]# mysql
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)
[root@localhost app]# mysql -uroot -p
Enter password: 
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)
查询自己的 mysql.sock文件

发现自己的路径在 

[root@localhost data]# find / -name mysql.sock
/tmp/mysql.sock
则在 my.cnf 中添加指定 mysql.sock文件

[root@localhost data]# vim /etc/my.cnf
[mysqld]
socket=/tmp/mysql.sock


fack!! 重启mysql服务问题依旧存在

于是添加软连接

[root@localhost data]# mkdir -pv /var/lib/mysql
mkdir: 已创建目录 “/var/lib/mysql”
[root@localhost data]# ln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock
[root@localhost data]# mysql
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.6.16 Source distribution
Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
mysql>
```
### Access denied for user 'root'@'localhost'
```javascript
# /etc/init.d/mysqld stop //停止mysql服务的运行
# mysqld_safe --user=mysql --skip-grant-tables --skip-networking & //跳过受权表访问
# mysql -u root mysql //登录mysql



在mysql5.7以下的版本如下：
mysql> UPDATE user SET Password=PASSWORD('newpassword') where USER='root' and host='127.0.0.1' or host='localhost';//把空的用户密码都修改成非空的密码就行了。

在mysql5.7版本如下：

update mysql.user set authentication_string=password('newpassword') where user='root' and host='127.0.0.1' or host='localhost';


mysql> FLUSH PRIVILEGES;
mysql> quit # /etc/init.d/mysqld restart //离开并重启mysql
# mysql -uroot -p
Enter password: <输入新设的密码newpassword> 
Connection:             Localhost via UNIX socket
Server characterset:    latin1
Db     characterset:    latin1
Client characterset:    utf8
Conn.  characterset:    utf8
UNIX socket:            /var/lib/mysql/mysql.sock

[root@localhost ~]# ps aux|grep mysqld
root     10913  0.0  0.0 106228  1396 ?        S    Jan19   0:00 /bin/sh /usr/bin/mysqld_safe --datadir=/data1/mysql --socket=/tmp/mysql.sock --pid-file=/var/run/mysqld/mysqld.pid --basedir=/usr --user=mysql
mysql    11147 57.8  3.4 3502672 416152 ?      Sl   Jan19 1706:42 /usr/sbin/mysqld --basedir=/usr --datadir=/data1/mysql --plugin-dir=/usr/lib64/mysql/plugin --user=mysql --log-error=/var/log/mysqld.log --pid-file=/var/run/mysqld/mysqld.pid --socket=/tmp/mysql.sock
```
### Can't connect to MySQL server on '127.0.0.1' 
```javascript
[root@localhost ~]# mysql -uroot -p -h 127.0.0.1
Enter password:
ERROR 2003 (HY000): Can't connect to MySQL server on '127.0.0.1' (111)
[root@localhost ~]# grep bind /etc/my.cnf
bind-address=172.16.7.27
[root@localhost ~]# mysql -uroot -p -h 172.16.7.27
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3979750
Server version: 5.7.11 MySQL Community Server (GPL)
Connection:             172.16.7.27 via TCP/IP#和通过socket链接不同

```
### 转换编码
```javascript
#!/bin/bash
DIR=$1 # 转换编码文件目录https://tonydeng.github.io/2015/11/27/batch-conversion-file-encoding/
FT=$2  # 需要转换的文件类型（扩展名）
SE=$3  # 原始编码
DE=$4  # 目标编码
for file in `find $DIR -type f -name "*.$FT"`; do
	echo "conversion $file encoding $SE to $DE"
    iconv -f $SE -t $DE "$file" > "$file".tmp
    mv -f "$file".tmp "$file"
done
//./batch_conversion_encoding.sh ~/sdk1 java GBK UTF8

```
### 安装 MySQL8.0.13
```javascript
wget -c 'https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.13-1.el7.x86_64.rpm-bundle.tar'
解压
tar xvf mysql-8.0.13-1.el7.x86_64.rpm-bundle.tar
安装
yum install mysql-community-libs-8.0.13-1.el7.x86_64.rpm
yum install mysql-community-libs-compat-8.0.13-1.el7.x86_64.rpm
yum install mysql-community-client-8.0.13-1.el7.x86_64.rpm
yum install mysql-community-server-8.0.13-1.el7.x86_64.rpm
设置数据库https://laravel-china.org/articles/22686
初次安装没进去，在/etc/my.cnf 中添加 skip-grant-tables, 使用mysql -uroot 直接进入数据库，
修改root账号密码：
alter user 'root'@'localhost' identified by '**';
mysql 8.0以后默认加密方式跟5.7不一样 ：
ALTER USER 'root'@'localhost' IDENTIFIED BY '**' PASSWORD EXPIRE NEVER; //修改用户永不过期
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '***';//更新一下用户的密码加密方式，修改密码
flush privileges; //执行完刷新权限

创建新用户
CREATE USER smile@% IDENTIFIED BY 'passowrd'; //# 创建账号密码
GRANT ALL ON . TO smile@% WITH GRANT OPTION; //授予远程登录权限（.远程访问所有数据）
REVOKE all privileges ON databasename.tablename FROM 'username'@'host'; //删除某些数据权限
flush privileges;//刷新权限
//不常用的 --- 创建过期用户
CREATE USER smile@% IDENTIFIED BY '***' PASSWORD EXPIRE INTERVAL 90 DAY;
//数据库搞定
service mysqld start restart stop


```
### 查询指定数据库的所有表名称
```javascript
USE information_schema;

SELECT TABLE_NAME,table_rows FROM TABLES WHERE TABLE_SCHEMA = '数据库名字' ORDER BY table_rows DESC;
查询指定库的数据大小，索引大小
SELECT CONCAT(ROUND(SUM(DATA_LENGTH/1024/1024),2),'MB') AS total_data_size, CONCAT(ROUND(SUM(index_length)/(1024*1024), 2), ' MB') AS total_index_size FROM TABLES  WHERE table_schema  =  '数据库名字';
```
### MySQL 分区表
```javascript
//https://learnku.com/articles/22947
如果需要定时清理一张普通大表里的历史数据。

可以使用一个或多个带 where 条件的 delete 语句去删除（where条件是时间）。 如果表数据量较大，这对数据库的造成了很大压力。即使我们把这些旧数据删除了，但是底层的数据文件并没有变小。

为什么没有变小？
当删除数据 时，MYSQL 并不会立即回收表空间。被已删除数据的占据的存储空间，以及索引位会空在那里，等待新的数据来弥补这个空缺。
强行回收： OPTIMIZE TABLE
mysql> SHOW PLUGINS \G;

*************************** 43. row ***************************
   Name: partition
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
CREATE TABLE hash_partition_test (
    id INT,
    pdate INT
)
PARTITION BY HASH(id)
PARTITIONS 4;
CREATE TABLE range_partition_test (
    id INT,
    pdate INT
)
PARTITION BY RANGE (pdate) (
    PARTITION p1 VALUES LESS THAN ( 201702 ),
    PARTITION p2 VALUES LESS THAN ( 201703 ),
    PARTITION p3 VALUES LESS THAN ( 201704 ),
    PARTITION p4 VALUES LESS THAN (MAXVALUE)
);
mysql> select * from range_partition_test;
+------+--------+
| id   | pdate  |
+------+--------+
|    1 | 201701 |
|    2 | 201702 |
|    3 | 201703 |
|    4 | 201704 |
|    5 | 201705 |
+------+--------+

mysql> explain partitions select * from range_partition_test where pdate between 201702 and 201703;
+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table                | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | range_partition_test | p2,p3      | ALL  | NULL          | NULL | NULL    | NULL |    2 |    50.00 | Using where |
+----+-------------+----------------------+------------+------+---------------+------+---------+------+------+----------+-------------+


```
### limit优化
```javascript
MySQL的 limit m,n 工作原理就是先读取符合where条件的前面m+n条记录，然后抛弃前m条，返回后面n条，所以m越大，偏移量越大，性能就越差。这也是大部分ORM框架生成的分页sql

SELECT * FROM
 t_tel_record t1
INNER JOIN (
 SELECT f_id
 FROM t_tel_record
 WHERE f_qiye_id = xxx
 ORDER BY f_id DESC
 LIMIT 999900, 100
) t2 ON t1.f_id = t2.f_id

min_id = SELECT f_id
FROM t_tel_record
WHERE f_qiye_id = xxx
ORDER BY f_id DESC
LIMIT 999900, 1
 
 
SELECT * FROM
  t_tel_record t1
WHERE f_qiye_id = xxx
AND f_id < {min_id} + 1
ORDER BY f_id DESC
LIMIT 100
第一页：（降序）
SELECT * FROM t_tel_record t1
WHERE f_qiye_id = xxx
ORDER BY f_id DESC LIMIT 100
 
 
获取结果集最大最小id：一般是第一条和最后一条，或者 max_id=max(f_id), min_id=min(f_id)
下一页（如果有）：
SELECT * FROM t_tel_record t1
WHERE f_qiye_id = xxx
AND f_id < {min_id}  -- min_id变量
ORDER BY f_id DESC LIMIT 100
 
 
上一页（如果有）：
SELECT * FROM t_tel_record t1
WHERE f_qiye_id = xxx
AND f_id > {max_id}  -- max_id变量
ORDER BY f_id DESC LIMIT 100
最后一页：（降序）
SELECT * FROM (
  SELECT * FROM t_tel_record t1
  WHERE f_qiye_id = xxx
  ORDER BY f_id ASC LIMIT 100) AS t
ORDER BY f_id DESC
 
 
倒数第二页：(以此类推)
SELECT * FROM (
  SELECT * FROM t_tel_record t1
  WHERE f_qiye_id = xxx
  ORDER BY f_id ASC LIMIT 100, 100) AS t
ORDER BY f_id DESC


```
### insert
```javascript

-- 将 oldUsers 表中的数据插入到 users 表
INSERT INTO `users`(`email`, `name`, `password`) SELECT `email`, `name`, `password` FROM `oldUsers`;

-- 将 users 表的数据复制到 usersCopy 表
SELECT * INTO `usersCopy` FROM `users`;

-- 创建新表 usersCopy 并将 users 复制过去
CREATE TABLE `usersCopy` AS SELECT * FROM `users`;
-- 查询 products 表中 price 与 number 的乘积并设为别名 total
SELECT `price` * `number` AS `total` FROM `products`;
-- 查询 users 表中的 name 列并将其用括号括起而且设置列别名为 newName
SELECT Concat('(', `name`, ')') AS `newName` FROM `users`;
```
### bindParam 和 bindValue
```javascript

bindParam 的作用是将变量的引用绑定到预编译的 SQL 语句中，当绑定的变量值改变时 SQL 语句随之改变。

$statement = $pdo->prepare("INSERT INTO `posts` (`id`, `title`, `author`) VALUES (:id, :title, :author)");
$id = 11;
$title = 'new post';
$author = 'unknown';
$statement->bindParam(':id', $id, PDO::PARAM_INT);
$statement->bindParam(':title', $title, PDO::PARAM_STR);
$statement->bindParam(':author', $author, PDO::PARAM_STR);
$statement->execute();
$id = 12;
$title = 'new post2';
$author = 'unknown2';
$statement->execute();
// 执行代码后查询数据库显示如下
// +----+-----------+----------+
// | id | title     | author   |
// +----+-----------+----------+
// |  1 | new post  | unknown  |
// |  2 | new post2 | unknown2 |
// +----+-----------+----------+
警告：由于 bindParam 是绑定的是变量的引用，所以在 foreach 中会出现意料之外的 BUG。示例如下：

$data = [':title' => 'title', ':author' => 'author'];
$statement = $pdo->prepare("INSERT INTO `posts` (`title`, `author`) VALUES (:title, :author)");
foreach ($data as $key => $val) {
    $statement->bindParam($key, $val);
}
$statement->execute();
// 执行代码后查询数据库显示如下
// +----+--------+--------+
// | id | title  | author |
// +----+--------+--------+
// |  1 | author | author |
// +----+--------+--------+
当循环结束后 $val 的值即为数组中最后一个元素的值，而 bindParam 方法绑定的是引用而不是值，所以此时所有的占位符绑定的都是循环结束后的 $val 变量值，因此就有了这个结果。 解决这个问题我们可以用 bindValue 方法实现。

bindValue 的作用是绑定值到预编译的 SQL 语句中，一经绑定 SQL 语句就固定不变。示例如下：

$data = [':title' => 'title', ':author' => 'author'];
$statement = $pdo->prepare("INSERT INTO `posts` (`title`, `author`) VALUES (:title, :author)");
foreach ($data as $key => $val) {
    $statement->bindValue($key, $val);
}
$statement->execute();
// 执行代码后查询数据库显示如下
// +----+--------+--------+
// | id | title  | author |
// +----+--------+--------+
// |  1 | title  | author |
// +----+--------+--------+
这样就解决了这个问题，当然我们还可以在 foreach 中使用引用的方式解决这个问题，但是不推荐。示例如下：

$data = [':title' => 'title', ':author' => 'author'];
$statement = $pdo->prepare("INSERT INTO `posts` (`title`, `author`) VALUES (:title, :author)");
foreach ($data as $key => &$val) {
    $statement->bindParam($key, $val);
}
$statement->execute();
// 执行代码后查询数据库显示如下
// +----+--------+--------+
// | id | title  | author |
// +----+--------+--------+
// |  1 | title  | author |
// +----+--------+--------+

```
### 行列转换
```javascript
#准备示例数据
create table tbl_name (ID int ,mSize varchar(100));
insert into tbl_name values (1,'tiny,small,big');
insert into tbl_name values (2,'small,medium');
insert into tbl_name values (3,'tiny,big');

#用于行列转换循环的自增表
create table incre_table (AutoIncreID int);
insert into incre_table values (1);
insert into incre_table values (2);
insert into incre_table values (3);
 

#实现行列转换的SQLhttp://cenalulu.github.io/mysql/column-row-reverse/
select a.ID,substring_index(substring_index(a.mSize,',',b.AutoIncreID),',',-1) 
from 
tbl_name a
join
incre_table b
on b.AutoIncreID <= (length(a.mSize) - length(replace(a.mSize,',',''))+1)
order by a.ID;
select a.ID,substring_index(substring_index(a.mSize,',',b.help_topic_id+1),',',-1) 
from 
tbl_name a
join
mysql.help_topic b
on b.help_topic_id < (length(a.mSize) - length(replace(a.mSize,',',''))+1)
order by a.ID;
```
### MySQL密码
```javascript
mysql> select password('root'),concat('*',sha1(unhex(sha1('root'))));
+-------------------------------------------+-------------------------------------------+
| password('root')                          | concat('*',sha1(unhex(sha1('root'))))     |
+-------------------------------------------+-------------------------------------------+
| *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | *81f5e21e35407d884a6cd4a731aebfb6af209e1b |
+-------------------------------------------+-------------------------------------------+
5.6以前如果你向MySQL发送了例如create user,grant user ... identified by这样的携带初始明文密码的指令，那么会在binary log中原原本本的被还原出来。
mysql [localhost] {msandbox} (mysql) > create user plain_password identified by 'plain_pass';
Query OK, 0 rows affected (0.00 sec)
用mysqlbinlog查看二进制日志 http://cenalulu.github.io/mysql/myall-about-mysql-password/

shell> mysqlbinlog binlog.000001
# at 106
#150227 23:37:59 server id 1  end_log_pos 223   Query   thread_id=1 exec_time=0 error_code=0
use mysql/*!*/;
SET TIMESTAMP=1425051479/*!*/;
SET @@session.pseudo_thread_id=1/*!*/;

change master to master_password=''命令不在这个范畴中。这也就意味着MySQL5.6中仍然使用这样的语法来启动replication时有安全风险的。这也就是为什么5.6中使用带有明文密码的change master to时会有warning提示，具体如下：

slave1 [localhost] {msandbox} ((none)) > change master to master_host='127.0.0.1',master_port =21288,master_user='rsandbox',master_password='rsandbox',master_auto_position=1;
Query OK, 0 rows affected, 2 warnings (0.04 sec)

slave1 [localhost] {msandbox} ((none)) > show warnings;
+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                                                                                                                                                                                                              |
+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Note  | 1759 | Sending passwords in plain text without SSL/TLS is extremely insecure.                                                                                                                                                                                                               |
| Note  | 1760 | Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information. |
+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)
```
### 导出表数据
```javascript
select * from table into outfile "/home/root/example.sql" where +条件
导入数据库

$ mysqldump -uroot -p --default-character-set=utf8 dbname tablename >  /home/root/example.sql
转载数据

load data local infile "/home/table.txt" into table `table`;

```
### 从数据库中获取随机的数据
```javascript
User::inRandomOrder()->get();
User::inRandomOrder()->first();
User::orderByRaw("RAND()")->get();
use Illuminate\Database\Query\Builder;
//https://learnku.com/laravel/wikis/16199
Builder::macro('orderByRandom', function () {

    $randomFunctions = [
        'mysql'  => 'RAND()',
        'pgsql'  => 'RANDOM()',
        'sqlite' => 'RANDOM()',
        'sqlsrv' => 'NEWID()',
    ];

    $driver = $this->getConnection()->getDriverName();

    return $this->orderByRaw($randomFunctions[$driver]);
});
SELECT 
FROM table AS t1 JOIN (SELECT ROUND(RAND() ((SELECT MAX(id) FROM table)-(SELECT MIN(id) FROM table))+(SELECT MIN(id) FROM table)) AS id) AS t2
WHERE t1.id >= t2.id
ORDER BY t1.id LIMIT 1;
以前用过的，效率不错。
```
### mysql5.7 datetime 默认值为‘0000-00-00 00:00:00'值无法创建问题解决
```javascript
1、使用root登陆数据库 命令界面执行

select @@sql_mode;
 结果中包含下面两个

NO_ZERO_IN_DATE,NO_ZERO_DATE
2、修改/etc/my.cnf，查找sql_model如果找不到则添加如下代码 

sql_mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"
3、重启mysql

/etc/ini.d/mysql restart
简单几步大功告成！

 http://118.25.60.91:9080/article/15 https://learnku.com/articles/16807

原因：

NO_ZERO_IN_DATE,NO_ZERO_DATE是无法默认为‘0000-00-00 00:00:00’的根源。

NO_ZERO_IN_DATE：在严格模式下，不允许日期和月份为零 

NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。
```
### Redis 分布式锁
```javascript
/**
 *
 * redis 加锁 --单Redis实例实现分布式锁
 *
 * -- 分布式请使用：Redlock:https://github.com/ronnylt/redlock-php
 * -- 详情参考： http://www.redis.cn/topics/distlock.html
 *
 * @package app\common\service
 */
class RedisLock
{
    const LOCK_SUCCESS = 'OK';
    const IF_NOT_EXISTS = 'NX';
    const MILLISECOND_EXPIRE_TIME = 'PX';
    const EXPIRE_TIME = 60000; // millisecond => 60s
    const LOCK_VALUE = 1;

        /**
         * 加锁https://learnku.com/articles/15825/redis-distributed-lock-solution
         * @param $redis object
         * @param $key
         * @param string $expire_time 60000
         */
        public static function lock($redis, $key, $expire_time='')
        {
            if (empty($expire_time)) {
                    $expire_time = self::EXPIRE_TIME;
            }

            $result = $redis->set($key, self::LOCK_VALUE, [self::IF_NOT_EXISTS, self::MILLISECOND_EXPIRE_TIME => $expire_time]);

            return self::LOCK_SUCCESS === (string)$result;
        }

        /**
         * 解锁https://github.com/laravel/framework/blob/5.6/src/Illuminate/Cache/RedisLock.php#L36 
         *
         * 参考： https://github.com/phpredis/phpredis/blob/develop/tests/RedisTest.php
         * @param $redis
         * @param $key
         */
        public static function unlock($redis, $key)
        {
            $lua =<<<EOT
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
EOT;
            $result = $redis->eval($lua, array($key, self::LOCK_VALUE), 1);
            return $result;
    }
}
public function acquire()
    {
        $result = $this->redis->setnx($this->name, 1);
        if ($result === 1 && $this->seconds > 0) {
            $this->redis->expire($this->name, $this->seconds);
        }
        return $result === 1;
    }
    /**
     * Release the lock.
     *
     * @return void
     */
    public function release()
    {
        $this->redis->del($this->name);
    }
```
### redis-cli
```javascript
//https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5bcfd27051882577e962f064
$ redis-cli incrby foo 5
(integer) 5
$ redis-cli incrby foo 5
(integer) 10
$ redis-cli info > info.txt
$ wc -l info.txt
     120 info.txt
// -n 2 表示使用第2个库，相当于 select 2
$ redis-cli -h localhost -p 6379 -n 2 ping
PONG
$ cat cmds.txt
set foo1 bar1
set foo2 bar2
set foo3 bar3
......
$ cat cmds.txt | redis-cli
OK
OK
OK
$ redis-cli < cmds.txt
OK
OK
OK
// 间隔1s，执行5次，观察qps的变化
$ redis-cli -r 5 -i 1 info | grep ops
instantaneous_ops_per_sec:43469
instantaneous_ops_per_sec:47460
如果将次数设置为 -1 那就是重复无数次永远执行下去。如果不提供 -i 参数，那就没有间隔，连续重复执行。在交互模式下也可以重复执行指令，形式上比较怪异，在指令前面增加次数

127.0.0.1:6379> 5 ping
PONG
PONG
PONG
PONG
PONG
# 下面的指令很可怕，你的屏幕要愤怒了
127.0.0.1:6379> 10000 info
$ redis-cli rpush lfoo a b c d e f g
(integer) 7
$ redis-cli --csv lrange lfoo 0 -1
"a","b","c","d","e","f","g"
$ redis-cli hmset hfoo a 1 b 2 c 3 d 4
OK
$ redis-cli --csv hgetall hfoo
"a","1","b","2","c","3","d","4"
$ redis-cli --csv -r 5 hgetall hfoo
"a","1","b","2","c","3","d","4"
"a","1","b","2","c","3","d","4"
"a","1","b","2","c","3","d","4"
"a","1","b","2","c","3","d","4"
"a","1","b","2","c","3","d","4"
127.0.0.1:6379> eval "return redis.pcall('mset', KEYS[1], ARGV[1], KEYS[2], ARGV[2])" 2 foo1 foo2 bar1 bar2
OK
127.0.0.1:6379> eval "return redis.pcall('mget', KEYS[1], KEYS[2])" 2 foo1 foo2
1) "bar1"
2) "bar2"
redis-cli --stat 参数来实时监控服务器的状态，间隔 1s 实时输出一次。
$ ./redis-cli --bigkeys -i 0.01
--bigkeys 参数可以很快扫出内存里的大 KEY，使用 -i 参数控制扫描间隔，避免扫描指令导致服务器的 ops 陡增报警。
$ redis-cli --host 192.168.x.x --port 6379 monitor
1539853410.458483 [0 10.100.90.62:34365] "GET" "6yax3eb6etq8:{-7}"
1539853410.459212 [0 10.100.90.61:56659] "PFADD" "growth:dau:20181018" "2klxkimass8w"
如果你想观察主从服务器之间都同步了那些数据，可以使用 redis-cli 模拟从库。

$ ./redis-cli --host 192.168.x.x --port 6379 --slave
SYNC with master, discarding 51778306 bytes of bulk transfer...
$ ./redis-cli --host 192.168.x.x --port 6379 --rdb ./user.rdb
SYNC sent to master, writing 2501265095 bytes to './user.rdb' 远程 rdb 备份

只有query执行时间大于slowlog-log-slower-than的才会定义成慢查询，才会被slowlog进行记录。slowlog-log-slower-than设置的单位是微秒，默认是10000微秒，也就是10毫秒。slowlog-max-len表示慢查询最大的条数，当slowlog超过设定的最大值后，会将最早的slowlog删除，是个FIFO队列。

查看slowlog总条数

127.0.0.1:6379> SLOWLOG LEN

(integer) 4
127.0.0.1:6379> CONFIG GET slowlog-*
1) "slowlog-log-slower-than"
2) "100"
3) "slowlog-max-len"
4) "1024"
127.0.0.1:6379> SLOWLOG GET 11) 1) (integer) 26            // slowlog唯一编号id2) (integer) 1440057815    // 查询的时间戳3) (integer) 47            // 查询的耗时（微秒），如表示本条命令查询耗时47微秒4) 1) "SLOWLOG"            // 查询命令，完整命令为 SLOWLOG GET，slowlog最多保存前面的31个key和128字符2) "GET"

 debug sleep阻塞了set命令，set命令的整体响应时间(R)是1530357微秒，而其服务时间(S)为8微秒，排队延迟(Q)为1530349微秒。
 
 Session-1:
 xxxx:6386> debug sleep 6
 OK
 (6.00s)
 
 Session-2:
 xxxxx:6386> set a b
 OK
 (1.53s)
 127.0.0.1:6379> SLOWLOG RESET
 OK
 127.0.0.1:6379> SLOWLOG LEN
 (integer) 0
 redis-cli monitor打印出所有sever接收到的命令以及其对应的客户端地址
 
 $ redis-cli monitor
 redis-cli --stat查看当前连接的客户端数，连接数等
 按前缀/模式批量删除keys
 redis-cli keys david* | xargs redis-cli del
 127.0.0.1:6379> eval "local keys = redis.call('keys',KEYS[1]) for i,v in ipairs(keys) do redis.call('del',v) end" 1 david*
```
### 每个分组的最后一条记录
```javascript
select * from t_tmp group by FCityId order by FUpdateTime desc;` 结果却是错误的！http://blog.text.wiki/2015/04/03/retrieve-the-last-record-in-each-group.html
SELECT * FROM (SELECT * FROM t_tmp ORDER BY FUpdateTime DESC)tmptable GROUP BY FCityId ORDER BY FUpdateTime DESC;

SELECT m1. * FROM t_tmp m1 LEFT JOIN t_tmp m2 ON ( m1.FCityId = m2.FCity
Id AND m1.FId < m2.FId )  WHERE m2.FId IS NULL ORDER BY FUpdateTime DESC LIMIT 0
, 30;
```
### 超过经理收入的员工
```javascript
 SELECT e.Name AS Employee
    FROM Employee e, Employee e1
    WHERE e.ManagerId = e1.id
        AND e.Salary > e1.Salary;
Department	Employee	Salary
IT	Max	90000
Sales	Henry	80000
https://learnku.com/articles/24492
```
### MySQL 之事务隔离级别
```javascript
MySQL事务主要用于处理一个包含操作量比较大、复杂的业务。比如说，删除一个学生，我们除了要删除该学生的基本信息，同时也要删除考试记录、违规记录等。诸多的操作组成一个事务。事务是用来管理insert、update、delete基本指令的。当MySQL使用innodb引擎的前提下才支持事务操作
https://learnku.com/articles/24581#topnav https://www.itcodemonkey.com/article/13020.html
隔离性的类别

read uncommitted | 读未提交
read committed | 读已提交
repeatable read | 可重复读
serializable | 串行化
在MySQL数据库中，引擎默认使用repeatable read

# SELECT @@tx_isolation 或者 SELECT @@transaction_isolation
# MySQL 8.x 
# transaction_isolation在MySQL 5.7.20中添加了作为别名 tx_isolation，现已弃用，并在MySQL 8.0中删除。
# 应调整应用程序transaction_isolation以优先使用 tx_isolation。
mysql> SELECT @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
1 row in set (0.01 sec)

## 将事务隔离的模式设置为[可重复读]
mysql> set session transaction isolation level repeatable read;
Query OK, 0 rows affected (0.00 sec)

## (1)事务A读取scor数据表
mysql> select * from score;
+----+----------+-------+
| id | name     | score |
+----+----------+-------+
|  1 | alicfeng |    75 |
|  2 | feng     |   100 |
|  3 | alic     |    90 |
+----+----------+-------+
3 rows in set (0.00 sec)

## (2)事务B新增删除一条数据并提交
mysql> delete from score where id=1;
Query OK, 1 row affected (0.01 sec)

mysql> commit;
Query OK, 0 rows affected (0.01 sec)

## (3)事务A再次读取score数据表
mysql> select * from score;
+----+----------+-------+
| id | name     | score |
+----+----------+-------+
|  1 | alicfeng |    75 |
|  2 | feng     |   100 |
|  3 | alic     |    90 |
+----+----------+-------+
3 rows in set (0.00 sec)
```
### MySQL性能突发事件问题排查技巧
```javascript
https://mp.weixin.qq.com/s/qCRfxIr1RoHd9i8-Hk8iuQ
top — Linux 系统进程监控
iostat
 vmstat — 虚拟内存统计
[xxx@localhost ~]$ vmstat
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0 945448 437836 618928 5950612    1    0    13   685    0    0 16  2 82  0  0
 lsof — 打开文件列表
 [finance@localhost ~]$ lsof -c php-fpm
 COMMAND   PID    USER   FD      TYPE     DEVICE SIZE/OFF       NODE NAME
 php-fpm  3893    root  cwd   unknown                                /proc/3893/cwd (readlink: Permission denied)
 php-fpm  3893    root  rtd   unknown                                /proc/3893/root (readlink: Permission denied)
 php-fpm  3893    root  txt   unknown                                /proc/3893/exe (readlink: Permission denied)
 php-fpm  3893    root NOFD                                          /proc/3893/fd (opendir: Permission denied)
 php-fpm  3894 root  cwd       DIR        8,2     4096      90113 /root
 php-fpm  3894 root  rtd       DIR        8,2     4096          2 /
 php-fpm  3894 root  txt       REG        8,7 37943970     264189 /data/php55/sbin/php-fpm
tcpdump — 网络数据包分析器
netstat — 网络统计 监控网络数据包传入和传出的统计界面的命令行工具
[XXX@localhost ~]$ netstat -a |more
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address               Foreign Address             State
tcp        0      0 127:6379 *:*                         LISTEN
tcp        0      0 localhost:6379              *:*                         LISTEN
tcp        0      0 localhost:9004              *:*                         LISTEN

SHOW PROCESSLIST; —当前MySQL数据库的运行的所有线程
INNODB_TRX; — 当前运行的所有事务
mysql> select *from information_schema.INNODB_TRX\G
INNODB_LOCKS; — 当前出现的锁
select *from information_schema.INNODB_LOCKS\G
INNODB_LOCK_WAITS; — 锁等待的对应关系计
mysql> select *from information_schema.INNODB_LOCK_WAITS\G
SHOW OPEN TABLES where In_use >0; — 当前打开表
SHOW ENGINE INNODB STATUS  \G; —Innodb状态
SHOW STATUS LIKE  'innodb_row_lock_%'; — 锁性能状态
SQL语句EXPLAIN; — 查询优化器
```
### Mysql 批量写入数据
```javascript
https://my.oschina.net/famoustone/blog/856736
public function insertTest(){

		set_time_limit(0);   //防止超300s 500错误
	
		$t1 = microtime(true);
	
	
		//随机插入num条
		for ($i=1; $i<=200000; $i++){
			
			$result = $this->db->insert('myisam', ['value' => uniqid().$i]);
		}

		//程序运行时间
		$t2 = microtime(true);
		echo '耗时：'.round($t2-$t1,3).'秒<br>';
		echo '内存消耗：'.round(memory_get_usage()/1048576,2)." M<br/>";
	
	}
	    167秒，时间20w 数据 Myisam要 接近3分钟了。
    
my.cnf 当innodb_flush_log_at_trx_commit=2时, 每次事务提交时, MySQL会把log buffer的数据写入log file, 但          不会主动触发flush(刷新到disk)操作同时进行. 然而, MySQL会每秒执行一次flush(刷新到disk)操作.
public function insertTest(){

		set_time_limit(0);   //防止超300s 500错误
	
		$t1 = microtime(true);
	
	
		$sql = "insert into innodb (value) VALUES";
		//随机插入num条
		for ($i=1; $i<=200000; $i++){
			
			$val = uniqid().$i;
				
			$sql .= "('{$val}'),";
			
		}
		
		$sql = substr($sql,0,-1);
		
		//程序运行时间
		$t2 = microtime(true);
		echo '循环耗时：'.round($t2-$t1,3).'秒<br>';
		
		$this->db->query($sql);  //批量插入
		
		$t3 = microtime(true);
		echo '插入耗时：'.round($t3-$t2,3).'秒<br>';
		
		echo '内存消耗：'.round(memory_get_usage()/1048576,2)." M<br/>";
	
	}拼接语句可能会报错
     设置一下
     
     max_allowed_packet = 500M
     
     允许mysql 接受数据包大小。
```
### Redis延时队列
```javascript
https://rsy.me/posts/redis-application-in-web-development/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io
$queueKey = "queue";

// 生产者
$redis->rpush($queueKey, $data)

// 消费者
while (true) {
    $data = $redis->lpop($queueKey);
    if (null === $data) {
        usleep(100000);
        continue;
    }
    // 业务逻辑
    ...
}

$queueKey = "queue";

// 生产消息

// 消费时间, 这里设置为1小时候
$consumeTimestamp = time() + 3600;
// $data需要添加随机串前缀(or后缀)，防止出现重复member被丢弃
$data = $data . md5(uniqid(rand(), true));
$redis->zadd($queueKey, $consumeTimestamp, $data);

// 消费消息
while (tue) {
    $arrData = $redis->zrangebyscore($queueKey, 0, time());
    if (!$arrData) {
        usleep(100000);
        continue;
    }
    // 业务逻辑
    foreach ($arrData as $data) {
        $data = substr($data, 0, strlen($data) - 32);
        
        // 消费$data

    }
}
```
### redis 分布式锁
```javascript
$lockStatus = $redis->setnx($lockKey, 1);
if (1 === $lockStatus) {
    // 加锁成功，为锁设置超时时间
    $redis->expire($lockKey, 300);

    // 进行后续操作

} elseif (0 === $lockStatus) {
    // 加锁失败
} else {
    // 其他异常
}
$lockStatus = $this->redis->set($lockKey, 1, "EX", 30, "NX");
if ("OK" === $lockStatus) {
    // 加锁成功，可进行后续操作
    
    //业务逻辑执行完毕，释放锁
    $this->redis->del($lockKey);

} elseif (null === $lockStatus) {
    // 加锁失败
}
$lockToken = md5(uniqid(rand(), true));
// 此处超时时间根据具体业务逻辑配置
$expire = rand(280, 320);
$lockStatus = $this->redis->set($lockKey, $lockToken, "EX", $expire, "NX");
if ("OK" === $lockStatus) {
    // 加锁成功，可进行后续操作
    
    // 业务逻辑执行完毕，释放锁
    // 删除锁之前需要判断是否是自己上的锁
    $currentToken = $this->redis->get($lockKey);
    if ($currentToken === $lockToken) {
        $this->redis->del($lockKey);
    }

} elseif (null === $lockStatus) {
    // 加锁失败
}
```
### redis 无法启动
```javascript
redis突然挂掉后，无法启动，查看log日志，发现报Short read or OOM loading DB. Unrecoverable error, aborting now
[root@localhost ~]# rm -f /var/lib/redis/dump.rdb  
[root@localhost ~]# rm -f /var/run/redis.pid  
[root@localhost ~]# service redis start  
```
### redis 导出 导入
```javascript
[root@localhost tank]# yum install ruby rubygems ruby-devel   //安装rubygems 以及相关包  
  
[root@localhost tank]# gem sources -a http://ruby.taobao.org/   //源，加入淘宝，外面的源不能访问  
http://ruby.taobao.org/ added to sources  
  
[root@localhost tank]# gem install redis-dump -V   //安装redis-dump 
查看复制打印?
[root@localhost tank]# telnet 127.0.0.1 6379 //telnet到redis  
Trying 127.0.0.1...  
Connected to 127.0.0.1.  
Escape character is '^]'.  
set test 11 //设置一个值  
+OK  
get test //取值  
$2  
11  
  
[root@localhost tank]# redis-dump -u 127.0.0.1:6379 >test.json //导出数据  
[root@localhost tank]# telnet 127.0.0.1 6379 //telnet到redis  
Trying 127.0.0.1...  
Connected to 127.0.0.1.  
Escape character is '^]'.  
flushall //请空所有数据  
+OK  
keys * //查看已清空  http://blog.51yip.com/nosql/1656.html
*0  
  
[root@localhost tank]# < test.json redis-load //导入数据  
  
[root@localhost tank]# telnet 127.0.0.1 6379  
Trying 127.0.0.1...  
Connected to 127.0.0.1.  
Escape character is '^]'.  
keys * //已导入成功  
*1  
$4  
test  
```
### 优化not in 和<>查询
```javascript
http://fanqieto.top/2017/11/26/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/
select customer_id,first_name,last_name,email
from customer
where customer_id
not in (select customer_id from payment)
改为：

select a.customer_id,a.first_name,a.last_name,a.email 
from customer a
left join payment b on a.customer_id = b.customer_id
where b.customer_id is null m
使用汇总表优化查询
例子

select count(*) from product_comment where product_id = 999
改为

create table product_comment_cnt(product_id int, cnt int);
select sum(cnt) from (
select cnt from product_comment_cnt where product_id = 999
union all
select count(*) from product_comment where product_id = 999
and timestr > date(now())
) a
```
### Redis的n种妙用
```javascript
setnx key value，当key不存在时，将 key 的值设为 value ，返回1。若给定的 key 已经存在，则setnx不做任何动作，返回0。



当setnx返回1时，表示获取锁，做完操作以后del key，表示释放锁，如果setnx返回0表示获取锁失败
# 实现方式一
# 一直往list左边放
lpush key value 
# key这个list有元素时，直接弹出，没有元素被阻塞，直到等待超时或发现可弹出元素为止，上面例子超时时间为10s
brpop key value 10 

# 实现方式二
rpush key value
blpop key value 10
# 参加抽奖活动
sadd key {userId} 

# 获取所有抽奖用户，大轮盘转起来
smembers key 

# 抽取count名中奖者，并从抽奖活动中移除
spop key count 

# 抽取count名中奖者，不从抽奖活动中移除
srandmember key count
# 1001用户给8001帖子点赞
sadd like::8001 1001

# 取消点赞
srem like::8001 1001

# 检查用户是否点过赞
sismember like::8001 1001 

# 获取点赞的用户列表
smembers like::8001 

# 获取点赞用户数
scard like::8001 
# 返回sevenSub和qingSub的交集，即seven和青山的共同关注
sinter sevenSub qingSub -> {mic,james}

# 我关注的人也关注他,下面例子中我是seven
# qing在micSub中返回1，否则返回0
sismember micSub qing
sismember jamesSub qing

# 我可能认识的人,下面例子中我是seven
# 求qingSub和sevenSub的差集，并存在sevenMayKnow集合中
sdiffstore sevenMayKnow qingSub sevenSub -> {seven,jack}
# 将拯救者y700P-001和ThinkPad-T480这两个元素放到集合brand::lenovo
sadd brand::lenovo 拯救者y700P-001 ThinkPad-T480
sadd screenSize::15.6 拯救者y700P-001 机械革命Z2AIR
sadd processor::i7 拯救者y700P-001 机械革命X8TIPlus

# 获取品牌为联想，屏幕尺寸为15.6，并且处理器为i7的电脑品牌(sinter为获取集合的交集)
sinter brand::lenovo screenSize::15.6 processor::i7 -> 拯救者y700P-001
# user1的用户分数为 10
zadd ranking 10 user1
zadd ranking 20 user2

# 取分数最高的3个用户
zrevrange ranking 0 2 withscores
Redis 的持久化机制有两种，第一种是快照（RDB RDB是隔一段时间来备份数据），第二种是 AOF 日志。快照是一次全量备份，AOF 日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而 AOF 日志记录的是内存数据修改的指令记录文本。AOF 日志在长期的运行过程中会变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。
假如客户端每秒发送5000个请求，其中4000个为黑客的恶意攻击，即在数据库中也查不到。举个例子，用户id为正数，黑客构造的用户id为负数，

如果黑客每秒一直发送这4000个请求，缓存就不起作用，数据库也很快被打死。
如何解决缓存穿透



查询不到的数据也放到缓存，value为空，如set -999 “”



总而言之，缓存雪崩就是缓存失效，请求全部全部打到数据库，数据库瞬间被打死。缓存穿透就是查询了一个一定不存在的数据，并且从存储层查不到的数据没有写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义
https://www.itcodemonkey.com/article/12951.html


```
### 防止库存超卖
```javascript
https://www.fanhaobai.com/2017/09/record-question-1.html

$num = $redis->incr($key);
if ($num < $max) {
    //入抢购成功队列，异步去执行抢购成功逻辑
} else {
    //不好意思呢，已经被抢完了
}
不知道你有没有闻到这段代码的坏味道，在大部分情况下会如你所想地运行，但是特殊场景下会 出现判断失效 的逻辑问题，例如：

1、key 由于某些原因失效了；
2、Incr 操作失败了，不会抛异常并返回 false；
通过日志定位到 Incr 操作问题，便 Telnet 连接到线上 Redis 服务，发现了异常情况：

# 查看值
GET key
100
# 尝试修改
INCR key
READONLY You can't write against a read only slave

INFO
# Replication
role:slave
可以看出来，该连接的机器目前处于从机状态，不可写操作，所以 Incr 操作返回 false，同时 PHP 不同类型比较会存在隐式转化，所以false < $num恒成立，导致计数器失效。

增加计数器容错处理：

$num = $redis->incr($key);
if ($num > 0 && $num < $max) {
    //入抢购成功队列，异步去执行抢购成功逻辑
} else {
    //不好意思呢，已经被抢完了
}
然后，切换 Redis 源到高可用集群（Codis），测试并重新上线，第二日的抢购已经正常，看着 Cat 上流量逐渐平稳，心里也踏实了。
```
### Redis管道提升性能
```javascript
Redis 的 管道 （pipelining）是用来打包多条无关命令批量执行，以减少多个命令分别执行带来的网络交互时间。在一些批量操作数据的场景，使用管道可以显著提升 Redis 的读写性能

https://www.fanhaobai.com/2017/08/redis-pipelining.html
# 安装nc命令
$ yum install nc
# nc打包多个命令
$ (printf "PING\r\nPING\r\nPING\r\n") | nc localhost 6379
# 响应
+PONG
+PONG
+PONG
$start = nowTime();
foreach (range(1, 1000) as $id) {
    $user[] = $redis->hgetAll($keyPrex.$id);
}
echo '时间：', nowTime() - $start, 'ms', PHP_EOL;

时间：39ms
$start = nowTime();
$redis->multi(Redis::PIPELINE);
foreach (range(1, 1000) as $id) {
    //返回资源id相同的socket资源，并未执行命令
    $redis->hgetAll($keyPrex.$id);  
}
$user = $redis->exec();
echo '时间：', nowTime() - $start, 'ms', PHP_EOL;

时间：6ms
在批量操作（查询和写入）数据时，我们应尽量避免多次跟 Redis 的网络交互。这时，可以使用管道实现，也可以 Redis 内嵌 Lua 脚本实现。需要注意的是：

管道只适用于无因果关联的多命令操作，否则就需要借助 Lua 脚本实现批量操作；
在实际应用中，Redis 往往不可能是单机部署，如果想要在集群中使用管道，可以部署为一主多从架构，此时所有节点的数据都一致，随机选取节点使用管道即可；
总结

在批量获取数据时，尽管使用 Redis 的管道性能会显著提升，但是使用管道时 Redis 会缓存之前命令的结果，最后一并输出给终端，因此所打包的命令不宜太多，否则内存使用会很严重。
```
### 处理重复数据
```javascript
CREATE TABLE `allowed_user`
(
  `id` INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  `uid` VARCHAR(36)  DEFAULT ''  NOT NULL,
  `last_time` TIMESTAMP  NOT NULL,
  UNIQUE (uid)
)

INSERT INTO `allowed_user` (`uid`, `last_time`) VALUES ('8e9b8c14-fae8-49d4-bbac-a733c09ec82f', '2017-09-03 19:31:15')
REPLACE INTO `allowed_user` (`uid`, `last_time`) VALUES ('8e9b8c14-fae8-49d4-bbac-a733c09ec82f', '2017-09-01 19:31:15')
注意执行影响行数为 2
INSERT INTO `allowed_user` (`uid`, `last_time`) VALUES ('8e9b8c14-fae8-49d4-bbac-a733c09ec82f', '2017-09-01 19:31:15') ON DUPLICATE  KEY UPDATE `last_time` = '2017-09-01 19:40:15'
SQL 执行影响记录数为 2 条
INSERT IGNORE INTO `allowed_user` (`uid`, `last_time`) VALUES ('8e9b8c14-fae8-49d4-bbac-a733c09ec82f', '2017-09-01 19:41:15')
try {
    $user = $model->query("SELECT * FROM `allowed_user` WHERE `uid` = '8e9b8c14-fae8-49d4-bbac-a733c09ec82f'");
    if (user) {
       $model->exec("UPDATE `allowed_user` SET `last_time` = '2017-09-01 19:50:15' WHERE `uid` = '8e9b8c14-fae8-49d4-bbac-a733c09ec82f'");
    } else {
       $model->exec("INSERT INTO `allowed_user` (`uid`, `last_time`) VALUES ('8e9b8c14-fae8-49d4-bbac-a733c09ec82f', '2017-09-01 19:50:15'");
    }
} catch(Exception $e) {

}
这段代码通过程序逻辑去试图保证唯一性，但是在高并发情况下，并不能保证数据唯一性，因为不是原子性操作，修改后为：https://www.fanhaobai.com/2017/09/mysql-repetition-deal.html

try {
    $model->exec("INSERT INTO `allowed_user` (`uid`, `last_time`) VALUES ('8e9b8c14-fae8-49d4-bbac-a733c09ec82f', '2017-09-01 19:50:15') ON DUPLICATE  KEY UPDATE `last_time` = '2017-09-01 19:50:15'");
} catch(Exception $e) {

}
替换掉异常数据的特殊换行符即可。

UPDATE table_a SET uid = REPLACE(REPLACE(uid, CHAR(10), ''), CHAR(13), '');
在 MySQL 中，CHAR(10) 和 CHAR(13) 分别代 换行符 和 回车符，这里都替换掉。
```
### lua 抢购场景
```javascript
$key = 'number:string';
$redis = new Redis();
$number = $redis->get($key);
if ($number <= 0) {
    return 0;
}
$redis->decr($key);
return $number--;
local key = 'number:string'
local number = tonumber(redis.call("GET", key))
if number <= 0 then
   return 0
end
redis.call("DECR", key)
return number--
Redis 中嵌入 Lua 脚本，所具有的几个特性为：

原子操作：Redis 将整个 Lua 脚本作为一个原子执行，无需考虑并发，无需使用事务来保证数据一致性；
高性能：嵌入 Lua 脚本后，可以减少多个命令执行的网络开销，进而间接提高 Redis 性能；
可复用：Lua 脚本会保存于 Redis 中，客户端都可以使用这些脚本；
Redis 中执行 Lua 脚本都是以原子方式执行，所以是原子操作。另外，redis-cli 命令行客户端支持直接使用--eval lua_file参数执行 Lua 脚本。
> EVAL "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 key2 first second
1) "key1"
2) "key2"
3) "first"
4) "second"
> EVAL "return 3.333" 0
(integer) 3
> EVAL "return 'fhb'" 0
"fhb"
> EVAL "return {'fhb', 'lw', 'lbf'}" 0
1) "fhb"
2) "lw"
3) "lbf"
> EVAL "return false" 0
(nil)
> EVAL "return true" 0
(integer) 1
通过 Lua 实现一个针对用户的 API 访问速率控制，Lua 代码如下：

local key = "rate.limit:string:" .. KEYS[1]
local limit = tonumber(ARGV[1])
local expire_time = tonumber(ARGV[2])
local times = redis.call("INCR", key)
if times == 1 then
    redis.call("EXPIRE", key, expire_time)
end
if times > limit then
    return 0
end
return 1
KEYS[1] 可以用 API 的 URI + 用户 uid 组成，ARGV[1] 为单位时间限制访问的次数，ARGV[2] 为限制的单位时间。
> EVAL "return redis.call('SET', 'name', 'fhb')" 0
> EVAL "return redis.pcall('GET', 'name')" 0
"fhb"
https://www.fanhaobai.com/2017/09/lua-in-redis.html
```
### 缓存与数据库双写一致性问题 
```javascript
周所周知，在项目性能优化、提升的时候，我们引进了一个缓存的概念，即一款缓存数据的技术，项目在最初期架构规划时都会引进的一个组件。使用缓存有很多好处：加快请求的响应速度、减少数据库的交互与浪费大量的IO操作等，但是在某些场景下使用缓存也有可能会造成雪崩、剧透、数据不一致等问题，我们研究下使用缓存会导致有哪些数据不一致的情况发生以及在哪些场景会使用哪些具体的解决方案，首先我们必然还是会使用缓存的。

缓存更新策略

先更新数据库再更新缓存

浪费资源
每次去更新数据库再更新缓存都是需要申请CPU进行数据库的修改的，同时倘若数据的修改比较频繁以及数据的读操作却又比较少的时候，这种策略会导致出现冷数据的情况。
数据脏读
如果两个操作同时对数据进行操作时，举个栗子：线程A 在线程B更新数据库成功后、更新缓存成功之前读取到数据，也就是读取到了缓存的旧数据。
该策略比较适合更新的频次比较少的场景下，比如博客的文章、基础数据、个人信息等场景。
先更新数据库再删除缓存

数据脏读
一个请求处理中过程中，倘若数据库更新成功了但是缓存更新失败了，那么后面的请求读取的数据都是旧数据、则脏数据。可以通过缓存过期时间定义缓存的有效期(推荐)，或者使用消息队列在删除缓存失败的时候再次异步更新缓存，直到成功为止，这两种方案都是尽可能减少读取脏数据的方案，还有一种方案可以完全解决数据脏读，就是异步请求串行化，一个字锁，但是会增加业务处理的时间甚至会出现死锁的情况。
这种缓存操作的策略使用的情况被使用的比较多、使用的场景也比较广泛。
先删除缓存再更新数据库
数据脏读
与第二种情况类似，但是更容易出现数据脏读，比如：删除缓存失败更新数据库成功(一般的业务可能在缓存修改失败后不再进行数据库的更新了)、线程B读取了线程A已经成功删除了缓存后更新数据库之前读取了脏数据并且也导致缓存的数据也是旧数据。解决方案还是使用缓存过期时间或者消息队列，在缓存过期的时候务必要注意雪崩的问题，比如大批量数据的过期时间几乎集中在同一个时间点上，容易造成雪崩。

VARCHAR(N) 中的 N 代表的是字符数，而不是字节数。使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存
 优先选择符合存储需要的最小的数据类型
 方法
 1、将字符串转换成数字类型存储，如：将IP地址转换成整形数据。
 
 MySQL 提供了两个方法来处理 IP 地址
 
 inet_aton 把ip转为无符号整型(4-8位)
 inet_ntoa 把整型的ip转为地址
 插入数据前，先用 inet_aton 把 IP 地址转为整型，可以节省空间。显示数据时，使用 inet_ntoa 把整型的 IP 地址转为地址显示即可。
 
 2、对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储,因为无符号相对于有符号可以多出一倍的存储空间。
 SIGNED INT -2147483648~2147483647
 UNSIGNED INT 0~4294967295
 同财务相关的金额类数据必须使用 decimal 类型
 
 非精准浮点：float，double
 精准浮点：decimal
 Decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可用于存储比 bigint 更大的整型数据。
  避免数据类型的隐式转换
 
 隐式转换会导致索引失效。如：
 select name,phone from customer where id = '111';
 https://learnku.com/articles/25020#topnav 
```
### MongoDB读写分离
PHP7中的MongoDB\Driver\ReadPreference MongoDB读写分离（Read Preference）的几种模式

```javascript
const integer RP_PRIMARY = 1 ;
const integer RP_PRIMARY_PREFERRED = 5 ;
const integer RP_SECONDARY = 2 ;
const integer RP_SECONDARY_PREFERRED = 6 ;
const integer RP_NEAREST = 10 ;

primary
主节点，默认模式，读操作只在主节点，如果主节点不可用，报错或者抛出异常。

primaryPreferred
首选主节点，大多情况下读操作在主节点，如果主节点不可用，如故障转移，读操作在从节点。

secondary
从节点，读操作只在从节点， 如果从节点不可用，报错或者抛出异常。

secondaryPreferred
首选从节点，大多情况下读操作在从节点，特殊情况（如单主节点架构）读操作在主节点。

nearest
最邻近节点，读操作在最邻近的成员，可能是主节点或者从节点
在使用mongo副本集的时候就在想，这些副本不用来读太浪费了，再翻阅php的mongodb驱动，发现一个美好的readPreference，可以设定读取的优先级，其中就有优先读取副本，甚至还可以设定读取最小网络延迟的节点，具体可以参考：http://php.net/manual/zh/mongodb-driver-readpreference.construct.php
http://imhuchao.com/918.html
写入安全级别的使用
W选项

0：非确认式写入

1：确认式写入

说明：这个级别下，对副本级只对主库做确认写入

2：副本级确认式写入

说明：这个级别下，副本集第一个slave写入成功后就响应给client

majority：复制级更多slave写入成功后，在响应给client
$filter = array();
$options = array(
    /* Only return the following fields in the matching documents */
    "projection" => array(
        "title" => 1,
        "article" => 1,
    ),
    "sort" => array(
        "views" => -1,
    ),
    "modifiers" => array(
        '$comment'   => "This is a query comment",
        '$maxTimeMS' => 100,
    ),
);

$query = new MongoDB\Driver\Query($filter, $options);

$manager = new MongoDB\Driver\Manager("mongodb://localhost:27017");
$readPreference = new MongoDB\Driver\ReadPreference(MongoDB\Driver\ReadPreference::RP_PRIMARY);
$cursor = $manager->executeQuery("databaseName.collectionName", $query, $readPreference);

foreach($cursor as $document) {
    var_dump($document);
}

vi config/database.php
"mongodb" => [
            'driver' => 'mongodb',
            'host' => env('MONGO_DEFAULT_HOST', '172.1.7.21'),
            'port' => env('MONGO_DEFAULT_PORT', 27017),
            'database' => env('MONGO_DEFAULT_DATABASE', 'app'),
            'username' => env('MONGO_DEFAULT_USER', ''),
            'password' => env('MONGO_DEFAULT_PASSWORD', ''),
            'options' => [
                'replicaSet' => env('MONGO_DEFAULT_REPLICASET'),
                'readPreference'=> env('MONGO_READ_PREFERENCE', 'nearest'),
            ]
        ],
vi  /vendor/jenssegers/mongodb/src/Jenssegers/Mongodb/Connection.php:28
public function __construct(array $config)
    {
        $this->config = $config;

        // Build the connection string
        $dsn = $this->getDsn($config);

        // You can pass options directly to the MongoClient constructor
        $options = array_get($config, 'options', []);

        // Create the connection
        $this->connection = $this->createConnection($dsn, $config, $options);
        dd($this->connection->getReadPreference());
        array:1 [▼
          "type" => "nearest"
        ]
        // Select database
        $this->db = $this->connection->{$config['database']};

        $this->useDefaultPostProcessor();
    }
```
### Laravel 分组获取最新记录
```javascript
///https://learnku.com/articles/20626
select * from (select * from project where user_id = :user_id order by id desc) as a group by a.name order by id desc;
select * from (select * from project where user_id = :user_id order by id desc limit 10000) as a group by a.name order by id desc;
public function projectList(Request $request){
        $limit = $request->get('limit',10);
        $user_id = $request->get('user_id',null);

        $sub_query = Project::where('user_id',$user_id)->orderBy('id','desc')->limit(1000);//子查询

        $results = Project::select('*')
                ->from(DB::raw('('.$sub_query->toSql().') as a')) //from() 类似与 DB::table(), toSql()得到带 ? 号的执行 sql 语句
                ->mergeBindings($sub_query->getQuery())//mergeBindings() 合并绑定参数,getQuery()获得具体值
                ->groupBy('name')
                ->orderBy('id','desc')
                ->paginate($limit);

        return $this->pageDate($results);
    }
```
### 将分组无结果的记录显示为0
```javascript
http://hshine.net/article/12 
SELECT
    ISNULL( SUM ( u_table1917.field5 ), 0 ) As val,
    u_table1916.companycode 
FROM
    u_table1917
    JOIN u_table1916 ON u_table1917.field3= u_table1916.field6 
WHERE
    u_table1916.field3 LIKE '2018%' 
    AND u_table1916.companycode IN ( 'GY00051', 'GY00071', 'GY00072', 'GY00073' ) 
GROUP BY
    u_table1916.companycode
    
    SELECT DISTINCT Ma.companycode,ISNULL(Sub.val,0) FROM --此处使用ISNULL对结果进行判空处理 
    (
    SELECT
        u_table1916.companycode 
    FROM
        u_table1917
        JOIN u_table1916 ON u_table1917.field3= u_table1916.field6
    --此处使用LEFT JOIN 关联，因为左表是包括所有数据记录的，而右表只包括符合条件的，这样就能获得
    --将所有的结果来进行分组，再加上ISNULL的处理，就可以显示聚合为0的记录
    ) AS Ma LEFT JOIN 
    (
    SELECT
        SUM ( u_table1917.field5 ) As val,
        u_table1916.companycode 
    FROM
        u_table1917
        JOIN u_table1916 ON u_table1917.field3= u_table1916.field6 
    WHERE
        u_table1916.field3 LIKE '2018%' 
    GROUP BY
        u_table1916.companycode
    ) AS Sub ON Ma.companycode=Sub.companycode
```
### MISCONF Redis is configured to save RDB snapshots
```javascript
使用redis-cli，你可以这样做：

 
CONFIG SET dir /tmp/some/directory/other/than/var
CONFIG SET dbfilename temp.rdb
千万不要使用https://blog.yiranzai.cn/posts/901/

 
config set stop-writes-on-bgsave-error no
忽视这些错误并不是解决问题的办法。

我的解决方案是

修改配置文件，重启服务
 
$ mkdir /usr/local/redis/db
$ vim redis.conf
# 第263行左右  设置快照文件目录，切勿设置成一个redis用户没有权限的目录
dir /usr/local/redis/db/
$ chown -R redis:redis /usr/local/redis
```
### MySQL数据库主从复制
```javascript
$ systemctl start mysqld.service
$ firewall-cmd --zone=public --add-port=80/tcp --permanent
$ firewall-cmd --reload
master服务器配置：https://blog.yiranzai.cn/posts/5420/
$ vim /etc/my.cnf
[mysqld]
server-id=1
log-bin=mysql-bin # 启用二进制日志

slave服务器配置：
$ vim /etc/my.cnf
[mysqld]
log_bin           = mysql-bin
server_id         = 2
relay_log         = mysql-relay-bin
log_slave_updates = 1
read_only         = 1
slave-skip-errors = all   #忽略因复制出现的所有错误

systemctl restart mysqld.service
mysql> MySQL -u root -p
mysql> GRANT REPLICATION SLAVE ON *.* to 'user'@'192.168.0.124' identified by 'password';
mysql> FLUSH PRIVILEGES;
mysql> FLUSH TABLES WITH READ LOCK;
mysql> show master status;
mysql> UNLOCK TABLES;

mysql> show maser status;
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000004 |    24364 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
1 row in set (0.02 sec)
mysql> change master to
 -> master_host='192.168.0.123',
 -> master_user='user',
 -> master_password='password',
 -> master_log_file='mysql-bin.000004',
 -> master_log_pos=24364;

mysql> start slave;
mysql> show slave status \G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.169.0.123
                  Master_User: user
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000004
          Read_Master_Log_Pos: 24364
               Relay_Log_File: mysql-relay-bin.000292
                Relay_Log_Pos: 283
        Relay_Master_Log_File: mysql-bin.000004
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
...
```
### Redis 快速实现签到统计
```javascript
https://learnku.com/articles/25181
在你想要的位置操作字节值，比如说用户 3 在 3月13号 签到了，那么 setbit(20190313, 3 ,1) 就可以实现签到功能了，这里的 offset 就是3
 $dayKey = 'login:'.\date('Ymd',\time());
$redis->bitop('AND', 'threeAnd', 'login:20190311', 'login:20190312', 'login:20190313');
echo "连续三天都签到的用户数量：" . $redis->bitCount('threeAnd');

$redis->bitop('OR', 'threeOr', 'login:20190311', 'login:20190312', 'login:20190313');
echo "三天中签到用户数量（有一天签也算签了）：" . $redis->bitCount('threeOr');

$redis->bitop('AND', 'monthActivities'', $redis->keys('login:201903*'));
echo "连续一个月签到用户数量：" . $redis->bitCount('monthActivities');

echo "当前用户指定天数是否签到：" . $redis->getbit('login:20190311', $this->user->id);

```
### MySQL分组查询TOP N的实践和踩坑
```javascript
https://blog.yiranzai.cn/posts/991/ 三个字段 课程 学生 成绩，如何取每门课程成绩 top3 的学生
CREATE TABLE `test2` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) DEFAULT NULL,
  `course` varchar(20) DEFAULT NULL,
  `score` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `course` (`course`,`score`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;
ysql> INSERT INTO `test2`(name,course,score) VALUES
('a1', 'a', 50),
('a2', 'a', 50),
('a3', 'a', 50),
('a4', 'a', 40),
('a5', 'a', 40),
('a6', 'a', 40),
('a7', 'a', 30),
('a8', 'a', 30),
('a9', 'a', 30);
mysql> select * from test2;
+----+------+--------+-------+
| id | name | course | score |
+----+------+--------+-------+
|  1 | a1   | a      |    50 |
|  2 | a2   | a      |    50 |
|  3 | a3   | a      |    50 |
|  4 | a4   | a      |    40 |
|  5 | a5   | a      |    40 |
|  6 | a6   | a      |    40 |
|  7 | a7   | a      |    30 |
|  8 | a8   | a      |    30 |
|  9 | a9   | a      |    30 |
+----+------+--------+-------+
9 rows in set (0.06 sec)
select *
from test1 a
where 3>(select count(*) from test1 where course=a.course and score>a.score)
order by a.course,a.score desc;



```
### case when
```javascript
SELECT
    CASE
    WHEN user_sleep_time <= 1536595176
        AND user_sleep_time > 1535212776 THEN
    'twoWeekdsAgo'
    WHEN user_sleep_time <= 1535212776
        AND user_sleep_time > 1532620776 THEN
    'thirtyDaysAgo'
    WHEN user_sleep_time <= 1532620776
        AND user_sleep_time > 1530028776 THEN
    'sixtyDaysAgo'
    WHEN user_sleep_time <= 1530028776
        AND user_sleep_time > 1527436776 THEN
    'ninetyDaysAgo'
    WHEN user_sleep_time <= 1527436776
        AND user_sleep_time > 1524844776 THEN
    'oneHundredAndTwentyDaysAgo'
    WHEN user_sleep_time <= 1524844776
        AND user_sleep_time > 1522252776 THEN
    'oneHundredAndFiftyDaysAgo'
    WHEN user_sleep_time <= 1522252776 THEN
    'oneHundredAndEightyDaysAgo'
    ELSE 0
    END sleep, COUNT(*) AS userCount
FROM `user_sleep_relation`
WHERE `user_recall_time` < 1536595176
GROUP BY  `sleep`  
https://learnku.com/articles/17547
```
### mysql replace into 坑
```javascript

replace into执行的逻辑
1、遇到PRIMARY KEY或UNIQUE索引的，新记录与旧记录有冲突的（这里实际产生了异常duplicate key error），会把旧记录删除，然后再插入新记录
2、若是新记录没有冲突，就直接插入一条新记录，与insert into一样
 
看起来很正常，这里针对第一种逻辑会有问题https://jjhpeopl.iteye.com/blog/2368927  https://blog.xupeng.me/2013/10/11/mysql-replace-into-trap/
1、把旧记录删除之后，插入的新记录只是插入了那些指定的字段，原本不想更新的字段，直接为默认值了，会导致数据丢失
2、若旧记录的id跟其他表是有关联的，更新后新记录会产生新的id，导致这种关联丢失
3、而且使用replace into会导致自增主键id一直增大，很容易导致id值范围不够用
另外，若是数据库存在主从关系，在主机器上进行了replace into操作之后，从机器上对应表的AUTO_INCREMENT是不会更新的，导致从机器转为主机器时，新插入数据会出现异常，直到AUTO_INCREMENT增加到原来主机器的值为止。 
CREATE TABLE `auto` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `k` int(10) unsigned NOT NULL,
  `v` varchar(100) DEFAULT NULL,
  `extra` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_k` (`k`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
INSERT INTO auto (k, v, extra) VALUES (1, '1', 'extra 1'), (2, '2', 'extra 2'), (3, '3', 'extra 3');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

xupeng@diggle7:3600(dba_m) [dba] mysql> SHOW CREATE TABLE auto\G
*************************** 1. row ***************************
       Table: auto
Create Table: CREATE TABLE `auto` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `k` int(10) unsigned NOT NULL,
  `v` varchar(100) DEFAULT NULL,
  `extra` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_k` (`k`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=latin1
1 row in set (0.01 sec)

xupeng@diggle7:3600(dba_m) [dba] mysql> SELECT * FROM auto;
+----+---+------+---------+
| id | k | v    | extra   |
+----+---+------+---------+
|  1 | 1 | 1    | extra 1 |
|  2 | 2 | 2    | extra 2 |
|  3 | 3 | 3    | extra 3 |
+----+---+------+---------+
3 rows in set (0.00 sec)
REPLACE INTO auto (k, v) VALUES (1, '1-1');
SELECT * FROM auto;
+----+---+------+---------+
| id | k | v    | extra   |
+----+---+------+---------+
|  2 | 2 | 2    | extra 2 |
|  3 | 3 | 3    | extra 3 |
|  4 | 1 | 1-1  | NULL    |
+----+---+------+---------+
3 rows in set (0.00 sec)
执行完 REPLACE INTO auto (k, v) VALUES (1, ‘1-1’) 之后，由于新写入记录时并未给 extra 字段指定值，原记录 extra 字段的值就「丢失」了，而通常这并非是业务上所预期的，更常见的需求实际上是，当存在 k=1 的记录时，就把 v 字段的值更新为 ‘1-1’，其他未指定的字段则保持原状，而满足这一需求的 MySQL 方言是 INSERT INTO auto (k, v) VALUES (1, ‘1-1’) ON DUPLICATE KEY UPDATE v=VALUES(v);

鉴于此，很多使用 REPLACE INTO 的场景，实际上需要的是 INSERT INTO … ON DUPLICATE KEY UPDATE，在正确理解 REPLACE INTO 行为和副作用的前提下，谨慎使用 REPLACE INTO。

```
### 类型转换对 MySQL 选择索引的影响
```javascript
mysql [localhost] {msandbox} (test) > explain select age from
    -> indextest where name=111222\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: indextest
         type: ALL
possible_keys: idx_name
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 4
        Extra: Using where
1 row in set (0.00 sec)
https://blog.xupeng.me/2012/02/08/type-conversion-and-index-selection-of-mysql/
mysql [localhost] {msandbox} (test) > SELECT '18015376320243459' =
    -> 18015376320243459;
+-----------------------------------------+
| '18015376320243459' = 18015376320243459 |
+-----------------------------------------+
|                                       0 |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql [localhost] {msandbox} (test) > SELECT '18015376320243459' + 0;
+-------------------------+
| '18015376320243459' + 0 |
+-------------------------+
|    1.80153763202435e+16 |
+-------------------------+
1 row in set (0.00 sec)


mysql [localhost] {msandbox} (test) > SELECT
    -> cast('18015376320243459' as unsigned) =  18015376320243459;
+-----------------------------------------------------------+
| cast('18015376320243459' as unsigned) = 18015376320243459 |
+-----------------------------------------------------------+
|                                                         1 |
+-----------------------------------------------------------+
1 row in set (0.00 sec)
因为浮点数精度(53 bits)问题，并且 MySQL 将字符串转换为浮点数和将整数转换为浮点数使用不同的方法，字符串 '18015376320243459' 和整数 18015376320243459 相比较就不相等，如果要避免隐式浮点数转换带来的精度问题，可以显式地使用 cast 做类型转换，将字符串转换为整数。

按照这些规则，对于上面的例子来说，name 字段的值和查询参数 '111222' 都会被转换为浮点数才会做比较，而很多文本都能转换为和 111222 相等的数值，比如 '111222', '111222aabb', ' 111222' 和 '11122.2e1'，所以 MySQL 不能有效使用索引，就退化为索引扫描甚至是全表扫描。
反过来，如果使用一个字符串作为查询参数，对一个数字字段做比较查询，MySQL 则是可以有效利用索引的
MySQL 可以将查询参数 '30' 转换为确定的数值 30，之后可以快速地在索引中找到与之相等的数值

 explain select * from
    -> indextest where date(create_time)='2012-02-02'\G
explain select * from
    -> indextest where create_time between '2012-02-02' and '2012-02-03'\G

```
### redis keys scan
```javascript
$redis->keys('login:201903*')
$redis->bitop('AND',  'monthActivities'', $redis->keys('login:201903*'));

echo "连续一个月签到用户数量：" . $redis->bitCount('monthActivities');https://learnku.com/articles/25892
当前的 keys 指令执行完了才可以继续，再加上 keys 操作是遍历算法，复杂度是 O(n)，乍一想就知道问题所在了，当实例中数据量过大的时候，Redis 服务可能会卡顿，其余指令可能会延时甚至超时报错..

127.0.0.1:6379> setbit login:20190321 1 1
(integer) 0
127.0.0.1:6379> setbit login:20190321 2 1
(integer) 0
127.0.0.1:6379> setbit login:20190322 2 1
(integer) 0
127.0.0.1:6379> setbit login:20190323 2 1
(integer) 0
127.0.0.1:6379> keys login:201903*
1) "login:20190323"
2) "login:20190322"
3) "login:20190321"
127.0.0.1:6379> scan 0 match login:201903*
1) "3"
2) 1) "login:20190323"
   2) "login:20190322"
127.0.0.1:6379> scan 0 match login:201903* count 2
1) "4"
2) (empty list or set)
127.0.0.1:6379> scan 0 match login:201903* count 20
1) "0"
2) 1) "login:20190323"
   2) "login:20190322"
   3) "login:20190321"

```
### mysql5.7Incorrect datetime value: '0000-00-00 00:00:00' for column
```javascript
`created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', 
`updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
show variables like 'sql_m%';
sql_mode      | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 

alter table test modify created_at datetime NOT NULL;
alter table test modify updated_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;

5.7 timestamp类型取值范围：1970-01-01 00:00:00 到 2037-12-31 23:59:59，初始值调整为 1970-01-02 00:00:00 就可以了 

alter table test modify created_at timestamp NOT NULL DEFAULT '1970-01-02 00:00:00';
alter table test modify updated_at timestamp NOT NULL DEFAULT '1970-01-02 00:00:00';

```
### mysql的limit进行分页时出现重复
```javascript
select * from table order by xx limit 0,10

当xx不存在索引，且有xx相同的行是，可能出现分页数据重复问题


解决办法：
         1.加上索引排序
         select * from table order by xx,id（任意有索引的字段） limit 0,10
         2、给xx字段加上索引
         作为验证，您可以在这个字段上加索引  alter table tea_course_sort add index(course_sort_order)，然后由于这个表数目太小，以防加索引都未必能用得上，语句修改为
       select * from tea_course_sort  force index(course_sort_order) order by tea_course_sort.course_sort_order desc  limit 0,10;
来得到您预期的结果
 
select  * from table_1 where 1=1 limit m,n

这样后面的页可能会出现重复数据，这时可以通过加入order by 子句来解决这种情况， select * from table_1  where 1=1 order by field_1 limit m,n

但是这里需要特别注意，如果field_1字段有相同值的情况下，后面的页还是会出现重复数据，这时可以加入第二个排序字段（值唯一），可以选主键id,

对应的sql语句是select * from table_1  where 1=1 order by field_1 , id limit m,n

但是最好保证field_1在表中的值是唯一的，这样就可以少写一个排序字段，增加查询效率，因为在只有一个排序字段的情况下，mysql会使用索引，如果是有多个排序字段的话，mysql会放弃索引做全表扫描。
```
### 预估 Mysql 数据表的数据大小和索引大小
```javascript
SELECT data_length,index_length
FROM information_schema.TABLES t
WHERE table_schema='your_db_name'
AND table_name = 'your_table_name';
直接查询 avg_row_length 字段，这个字段表示数据表的平均行大小，和上面自己计算的结果类似。
SHOW COLUMNS FROM TABLES;
https://www.playpi.org/2019041001.html 
```
### mysql limit查询优化方法
```javascript
对同一张表在不同的地方取10条数据： 1）offset比较小时  
 
代码示例: select * from user limit 10,10;   这条sql语句多次运行，时间保持在0.0004-0.0005之间。  
 
代码示例: select * from user where uid >=( select uid from user order by uid limit 10,1 ) limit 10;   这条sql语句多次运行，时间保持在0.0005-0.0006之间，主要是0.0006。 结论：偏移offset较小时，直接使用limit较优。这个显然是子查询的原因。
 
2）offset大时  
 
代码示例: select * from user limit 10000,10;   这条sql语句多次运行，时间保持在0.0187左右  
 
代码示例: select * from user where uid >=( select uid from user order by uid limit 10000,1 ) limit 10; 这条sql语句多次运行，时间保持在0.0061左右，只有前者的1/3。可以预计offset越大，后者越优。
 
通过以上对比，得出mysql limit查询语句优化经验： 使用limit语句时，当数据量偏移量较小时可以直接使用limit，当数据量偏移量较大时，可以适当的使用子查询来做相关的性能优化。
--------------------- 
 select * from test a inner join (select id from test where val=4 limit 300000,5) b on a.id=b.id;
```
### FOUND_ROWS()
```javascript
分页程序一般由两条SQL组成：
SELECT COUNT(*) FROM ... WHERE ....
SELECT ... FROM ... WHERE LIMIT ...

如果使用SQL_CALC_FOUND_ROWS的话，一条SQL就可以了：
SELECT SQL_CALC_FOUND_ROWS ... FROM ... WHERE LIMIT ...

 
当我们在处理分页程序的时候，会使用 limit 来限制返回的数量，然后会有两种获取分页的方法：

第一种方法：

在 SELECT 语句中加入 SQL_CALC_FOUND_ROWS 选项，然后通过 SELECT FOUND_ROWS() 来获取总行数：

SELECT SQL_CALC_FOUND_ROWS * FROM table WHERE id > 100 LIMIT 10;
SELECT FOUND_ROWS();
第二种方式：
使用正常的 SQL 语句，然后再用 SELECT COUNT(*) 来获取总行数：

SELECT * FROM table WHERE id > 100 LIMIT 10;
SELECT COUNT(*) FROM table WHERE id > 100;
经过测试，一般来说 SQL_CALC_FOUND_ROWS 是比较慢的，SQL执行的时间甚至会达到10倍那么夸张，所以最好别使用 MySQL 的 SQL_CALC_FOUND_ROWS 来获取总行数
```
###  left join on where
```javascript
使用了 left join，where 是针对左表，但左表是日期表，那如何做业务表上的条件限制
数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户；

where 条件是在临时表生成好后，再对临时表进行过滤的条件；

因此：where 条件加上，已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。

解决方案是把限制条件放在 on 后面

select a.*,b.*
from table1 a
left join table2 b on b.X=a.X and XXX
结论：https://learnku.com/articles/26796 

where 后面：是先连接然生成临时查询结果，然后再筛选

on 后面：先根据条件过滤筛选，再连 生成临时查询结果
```
### 如何索引 JSON 字段
```javascript
CREATE TABLE `players` (  
   `id` INT UNSIGNED NOT NULL,
   `player_and_games` JSON NOT NULL,
   `names_virtual` VARCHAR(20) GENERATED ALWAYS AS (`player_and_games` ->> '$.name') NOT NULL, 
   PRIMARY KEY (`id`)
);
SELECT * FROM `players`;
https://learnku.com/articles/27046#topnav
+----+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+
| id | player_and_games                                                                                                                                                                                           | names_virtual |
+----+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+
|  1 | {"id": 1, "name": "Sally", "games_played": {"Puzzler": {"time": 7}, "Battlefield": {"rank": "Sergeant V", "level": 20, "weapon": "sniper rifle"}, "Crazy Tennis": {"won": 4, "lost": 1}}}                  | Sally         |
|  2 | {"id": 2, "name": "Thom", "games_played": {"Puzzler": {"time": 25}, "Battlefield": {"rank": "Major General VIII", "level": 127, "weapon": "carbine"}, "Crazy Tennis": {"won": 10, "lost": 30}}}            | Thom          |
CREATE INDEX `names_idx` ON `players`(`names_virtual`);  

EXPLAIN SELECT * FROM `players` WHERE `names_virtual` = "Sally"\G  
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: players
   partitions: NULL
         type: ref
possible_keys: names_idx  
          key: names_idx
      key_len: 22
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL


```
###  length 检测 vachar 字节长度
```javascript
insert into test value (1, '测')
SELECT id, LENGTH(str), CHAR_LENGTH(str) FROM test;返回结果是 1 3 1
ALTER TABLE `test`
ADD COLUMN `str2`  varchar(2000) NULL AFTER `str`;
SELECT id, LENGTH(str2), CHAR_LENGTH(str2) FROM test where id = 2;
添加了一个 str2 字段，然后插入 256 个汉字，返回结果是
2 768 256
mysql lenght 是字符串所占的字节，并没有计算额外的所需字节。https://learnku.com/laravel/t/27848
```
### 浅析乐观锁与悲观锁
```javascript
使用悲观锁https://learnku.com/articles/27880
悲观并发控制实际上是 “先取锁，再访问” 的保守策略，为数据处理的安全提供了保证。
begin;
select quantity from products where id = 1 for update;
update products set quanntity = 2 where id = 1;
commit;
以上，对 id 为 1 的产品进行修改，先通过 for update 的方式进行加锁，然后再修改。典型的悲观锁策略。
在对数据修改前，尝试增加排他锁。
加锁失败，意味着数据正在被修改，进行等待或者抛出异常。
加锁成功，对数据进行修改，提交事务，锁释放。
如果我们加锁成功，有其他线程对该数据进操作或者加排他锁的操作，只能等待或者抛出异常。

如果修改库存的逻辑发生并发，同一时间只有一个线程可以开启事务并获得 id = 1 的锁，其他事务必须等本次提交之后才能执行，这样可以保证数据不被其他事务修改。

使用排他锁会把数据锁住，不过需要注意一些基本的锁级别，MySQL InnoDB 默认行级锁。行级锁是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁，会使用表级锁把整张表锁住。
使用乐观锁

select quantity from products where id = 1
update products set quantity = 2 where id = 1 and quantity = 3
先查询库存表当前库存数，然后更新的时候判断数据表对应数据的 quantity 与第一次取出来的是否一致，一致则更新，否则认为是过期数据。

这样实现有一个问题，线程 1 从数据库取出 quantity 为 3，线程 2 也取出同一条数据的 quantity，进行操作，变成了 2，然后又进行某些操作 变成了 3，此时线程 1 进行更新操作成功。但是这个过程有问题。

引入 version 参数，乐观锁每次在执行数据修改的操作，都会带上版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对 version 执行 +1 操作，否则就执行失败。

这样实现也有一个问题，如果真的有高并发的时候，就只有一个线程可以修改成功，就会存在大量的失败。

如果你的应用存在超高并发，这样解决也不好，因为会总让用户感知到失败。

尝试减小乐观锁力度，最大程度提高吞吐。

update products set quantity = quantity - 1 where id = 1 and quanntity - 1 > 0
使用这条 SQL 语句，在执行过程中，会在一次原子操作中查询一遍 quantity 的值，并且减去 1。
laravel 悲观锁对应 lockForUpdate，乐观锁对应 sharedLock https://learnku.com/docs/laravel/5.8/queries/3926
```
![](https://iocaffcdn.phphub.org/uploads/images/201904/24/27516/LoRNLmbvjW.png!large)
![](https://iocaffcdn.phphub.org/uploads/images/201904/24/27516/DnQMqeCmUn.png!large)
### mysql 8.0 使用简单密码
```javascript
直接在 my.cnf 配置文件中 [mysqld] 部分加入下面参数，然后重启 mysqld 即可。

validate_password.policy = 0
validate_password.mixed_case_count = 0
validate_password.number_count = 0
validate_password.special_char_count = 0
validate_password.length = 0
validate_password.policy

可以配置密码的复杂度，可以配置的级别：

0 or LOW
1 or MEDIUM
2 or STRONG
validate_password.length

最终密码的长度，允许为 0 ，但是要注意这里有个坑，validate_password.length 的长度要大于 validate_password.mixed_case_count + validate_password.number_count + validate_password.special_char_count 的和。 例如默认这 3 个 参数的长度都是 1， 所以密码长度最小也只能是 4， 即使配置成了 1 或者 0 ，最终它也会自动变成 4 。 要是想使用 0 的长度，需要将另外三个参数也配置成 0 。
https://broqiang.com/posts/mysql-8-0-uses-a-simple-password
```
### Mysql 批量更新多行
```javascript
update test set test.sex = case name
	when '小白' then 2
	when '小红' then 2
	else 11
	end
where name in ('小白','小红') and test.group = 1
https://www.h57.pw/2016/09/11/mysql-batch-update-multiline-notes/

```
### MySQL中的注释符
 
    # 注释从#字符到行尾
    -- 注释从–序列到行尾，后面需要跟上一个或多个空格，tab也可以
    /* */ 注释中间的字符
    
### 获取元数据
```javascript
 获取当前的数据库用户，数据库名称，数据库的版本信息
select user(),database(),version() from dual;
# 查询数据库，有时需要限制返回的数量，或者偏移，例如页面只显示一条数据的情况 limit 0,1 limit 1,2
# 需要通过偏移来返回所有的数据库
select schema_name from information_schema.schemata;
# group_concat 函数是将多行数据连接成一行
select group_concat(schema_name) from information_schema.schemata;
# 查询表
# 方法1
select group_concat(table_name) from information_schema.tables where table_schema=database();  
# 方法2
select table_name from information_schema.tables where table_schema='database_name';
# 方法3
select table_name from information_schema.tables where table_schema=(select database());

# 查询列
select column_name from information_schema.columns where table_schema='database_name' and table_name='users';
select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='flag';

# 上面可能会被waf识别，也可以这样
select group_concat(column_name) from information_schema.columns where table_name='users';

# 字符串可以转换成16进制
select concat(group_concat(distinct+column_name)) from information_schema.columns where table_name=0x696e666f;
```   
### max key length is 767
```javascript
使用 mysql5.7 没有问题，可以正常 migrate,
使用 mysql5.6 时，就出现这个问题，把字段长度缩小可以解决
由于 MySQL Innodb 引擎表索引字段长度的限制为 767 字节，因此对于多字节字符集的大字段（或者多字段组合索引），创建索引会出现上面的错误。
以 utf8mb4 字符集 字符串类型字段为例：utf8mb4 是 4 字节字符集，则默认支持的索引字段最大长度是： 767 字节 / 4 字节每字符 = 191 字符，因此在 varchar (255) 或 char (255) 类型字段上创建索引会失败。https://learnku.com/laravel/t/28819
处理方案：在 App\Providers\AppServiceProvider 的 boot () 方法中添加 \Illuminate\Support\Facades\Schema::defaultStringLength(191); 即可
```
### SQL 注入
```javascript
select * from user where username='' and pass=''
# 构造 username=devnull' or '1后，sql 语句变成
select * from user where username='devnull' or '1' and pass=''
SELECT * from users t where t.username=a()
// 报错信息，数据库名是 test_db
[Err] 1305 - FUNCTION test_db.a does not exist
# 原始的
http://192.168.137.140/cms/show.php?id=35
# 后面加上 order by 数字，就会按照第几个字段进行排序，如果没有会报错
http://192.168.137.140/cms/show.php?id=35 order by 16
mysql执行：语句正常；
# mssql执行：语句错误，数据类型不匹配，无法正常执行
select id,username from users union select 1,2;     

# oracle执行：语句错误，数据类型不匹配
select id,username from users union select 1,2 from dual;
// 使用括号，select, from , where 这些关键字不能用括号
select(table_name)from(information_schema.tables)where(table_schema)=database()
// 使用内联注释
select/*1*/username/*1*/from/*1*/users
// 使用%0a 绕过
1 or 1 == 0x31206f722031
不区分大小写
select * from table_name where a like 'a%'
select * from table_name where a regexp '^a'

# 区分大小写
select * from table_name where binary a like 'a%'
select * from table_name where binary a regexp '^a'
如果是数字开头的，则会变成前面的字符串 
'123abc' == 123
'abc' == 0
# 可以把username不以数字开头的数据取出来
select * from users WHERE username=0;

#  'abc' + 0 为 0
select 'abc' + 0;
#  'abc' + 123 为 123
select 'abc' + 123;
# 'abc' + '0' 为 0，做加法运算的时候，两边都变成数字 
select 'abc' + '0';
获取所有用户名和密码不为0的数据，利用这种方式可以构造万能密码

 et/2018/10/29/ctf-sqli-notes/
select * from users where username=0 and password=0
select * from users where username='abcd' + '0' and password='abc' + '0'
``` 
### limit 优化
```javascript
在偏移量非常大的时候，例如可能是LIMIT 1000,20这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面1000条记录都被抛弃，这样的代价非常高。如果所有的页面被访问的频率相同，那么这样的查询平均需要访问半个表的数据。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。

优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。考虑下面的查询：

select id,desc from film order by title limit 50000,10;

select id,desc from file inner join (select id from file order by title limit 50000,10) b on film.id=b.id;
”延迟关联“将大大提升查询效率，它让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回元表查询需要的所有列。这个技术也可以用于优化关联查询中的LIMIT子句。

LIMIT和OFFSET的问题，其实是OFFSET的问题，它会导致MySQL扫描达赖给你不需要的行然后再抛弃掉。如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录得位置开始扫描，这样就可以避免使用OFFSET。

select id,desc from film where id>5000 limit 10;
https://shuwoom.com/?p=2659
```
### 取出一组热门作者及他们最近发表的 3 篇文章
```javascript
$users = \App\Models\User::limit(10)->get();

$users = $users->map(function ($user) {
    //可以考虑$user->id缓存,在保证了速度的同时避免大面积的缓存重建
    $user->posts = $user->posts()->limit(3)->get();

    return $user;
});

return $users;
SELECT
    posts.*,
    @number := IF (@current_user_id = `user_id`, @number + 1, 1) AS number,
    @current_user_id := `user_id`
FROM
    (select * from `posts` where `posts`.`user_id` IN (572, 822, 911, 103, 234, 11, 999, 333, 121, 122) order by `posts`.`user_id` ASC) AS posts
HAVING
    number <= 3
简单解析一下这个 sql 语句.
https://learnku.com/articles/24787#replies
FORM 为一个子查询，初步筛选出我们需要的作者的所有文章，且正序排列后生成一个临时表.

SELECT 为上面临时表添加标号，添加的方式如下. (你需要从上往下一行行一行的观察，与 select 的执行方式一致即可)

MySQL 中调用未定义的变量，其值默认为 null.
id	user_id	@current_user_id	if 判断	@number
1	1	null	false, number 被赋值为 1	1
2	1	1	true, @number = @number + 1	2
3	1	1	true, @number = @number + 1	3
4	1	1	true, @number = @number + 1	4
5	2	1	false, number 被赋值为 1	1
6	2	2	true, @number = @number + 1	2
..	..	..	..	..
HAVING 执行于 SELECT 之后，其再次筛选上面的临时表，只取 number <= 3 的 行.

select *, substring_index(group_concat(id order by id desc), ',', 10) from orders
group by sid;

User::with(['posts'=>function($query){
            $query->whereRaw('3 > (select count(*) from posts as sub where sub.user_id = posts.user_id and sub.id > posts.id ) ')
            ->orderByDesc('id');
        }])->get();
```
### 多更新
```javascript
update your_table set is_default = (case when id = 3 then 1 else 0 end)

```
[CTF 中的 SQL 注入总结](https://www.restran.net/2018/10/29/ctf-sqli-notes/)

[MySQL 常用技巧](https://blog.smoker.cc/mysql/common-skills.html)

[mysql 证明为什么用limit时，offset很大会影响性能](https://segmentfault.com/p/1210000008951080/read)

[MySQL 细致总结之基础篇](https://learnku.com/articles/26067)

[mysql connection time out](https://www.v2ex.com/t/472180)

[mysql replace into 坑](https://blog.xupeng.me/2013/10/11/mysql-replace-into-trap/)

[Redis学习](https://mp.weixin.qq.com/s/CMYHiW3hgDCBYH5P1XcmaQ)

[MyCAT实现MySQL读写分离](https://blog.yiranzai.cn/posts/990/)

[Redis 内存分析工具](https://github.com/xaecbd/RCT)

[mysql —— InnoDB行级锁机制](http://eienao.com/posts/mysql-innodb-row-level-locking-mechanism.html)

[MySQL 社区规范 | 数据库篇](https://learnku.com/articles/25148#topnav)

[MySQL 规范 (数据库表设计规范)](https://learnku.com/articles/25116#topnav)

[MySQL 规范](https://learnku.com/articles/25020#topnav)

[mysql数据库结构优化](http://fanqieto.top/2017/11/23/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/)

[阿里云Redis开发规范](https://mp.weixin.qq.com/s/OzAnRVPUDtoiIXqeC7YL6g)

[MySQL索引优化实战](https://mp.weixin.qq.com/s/F0PrHNqfD-JVn8if3q8S0Q)

[一个字节的网络漫游故事独白](https://mp.weixin.qq.com/s/EC5cgQ1ne9ZR0jFvznHBfg)

[技术精选](https://mp.weixin.qq.com/mp/homepage?__biz=MzI0MDQ4MTM5NQ==&hid=8&sn=1db566bed001a8db6d9927540ccc2156&scene=1&devicetype=iOS12.1.2&version=17000326&lang=zh_CN&nettype=WIFI&ascene=7&session_us=gh_53f281f2ae80&fontScale=100&wx_header=1)

[Redis过期策略及实现原理](https://mp.weixin.qq.com/s/FIMDOksAej5uqxT1YksyxA)

[19条MySQL优化](https://mp.weixin.qq.com/s/Z3Juad9pz33EWiKAH7ZgzA)

[Mysql分表和分区的区别、分库分表介绍与区别](https://www.cnblogs.com/junwangzhe/p/6420049.html)

[用Redis实现分布式锁 与 实现任务队列](https://www.cnblogs.com/it-cen/p/4984272.html)

[面试官问你如何解决web高并发这样回答就好了](https://segmentfault.com/a/1190000016902003)

[Redis实现分布式锁与任务队列的思路与源码 ](https://www.cnblogs.com/it-cen/p/4984272.html)

[PHP+Redis，实现延迟任务 实现自动取消订单，自动完成订]( https://www.cnblogs.com/-mrl/p/9519259.html)

[MySQL 图形化工具 ](https://www.v2ex.com/t/536138#reply149)

[MYSQL的SQL性能优化总结](https://mp.weixin.qq.com/s/PbtikNJlGmsR2iLSIA4aMw)

[MySQL 主从复制 实例讲解](https://www.einsition.com/article/14/details)

[Redis从入门到实践](https://juejin.im/post/5a912b3f5188257a5c608729)

[10分钟快速入门Redis](https://github.com/jaywcjlove/handbook/tree/master/Redis)

[MySQL工具汇总](http://cenalulu.github.io/mysql/mysql-tools-list/)

[MySQL 大表优化方案](http://www.54php.cn/default/240.html)

[Mysql 锁](http://www.syyong.com/db/Mysql-lock.html)

[pdo bindParam bindValue](https://www.0php.net/posts/%E5%A4%87%E5%BF%98-PHP-PDO-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html)

[MYSQL 事务隔离实验-认识：脏读、不可重复读、幻读](https://www.0php.net/posts/MySQL-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E5%AE%9E%E9%AA%8C-%E8%AE%A4%E8%AF%86%EF%BC%9A%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB.html)

[MySQL分页优化](http://seanlook.com/2018/03/21/mysql-pagination-no-offset/)

[msyql日志](https://www.awaimai.com/1910.html)

[MySQL · 最佳实践 · 分区表基本类型](http://mysql.taobao.org/monthly/2017/11/09/)

[花式搭建 Laravel 运行环境](https://laravel-china.org/topics/17508)

[mysql中的数据存储选择](http://www.helpergarden.com/2018/05/mysql%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e9%80%89%e6%8b%a9.html)

[安装LNMP开发环境](https://www.fanhaobai.com/2016/05/lnmp.html)

[Mysql Master&Slave 实战](http://www.helpergarden.com/2014/03/mysql-masterslave-%e5%ae%9e%e6%88%98.html)

[MySQL 主从复制部署与 Laravel 读写分离配置](https://www.raymondwu.net/2018/07/26/Laravel%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8EMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/)

[教你 MySQL Binlog 实用攻略](https://laravel-china.org/articles/22190)

[《高性能MySQL》学习笔记1——MySQL架构](https://www.goozp.com/article/22.html)

[MySQL 部分整理](https://laravel-china.org/articles/22188)

[PHP开发之网站安全](https://www.goozp.com/article/30.html)

[mysql的水平分库分表和垂直分库分表](https://www.woann.cn/article/10)

[MySQL 索引初探](https://laravel-china.org/articles/19472#b808e0)

[redis主从库读写分离](https://blog.csdn.net/iechenyb/article/details/79828413)

[MySQL 中的四种隔离级别](https://laravel-china.org/articles/13849/understanding-four-isolation-levels-in-mysql)

[MySQL 主从复制部署与 Laravel 读写分离配置](https://www.raymondwu.net/2018/07/26/Laravel%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8EMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/)

[部署Laravel实战：Step 4 MySQL主从复制](http://youngyu.net/post/bslaravel4)

[Redis 面试内容](https://laravel-china.org/articles/22363)

[Pika是一个可持久化的大容量redis存储服务](https://github.com/Qihoo360/pika/blob/master/README_CN.md)

[yum 快速搭建 lnmp 开发环境](https://laravel-china.org/articles/10735/yum-quickly-build-lnmp-development-environment)

[redis笔记](https://segmentfault.com/a/1190000012164089)

[面试前必须要知道的 Redis 面试内容](https://learnku.com/articles/22363#413d78)

[elastic stack来分析下你的redis slowlog](https://zhuanlan.zhihu.com/p/36337666)

[Redis 入门](http://www.thpffcj.com/2017/12/20/Redis-Getting-Started-2/)