---
title: 浅谈php设计模式
date: 2018-11-26 10:35:15
tags:
- php
---

本文来自[laravel-china](https://laravel-china.org/articles/17805?#reply72314)

接口和抽象类的概念有点相似：

接口：一个类要实现一个接口，类中必须实现接口中定义的所有方法，接口中定义的所有方法都必须是公有。

抽象类：一个类继承抽象类，子类必须定义父类中的所有抽象方法，子类中的方法访问控制（public、protected 、private）必须和父类中一样（或者更为宽松），例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。（私有比受保护的更高级和更严格）

[设计模式六大原则](https://laravel-china.org/articles/19451)

开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象.

依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

单一职责原则：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。

接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

迪米特法则 ：一个对象应该对其他对象保持最少的了解。

### 单例模式
```javascript
<?php

/**
 * 单例模式
 */
class Singleton
{
    /**
     * @var self[保存实例]
     */
    private static $instance;

    /**
     * @var
     */
    public $mix;

    /**
     * return self instance [创建一个用来实例化对象的方法]
     */
    public static function getInstace()
    {
        var_dump(isset(self::$instance));
        if (!self::$instance instanceof self) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * Singleton constructor.构造函数为private，防止创建对象
     */
    private function __construct()
    {
        echo "实例初始化了";
    }

    private function __clone()
    {
        // TODO: Implement __clone() method.
        trigger_error('Clone is not allowed!');
    }
}

// @Test
$firstSingle = Singleton::getInstace();
$secondSingle = Singleton::getInstace();
//bool(false) 实例初始化了bool(true)
$firstSingle->mix = 'one';
//一开始mix是赋值‘one',所以打印出one
print_r($firstSingle->mix);

//由于getInstace该方法保证了Singleton类只能有一个实例，不会再重新new，minx依然用firstSingle的，mix被改变成’two‘
$secondSingle->mix = 'two';  
print_r($firstSingle->mix);//TWO
print_r($secondSingle->mix);//TWO
```
### 简单工厂模式
```javascript
<?php 
//简单工厂模式
class ProductA
{
  function __construct()
  {
      echo "I am ProductA class <br>";
  }
}
class ProductB
{
  function __construct()
  {
      echo "I am ProductB class <br>";
  }
}
class Factory
{
  public static function CreateProduct($name){
      if ($name == 'A') {
          return new ProductA();
      } elseif ($name == 'B') {
          return new ProductB();
      }
  }
}
$cat = Factory::CreateProduct('A');
$dog = Factory::CreateProduct('B');
```
### 一对一抽象工厂模式
```javascript
<?php 
  interface Product{     //产品接口（核心类）
      public function getProduct();
  }
  class ProductA implements Product   //A类产品
  {
      public function getProduct(){
          echo "I'm ProductA <br>";
      }
  }
  class ProductB implements Product   /B类产品
  {
      public function getProduct(){
          echo "I'm ProductB <br>";
      }
  }
  abstract class Factory{      //抽象工厂类（抽象类）（核心工厂类）
      abstract static function createProduct();
  }
  class ProductAFactory extends Factory   //A工厂继承工厂类
  {
      public static function createProduct()
      {
          return new ProductA();   //A工厂创建A产品类对象
      }
  }
  class ProductBFactory extends Product  //B工厂继承工厂类
  {
      public static function createProduct()
      {
          return new ProductB();    //B工厂创建B产品类对象
      }
  }
    注意：声明为static的静态方法不能通过new实例化对象进行访问，必须使用类名::方法名() 访问
  $ProductA = ProductAFactory::createProduct();
  $ProductA->getProduct();
  $ProductB = ProductBFactory::createProduct();
  $ProductB->getProduct();
```


### 一对多抽象工厂模式

```javascript
<?php 
interface Mouse{     //鼠标产品接口（核心类）
      public function getMouse();  //获取鼠标
  }
class DellMouse implements Mouse   //戴尔类产品
  {
      public function getMouse(){
          echo "我是戴尔鼠标<br>";
      }
  }
class LenovoMouse implements Mouse   //联想类产品
  {
      public function getMouse(){
          echo "我是联想鼠标<br>";
      }
  }
interface Keybo{     //键盘产品接口（核心类）
      public function getKeybo();  //获取键盘
  }
class DellKeybo implements Keybo   //戴尔类产品
  {
      public function getKeybo(){
          echo "我是戴尔键盘<br>";
      }
  }
class LenovoKeybo implements Keybo   //联想类产品
  {
      public function getKeybo(){
          echo "我是联想键盘<br>";
      }
  }

abstract class Factory{      //抽象工厂类（核心工厂类）
      abstract static function createMouse(); //生产鼠标
      abstract static function createKeybo();//生产键盘
  }
class DellFactory extends Factory   //戴尔牌工厂继承工厂类
  {
      public static function createMouse()
      {
          return new DellMouse();   //工厂创建戴尔鼠标类对象
      }
            public static function createKeybo()
      {
          return new DellKeybo();   //工厂创建戴尔键盘类对象
      }
  }
class LenovoFactory extends Factory   //联想牌工厂继承工厂类
  {
      public static function createMouse()
      {
          return new LenovoMouse();   //工厂创建联想鼠标类对象
      }
            public static function createKeybo()
      {
          return new LenovoKeybo();   //工厂创建联想键盘类对象
      }
  }
  //输出“我是戴尔鼠标”
  $dell_mouse =DellFactory::createMouse();
  echo  $dell_mouse->getMouse();
  //输出“我是戴尔键盘”
  $dell_keybo = DellFactory::createKeybo();
  echo $dell_keybo->getKeybo();
  //输出“我是联想鼠标”
  $lenovo_mouse = LenovoFactory::createMouse();
  echo $lenovo_mouse->getMouse();
  //输出“我是联想键盘”
  $lenovo_keybo = LenovoFactory::createKeybo();
  echo $lenovo_keybo->getKeybo();
```
### self static
```javascript
//实例代码1
<?php
class A{
    const CURRENT = 'A';
    const A = 'A';
}
class B extends A{
    const CURRENT = 'B';
    public function get(){
        echo self::CURRENT.PHP_EOL.self::A; //这儿用的self关键字
    }
}
class C extends B{
    const CURRENT = 'C';
}
$b = new C();
$b->get();
$ php selfBind.php
B
A
//实例代码2
<?php
class A{
    const CURRENT = 'A';
    const A = 'A';
}
class B extends A{
    const CURRENT = 'B';
    public function get(){
        echo static::CURRENT.PHP_EOL.static::A; //这儿用的static关键字 https://www.snail-c.cn/article/2
    }
}
class C extends B{
    const CURRENT = 'C';
}
$b = new C();
$b->get();
$ php selfBind.php
C
A
```
### ioc
```javascript
IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦
由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。

软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。

软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。

控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。

所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。

https://learnku.com/articles/22769

```
### 多例模式
```javascript
abstract class Multiton { 
    private static $instances = array(); 
    public static function getInstance() { 
        $key = get_called_class() . serialize(func_get_args());
        if (!isset(self::$instances[$key])) { 
            $rc = new ReflectionClass(get_called_class());
            self::$instances[$key] = $rc->newInstanceArgs(func_get_args());
        }
        return self::$instances[$key]; 
    }
    /**
     * 该私有对象阻止实例被克隆
     */
    private function __clone()
    {
    }
    /**
     * 该私有方法阻止实例被序列化
     */
    private function __wakeup()
    {
    }
} 
class Hello extends Multiton { 
    public function __construct($string = 'World') { 
        echo "Hello $string\n"; 
    } 
} 
class GoodBye extends Multiton { 
    public function __construct($string = 'my', $string2 = 'darling') { 
        echo "Goodbye $string $string2\n"; 
    }
}
$a = Hello::getInstance('World'); 
$b = Hello::getInstance('bob'); 
// $a !== $b 
$c = Hello::getInstance('World'); 
// $a === $c 
$d = GoodBye::getInstance(); 
$e = GoodBye::getInstance();
// $d === $e 
$f = GoodBye::getInstance('your'); 
// $d !== $f 

```
### 简单工厂模式
```javascript
interface fruit{
    /**
     * 生长
     */
    public function grow();
    /**
     * 种植
     */
    public function plant();
    /**
     * 收获
     */
    public function harvest();
    /**
     * 吃
     */
    public function eat();
}
class apple implements fruit{
    //苹果树有年龄
    private $treeAge;
    //苹果有颜色
    private $color;
    public function grow(){
        echo "grape grow";
    }
    public function plant(){
        echo "grape plant";
    }
    public function harvest(){
        echo "grape harvest";
    }
    public function eat(){
        echo "grape eat";
    }
    //取苹果树的年龄
    public function getTreeAge(){
        return $this->treeAge;
    }
    //设置苹果树的年龄
    public function setTreeAge($age){
        $this->treeAge = $age;
        return true;
    }
}
class grape implements fruit{
    //葡萄是否有籽
    private $seedLess;
    public function grow(){
        echo "apple grow";
    }
    public function plant(){
        echo "apple plant";
    }
    public function harvest(){
        echo "apple harvest";
    }
    public function eat(){
        echo "apple eat";
    }
    //有无籽取值
    public function getSeedLess(){
        return $this->seedLess;
    }
    //设置有籽无籽
    public function setSeedLess($seed){
        $this->seedLess = $seed;
        return true;
    }
}
class farmer
{
    //定义个静态工厂方法
    public static function factory($fruitName){
        switch ($fruitName) {
            case 'apple':
                return new apple();
                break;
            case 'grape':
                return new grape();
                break;
            default:
                throw new badFruitException("Error no the fruit", 1);
                break;
        }
    }
}
class badFruitException extends Exception
{
    public $msg;
    public $errType;
    public function __construct($msg = '' , $errType = 1){
        $this->msg = $msg;
        $this->errType = $errType;
    }  
}
/**
 * 获取水果实例化的方法
 */
try{
    $appleInstance = farmer::factory('apple');
    var_dump($appleInstance);
}catch(badFruitException $err){
    echo $err->msg . "_______" . $err->errType;
}

```
### 工厂模式
```javascript
工厂模式，工厂方法或者类生成对象，而不是在代码中直接 new。 \
使用工厂模式，可以避免当改变某个类的名字或者方法之后，在调用这个类的所有的代码中都修改它的名字或者参数。

 Test1.php
 <?php
 class Test1{
      static function test(){
          echo __FILE__;
      }
  }
  Factory.php
 <?php
 class Factory{
     /*
      * 如果某个类在很多的文件中都new ClassName()，那么万一这个类的名字
      * 发生变更或者参数发生变化，如果不使用工厂模式，就需要修改每一个PHP
      * 代码，使用了工厂模式之后，只需要修改工厂类或者方法就可以了。
     */
     static function createDatabase(){
         $test = new Test1();
         return $test;
     }
 }
Test.php
 <?php
 spl_autoload_register('autoload1');

 $test = Factory::createDatabase();
 $test->test();
function autoload1($class){
     $dir  = __DIR__;
     $requireFile = $dir."\\".$class.".php";
    require $requireFile;
}

```
### 注册模式
```javascript
注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。

 <?php

  class Register
  {
      protected static  $objects;
      function set($alias,$object)//将对象注册到全局的树上
      {
          self::$objects[$alias]=$object;//将对象放到树上
      }
     static function get($name){
         return self::$objects[$name];//获取某个注册到树上的对象
     }
     function _unset($alias)
     {
         unset(self::$objects[$alias]);//移除某个注册到树上的对象。
     }
 }

```
### 适配器模式
```javascript
将各种截然不同的函数接口封装成统一的 API。 
PHP 中的数据库操作有 MySQL,MySQLi,PDO 三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的 API。类似的场景还有 cache 适配器，可以将 memcache,redis,file,apc 等不同的缓存函数，统一成一致。 
首先定义一个接口 (有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。

接口 IDatabase
 <?php
 namespace IMooc;
 interface IDatabase
 {
     function connect($host, $user, $passwd, $dbname);
     function query($sql);
     function close();
 }
MySQL

 <?php
  namespace IMooc\Database;
  use IMooc\IDatabase;
  class MySQL implements IDatabase
  {
      protected $conn;
      function connect($host, $user, $passwd, $dbname)
      {
         $conn = mysql_connect($host, $user, $passwd);
         mysql_select_db($dbname, $conn);
         $this->conn = $conn;
     }

     function query($sql)
     {
         $res = mysql_query($sql, $this->conn);
         return $res;
     }

     function close()
     {
         mysql_close($this->conn);
     }
 }
MySQLi

 <?php
  namespace IMooc\Database;
  use IMooc\IDatabase;
  class MySQLi implements IDatabase
  {
      protected $conn;

     function connect($host, $user, $passwd, $dbname)
     {
         $conn = mysqli_connect($host, $user, $passwd, $dbname);
         $this->conn = $conn;
     }

     function query($sql)
     {
         return mysqli_query($this->conn, $sql);
     }

     function close()
     {
         mysqli_close($this->conn);
     }
 }
PDO

 <?php
  namespace IMooc\Database;
  use IMooc\IDatabase;
  class PDO implements IDatabase
  {
      protected $conn;
      function connect($host, $user, $passwd, $dbname)
      {
         $conn = new \PDO("mysql:host=$host;dbname=$dbname", $user, $passwd);
         $this->conn = $conn;
     }
 function query($sql)
     {
         return $this->conn->query($sql);
     }

     function close()
     {
         unset($this->conn);
     }
 }
通过以上案例，PHP 与 MySQL 的数据库交互有三套 API，在不同的场景下可能使用不同的 API，那么开发好的代码，换一个环境，可能就要改变它的数据库 API，那么就要改写所有的代码，使用适配器模式之后，就可以使用统一的 API 去屏蔽底层的 API 差异带来的环境改变之后需要改写代码的问题。

```
### 策略模式
```javascript

策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境。 \
eg：假如有一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有的广告位展示不同的广告。在传统的代码中，都是在系统中加入各种 if else 的判断，硬编码的方式。如果有一天增加了一种用户，就需要改写代码。使用策略模式，如果新增加一种用户类型，只需要增加一种策略就可以。其他所有的地方只需要使用不同的策略就可以。 \
首先声明策略的接口文件，约定了策略的包含的行为。然后，定义各个具体的策略实现类。

 UserStrategy.php
  <?php
  /*
   * 声明策略文件的接口，约定策略包含的行为。
   */
  interface UserStrategy
  {
      function showAd();
      function showCategory();
 }
 FemaleUser.php
  <?php
  require_once 'Loader.php';
  class FemaleUser implements UserStrategy
  {
      function showAd(){
          echo "2016冬季女装";
      }
      function showCategory(){
         echo "女装";
     }
 }
  MaleUser.php
  <?php
  require_once 'Loader.php';
  class MaleUser implements UserStrategy
  {
      function showAd(){
          echo "IPhone6s";
      }
      function showCategory(){
         echo "电子产品";
     }
 }
 Page.php//执行文件
  <?php
  require_once 'Loader.php';
  class Page
  {
      protected $strategy;
      function index(){
          echo "AD";
          $this->strategy->showAd();
         echo "<br>";
         echo "Category";
         $this->strategy->showCategory();
         echo "<br>";
     }
     function setStrategy(UserStrategy $strategy){
         $this->strategy=$strategy;
     }
 }

 $page = new Page();
 if(isset($_GET['male'])){
     $strategy = new MaleUser();
 }else {
     $strategy = new FemaleUser();
 }
 $page->setStrategy($strategy);
 $page->index();
```
### 观察者模式
```javascript
1：观察者模式 (Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。 \
2：场景：一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 \
3：观察者模式实现了低耦合，非侵入式的通知与更新机制。 

定义一个事件触发抽象类。

 EventGenerator.php
  <?php
  require_once 'Loader.php';
  abstract class EventGenerator{
      private $observers = array();
      function addObserver(Observer $observer){
          $this->observers[]=$observer;
      }
      function notify(){
         foreach ($this->observers as $observer){
             $observer->update();
         }
     }
 }
定义一个观察者接口

Observer.php
<?php
require_once 'Loader.php';
interface Observer{
    function update();//这里就是在事件发生后要执行的逻辑
}
 <?php
  //一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件
  require 'Loader.php';
  class Event extends EventGenerator{
      function triger(){
          echo "Event<br>";
      }
  }
  class Observer1 implements Observer{
     function update(){
         echo "逻辑1<br>";
     }
 }
 class Observer2 implements Observer{
     function update(){
         echo "逻辑2<br>";
     }
 }
 $event = new Event();
 $event->addObserver(new Observer1());
 $event->addObserver(new Observer2());
 $event->triger();
 $event->notify();
当某个事件发生后，需要执行的逻辑增多时，可以以松耦合的方式去增删逻辑。也就是代码中的红色部分，只需要定义一个实现了观察者接口的类，实现复杂的逻辑，然后在红色的部分加上一行代码即可。这样实现了低耦合

```
### 原型模式
```javascript
原型模式（对象克隆以避免创建对象时的消耗） \
1：与工厂模式类似，都是用来创建对象。 \
2：与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过 clone 原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作。 \
3：原型模式适用于大对象的创建，创建一个大对象需要很大的开销，如果每次 new 就会消耗很大，原型模式仅需要内存拷贝即可。

Canvas.php
<?php
require_once 'Loader.php';
class Canvas{
private $data;
function init($width = 20, $height = 10)
    {
        $data = array();
        for($i = 0; $i < $height; $i++)
        {
            for($j = 0; $j < $width; $j++)
            {
                $data[$i][$j] = '*';
            }
        }
        $this->data = $data;
    }
function rect($x1, $y1, $x2, $y2)
    {
        foreach($this->data as $k1 => $line)
        {
            if ($x1 > $k1 or $x2 < $k1) continue;
           foreach($line as $k2 => $char)
            {
              if ($y1>$k2 or $y2<$k2) continue;
                $this->data[$k1][$k2] = '#';
            }
        }
    }

    function draw(){
        foreach ($this->data as $line){
            foreach ($line as $char){
                echo $char;
            }
            echo "<br>;";
        }
    }
}
 Index.php
  <?php
  require 'Loader.php';
  $c = new Canvas();
  $c->init();
  // $canvas1 = new Canvas();
  // $canvas1->init();
  $canvas1 = clone $c;//通过克隆，可以省去init()方法，这个方法循环两百次
  //去产生一个数组。当项目中需要产生很多的这样的对象时，就会new很多的对象，那样
 //是非常消耗性能的。
 $canvas1->rect(2, 2, 8, 8);
 $canvas1->draw();
 echo "-----------------------------------------<br>";
 // $canvas2 = new Canvas();
 // $canvas2->init();
 $canvas2 = clone $c;
 $canvas2->rect(1, 4, 8, 8);
 $canvas2->draw();

装饰器模式

1：装饰器模式，可以动态的添加修改类的功能 \
2：一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重写实现类的方法 \
3：使用装饰器模式，仅需要在运行时添加一个装饰器对象即可实现，可以实现最大额灵活性。
https://learnku.com/articles/34239
```
### 三大经典模式
```javascript
class Single {
    public function index() {
        return '';
    }
}
$single1 = new Single();
$single2 = new Single();
var_dump($single1);
var_dump($single2);
if ($single2 === $single1) {
    echo "是同一个对象";
} else {
    echo "不是同一个对象";
}
// object(Single)#1 (0) {
// }
// object(Single)#2 (0) {
// }
// 不是同一个对象
class Single2 {
    // 1.声明一个静态属性，用户保存类的实例
    public static $instance;
    //3. 将构函数私有化，避免外部new(每new一次，就不是同一个实例)
    private function __construct() {
    }
    // 2.声明一个静态的公共方法，用户外部调用本类的实例
    public static function getInstance() {
        if (!(self::$instance instanceof self)) {
            self::$instance = new self;
        }
        return self::$instance;
    }
    //3. 克隆函数私有化，避免外部clone(每clone一次，就不是同一个实例)
    private function __clone() {
    }
}
$singleDemo1 = Single2::getInstance();
$singleDemo2 = Single2::getInstance();
var_dump($singleDemo1->getInstance());
var_dump($singleDemo2->getInstance());
if ($singleDemo1 === $singleDemo2) {
    echo "是同一个对象";
} else {
    echo "不是同一个对象";
}
// object(Single2)#3 (0) {
// }
// object(Single2)#3 (0) {
// }
// 是同一个对象
/**
 * 工厂模式
 */
class Factory
{
    public static function createObj()
    {
        return Single::getInstance('个人技术');
    }
}
/**

 * 注册模式

 * 含义:就是将对象放在一个对象池中，使用的时候直接去对象池查找.

 * 需要如下几个操作:

 * 1.注册

 * 2.存放对象池

 * 3.获取

 * 4.销毁

 */
Class Register
{
    // 用一个数组来当做对象池，键当做对象别名，值存储具体对象
    public static $objTree = [];
    // 将对象放在对象池
    public static function set($key, $val)
    {
        return self::$objTree[$key] = $val;
    }
    // 通过对象别名在对象池中获取到对象别名
    public static function get($key)
    {
        return self::$objTree[$key];
    }
    // 通过对象别名将对象从对象池中注销
    public static function _unset($key)
    {
        unset(self::$objTree[$key]);
    }
}
Register::set('single', Factory::createObj());
$single = Register::get('single');
print_r($single);
echo $single::$attribute;
https://learnku.com/articles/36134
```

[大话 PHP 设计模式](https://learnku.com/articles/33463)

[php设计模式](https://github.com/guijianshi/DesignPattern)

[设计模式之三种工厂模式](https://learnku.com/articles/24372)

[通俗易懂的设计模式](https://laravel-china.org/articles/21370)

 [ PHP面向对象编程：面向对象概念、基本实践、高级实战、PHP面向对象特殊实践](https://segmentfault.com/a/1190000014430417#articleHeader27)

[PHP 设计模式全集 2018](https://laravel-china.org/docs/php-design-patterns/2018)

[PHP 设计模式基础](https://www.awaimai.com/patterns/basic)

[PHP经验总结 - 聊聊面向对象](https://segmentfault.com/a/1190000004067581)

[Laravel 源码阅读指南 -- PHP 类的反射和依赖注入](https://learnku.com/articles/12555/laravel-source-code-reading-guide-reflection-and-dependency-injection-for-class-php)

[设计模式超级简单的解释](https://learnku.com/articles/24982#topnav)