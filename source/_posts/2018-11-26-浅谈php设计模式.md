---
title: 浅谈php设计模式
date: 2018-11-26 10:35:15
tags:
- php
---

本文来自[laravel-china](https://laravel-china.org/articles/17805?#reply72314)

接口和抽象类的概念有点相似：

接口：一个类要实现一个接口，类中必须实现接口中定义的所有方法，接口中定义的所有方法都必须是公有。

抽象类：一个类继承抽象类，子类必须定义父类中的所有抽象方法，子类中的方法访问控制（public、protected 、private）必须和父类中一样（或者更为宽松），例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。（私有比受保护的更高级和更严格）

[设计模式六大原则](https://laravel-china.org/articles/19451)

开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象.

依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

单一职责原则：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。

接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

迪米特法则 ：一个对象应该对其他对象保持最少的了解。

### 单例模式
```javascript
<?php

/**
 * 单例模式
 */
class Singleton
{
    /**
     * @var self[保存实例]
     */
    private static $instance;

    /**
     * @var
     */
    public $mix;

    /**
     * return self instance [创建一个用来实例化对象的方法]
     */
    public static function getInstace()
    {
        var_dump(isset(self::$instance));
        if (!self::$instance instanceof self) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * Singleton constructor.构造函数为private，防止创建对象
     */
    private function __construct()
    {
        echo "实例初始化了";
    }

    private function __clone()
    {
        // TODO: Implement __clone() method.
        trigger_error('Clone is not allowed!');
    }
}

// @Test
$firstSingle = Singleton::getInstace();
$secondSingle = Singleton::getInstace();
//bool(false) 实例初始化了bool(true)
$firstSingle->mix = 'one';
//一开始mix是赋值‘one',所以打印出one
print_r($firstSingle->mix);

//由于getInstace该方法保证了Singleton类只能有一个实例，不会再重新new，minx依然用firstSingle的，mix被改变成’two‘
$secondSingle->mix = 'two';  
print_r($firstSingle->mix);//TWO
print_r($secondSingle->mix);//TWO
```
### 简单工厂模式
```javascript
<?php 
//简单工厂模式
class ProductA
{
  function __construct()
  {
      echo "I am ProductA class <br>";
  }
}
class ProductB
{
  function __construct()
  {
      echo "I am ProductB class <br>";
  }
}
class Factory
{
  public static function CreateProduct($name){
      if ($name == 'A') {
          return new ProductA();
      } elseif ($name == 'B') {
          return new ProductB();
      }
  }
}
$cat = Factory::CreateProduct('A');
$dog = Factory::CreateProduct('B');
```
### 一对一抽象工厂模式
```javascript
<?php 
  interface Product{     //产品接口（核心类）
      public function getProduct();
  }
  class ProductA implements Product   //A类产品
  {
      public function getProduct(){
          echo "I'm ProductA <br>";
      }
  }
  class ProductB implements Product   /B类产品
  {
      public function getProduct(){
          echo "I'm ProductB <br>";
      }
  }
  abstract class Factory{      //抽象工厂类（抽象类）（核心工厂类）
      abstract static function createProduct();
  }
  class ProductAFactory extends Factory   //A工厂继承工厂类
  {
      public static function createProduct()
      {
          return new ProductA();   //A工厂创建A产品类对象
      }
  }
  class ProductBFactory extends Product  //B工厂继承工厂类
  {
      public static function createProduct()
      {
          return new ProductB();    //B工厂创建B产品类对象
      }
  }
    注意：声明为static的静态方法不能通过new实例化对象进行访问，必须使用类名::方法名() 访问
  $ProductA = ProductAFactory::createProduct();
  $ProductA->getProduct();
  $ProductB = ProductBFactory::createProduct();
  $ProductB->getProduct();
```


### 一对多抽象工厂模式

```javascript
<?php 
interface Mouse{     //鼠标产品接口（核心类）
      public function getMouse();  //获取鼠标
  }
class DellMouse implements Mouse   //戴尔类产品
  {
      public function getMouse(){
          echo "我是戴尔鼠标<br>";
      }
  }
class LenovoMouse implements Mouse   //联想类产品
  {
      public function getMouse(){
          echo "我是联想鼠标<br>";
      }
  }
interface Keybo{     //键盘产品接口（核心类）
      public function getKeybo();  //获取键盘
  }
class DellKeybo implements Keybo   //戴尔类产品
  {
      public function getKeybo(){
          echo "我是戴尔键盘<br>";
      }
  }
class LenovoKeybo implements Keybo   //联想类产品
  {
      public function getKeybo(){
          echo "我是联想键盘<br>";
      }
  }

abstract class Factory{      //抽象工厂类（核心工厂类）
      abstract static function createMouse(); //生产鼠标
      abstract static function createKeybo();//生产键盘
  }
class DellFactory extends Factory   //戴尔牌工厂继承工厂类
  {
      public static function createMouse()
      {
          return new DellMouse();   //工厂创建戴尔鼠标类对象
      }
            public static function createKeybo()
      {
          return new DellKeybo();   //工厂创建戴尔键盘类对象
      }
  }
class LenovoFactory extends Factory   //联想牌工厂继承工厂类
  {
      public static function createMouse()
      {
          return new LenovoMouse();   //工厂创建联想鼠标类对象
      }
            public static function createKeybo()
      {
          return new LenovoKeybo();   //工厂创建联想键盘类对象
      }
  }
  //输出“我是戴尔鼠标”
  $dell_mouse =DellFactory::createMouse();
  echo  $dell_mouse->getMouse();
  //输出“我是戴尔键盘”
  $dell_keybo = DellFactory::createKeybo();
  echo $dell_keybo->getKeybo();
  //输出“我是联想鼠标”
  $lenovo_mouse = LenovoFactory::createMouse();
  echo $lenovo_mouse->getMouse();
  //输出“我是联想键盘”
  $lenovo_keybo = LenovoFactory::createKeybo();
  echo $lenovo_keybo->getKeybo();
```
### self static
```javascript
//实例代码1
<?php
class A{
    const CURRENT = 'A';
    const A = 'A';
}
class B extends A{
    const CURRENT = 'B';
    public function get(){
        echo self::CURRENT.PHP_EOL.self::A; //这儿用的self关键字
    }
}
class C extends B{
    const CURRENT = 'C';
}
$b = new C();
$b->get();
$ php selfBind.php
B
A
//实例代码2
<?php
class A{
    const CURRENT = 'A';
    const A = 'A';
}
class B extends A{
    const CURRENT = 'B';
    public function get(){
        echo static::CURRENT.PHP_EOL.static::A; //这儿用的static关键字 https://www.snail-c.cn/article/2
    }
}
class C extends B{
    const CURRENT = 'C';
}
$b = new C();
$b->get();
$ php selfBind.php
C
A
```
### ioc
```javascript
IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦
由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。

软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。

软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。

控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。

所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。

https://learnku.com/articles/22769

```
### 多例模式
```javascript
abstract class Multiton { 
    private static $instances = array(); 
    public static function getInstance() { 
        $key = get_called_class() . serialize(func_get_args());
        if (!isset(self::$instances[$key])) { 
            $rc = new ReflectionClass(get_called_class());
            self::$instances[$key] = $rc->newInstanceArgs(func_get_args());
        }
        return self::$instances[$key]; 
    }
    /**
     * 该私有对象阻止实例被克隆
     */
    private function __clone()
    {
    }
    /**
     * 该私有方法阻止实例被序列化
     */
    private function __wakeup()
    {
    }
} 
class Hello extends Multiton { 
    public function __construct($string = 'World') { 
        echo "Hello $string\n"; 
    } 
} 
class GoodBye extends Multiton { 
    public function __construct($string = 'my', $string2 = 'darling') { 
        echo "Goodbye $string $string2\n"; 
    }
}
$a = Hello::getInstance('World'); 
$b = Hello::getInstance('bob'); 
// $a !== $b 
$c = Hello::getInstance('World'); 
// $a === $c 
$d = GoodBye::getInstance(); 
$e = GoodBye::getInstance();
// $d === $e 
$f = GoodBye::getInstance('your'); 
// $d !== $f 

```
### 简单工厂模式
```javascript
interface fruit{
    /**
     * 生长
     */
    public function grow();
    /**
     * 种植
     */
    public function plant();
    /**
     * 收获
     */
    public function harvest();
    /**
     * 吃
     */
    public function eat();
}
class apple implements fruit{
    //苹果树有年龄
    private $treeAge;
    //苹果有颜色
    private $color;
    public function grow(){
        echo "grape grow";
    }
    public function plant(){
        echo "grape plant";
    }
    public function harvest(){
        echo "grape harvest";
    }
    public function eat(){
        echo "grape eat";
    }
    //取苹果树的年龄
    public function getTreeAge(){
        return $this->treeAge;
    }
    //设置苹果树的年龄
    public function setTreeAge($age){
        $this->treeAge = $age;
        return true;
    }
}
class grape implements fruit{
    //葡萄是否有籽
    private $seedLess;
    public function grow(){
        echo "apple grow";
    }
    public function plant(){
        echo "apple plant";
    }
    public function harvest(){
        echo "apple harvest";
    }
    public function eat(){
        echo "apple eat";
    }
    //有无籽取值
    public function getSeedLess(){
        return $this->seedLess;
    }
    //设置有籽无籽
    public function setSeedLess($seed){
        $this->seedLess = $seed;
        return true;
    }
}
class farmer
{
    //定义个静态工厂方法
    public static function factory($fruitName){
        switch ($fruitName) {
            case 'apple':
                return new apple();
                break;
            case 'grape':
                return new grape();
                break;
            default:
                throw new badFruitException("Error no the fruit", 1);
                break;
        }
    }
}
class badFruitException extends Exception
{
    public $msg;
    public $errType;
    public function __construct($msg = '' , $errType = 1){
        $this->msg = $msg;
        $this->errType = $errType;
    }  
}
/**
 * 获取水果实例化的方法
 */
try{
    $appleInstance = farmer::factory('apple');
    var_dump($appleInstance);
}catch(badFruitException $err){
    echo $err->msg . "_______" . $err->errType;
}

```
[大话 PHP 设计模式](https://learnku.com/articles/33463)

[php设计模式](https://github.com/guijianshi/DesignPattern)

[设计模式之三种工厂模式](https://learnku.com/articles/24372)

[通俗易懂的设计模式](https://laravel-china.org/articles/21370)

 [ PHP面向对象编程：面向对象概念、基本实践、高级实战、PHP面向对象特殊实践](https://segmentfault.com/a/1190000014430417#articleHeader27)

[PHP 设计模式全集 2018](https://laravel-china.org/docs/php-design-patterns/2018)

[PHP 设计模式基础](https://www.awaimai.com/patterns/basic)

[PHP经验总结 - 聊聊面向对象](https://segmentfault.com/a/1190000004067581)

[Laravel 源码阅读指南 -- PHP 类的反射和依赖注入](https://learnku.com/articles/12555/laravel-source-code-reading-guide-reflection-and-dependency-injection-for-class-php)

[设计模式超级简单的解释](https://learnku.com/articles/24982#topnav)