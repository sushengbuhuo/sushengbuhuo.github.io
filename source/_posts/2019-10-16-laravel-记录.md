---
title: laravel 记录
date: 2019-10-16 19:45:15
tags:
---
### Laravel 网站不会被嵌入到其他站点中
```javascript

HTTP 响应头部中，有一个字段，叫做 X-Frame-Options，该字段可以用来指示是否允许自己的网站被嵌入到其他网站的 <iframe> 或者 <object> 标签中。该头部有三个值

DENY - 始终不允许嵌入，即使是同一个域名
SAMEORIGIN - 只能在相同域名中嵌入
ALLOW-FROM uri - 设置允许的域
通常，可以在 HTTP 代理中进行配置，比如 nginx

add_header X-Frame-Options SAMEORIGIN;
Laravel 自带了用来「只允许同域名嵌入」的中间件，我们只需要在 /app/Http/Kernel.php 中添加即可

// /app/Http/Kernel.php
protected $middleware = [
    \Illuminate\Http\Middleware\FrameGuard::class,
];
该中间件的实现如下

<?php

namespace Illuminate\Http\Middleware;

use Closure;

class FrameGuard
{
    /**
     * Handle the given request and get the response.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Symfony\Component\HttpFoundation\Response
     */
    public function handle($request, Closure $next)
    {
        $response = $next($request);

        $response->headers->set('X-Frame-Options', 'SAMEORIGIN', false);

        return $response;
    }
}
https://learnku.com/articles/35201
https://securityheaders.com/

可以直接扫描特定 URL 是否包含一些安全头信息。类似的头还有 X-Content-Type-Options、 Referrer-Policy、Feature-Policy 等。

```
### Uncaught ReflectionException: Class request does not exist
```javascript
PHP Fatal error:  Uncaught ReflectionException: Class request does not exist in /home/vagrant/learnku/vendor/laravel/framework/src/Illuminate/Container/Container.php:790
Stack trace:
在 App\Exceptions\Handler::report() 方法里，使用：

dd($exception);
```
### Laravel 下 TNTSearch+jieba-PHP 实现中文全文搜索
```javascript
TNTSearch+jieba-php 这套组合可以在不依赖第三方的情况下实现中文全文搜索；
composer require vanry/laravel-scout-tntsearch
'providers' => [
    ...
    /**
     * TNTSearch 全文搜索
     */
    Laravel\Scout\ScoutServiceProvider::class,
    Vanry\Scout\TNTSearchScoutServiceProvider::class,
],
composer require fukuball/jieba-php

php artisan vendor:publish --provider="Laravel\Scout\ScoutServiceProvider"

配置项 config/scout.php 中增加 tntsearch

'tntsearch' => [
    'storage' => storage_path('indexes'), //必须有可写权限
    'fuzziness' => env('TNTSEARCH_FUZZINESS', false),
    'searchBoolean' => env('TNTSEARCH_BOOLEAN', false),
    'asYouType' => false,

    'fuzzy' => [
        'prefix_length' => 2,
        'max_expansions' => 50,
        'distance' => 2,
    ],

    'tokenizer' => [
        'driver' => env('TNTSEARCH_TOKENIZER', 'default'),

        'jieba' => [
            'dict' => 'small',
            //'user_dict' => resource_path('dicts/mydict.txt'), //自定义词典路径
        ],

        'analysis' => [
            'result_type' => 2,
            'unit_word' => true,
            'differ_max' => true,
        ],

        'scws' => [
            'charset' => 'utf-8',
            'dict' => '/usr/local/scws/etc/dict.utf8.xdb',
            'rule' => '/usr/local/scws/etc/rules.utf8.ini',
            'multi' => 1,
            'ignore' => true,
            'duality' => false,
        ],
    ],

    'stopwords' => [
        '的',
        '了',
        '而是',
    ],
],
 env 增加配置项

SCOUT_DRIVER=tntsearch
TNTSEARCH_TOKENIZER=jieba
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Laravel\Scout\Searchable;

class Article extends Model
{
    use Searchable;

    /**
     * 索引的字段
     *
     * @return array
     */
    public function toSearchableArray()
    {
        return $this->only('id', 'title', 'content');

       // return $this->toArray();
    }
}
生成索引：

php artisan scout:import "App\Model\Article"
https://learnku.com/articles/27617#replies 
```
### 二分查找
```javascript
原理实现：有序集合从中间分为前后2部分，当要查当数值等于中间值，直接返回；当要查询数值大于中间值，则说明要查询的数值在后半部分，那么继续二分后半部分；当要查询数值小于中间数值时，说明要查询的数值在前半部分，那么继续二分前半部分。（过滤掉一半数据查询）

<?php
    /**
     * 递归实现
     * array $arr 有序数组
     * int $search 要查询的数字
     * int firstIndex 数组起始位置
     * int lastIndex 数组结束位置
     * @return 
     */
    function binarySearchRecursion(array $arr, $search, $lastIndex, $firstIndex = 0)
    {
        $len = count($arr);
        if ($len <= 0) {
            return -1;
        }
        $middle = intval(($firstIndex + $lastIndex) / 2);
        if ($search == $arr[$middle]) {//找到直接返回
            return $arr[$middle];
        } elseif ($search > $arr[$middle]) {//去后面查，数组起始位置变为$middle + 1。
            return binarySearchRecursion($arr, $search, $middle + 1, $lastIndex);
        } else {//去前面查，数组结束位置为$middle - 1。
            return binarySearchRecursion($arr, $search, $firstIndex, $middle - 1);
        }
        return -1;
    }

    /**
     * 递归实现
     * array $arr 有序数组
     * int $search 要查询的数字
     * @return 
     */
     function binarySearch($arr, $search)
     {
        $len = count($arr);
        if ($len <= 0 ) {
            return -1;
        }
        $firstIndex = 0;
        $lastIndex = $len - 1;
        while($firstIndex <= $lastIndex) {
            $middle = intval(($firstIndex + $lastIndex) / 2);
            if ($search == $arr[$middle]) {//出口
                return $arr[$middle];
            } elseif ($search > $arr[$middle]) {//去后面查，数组起始位置变为$middle + 1。
                $firstIndex = $middle + 1;
            } else {//去前面查，数组结束位置为$middle - 1。
                $lastIndex = $middle - 1;
            }
        }
        return -1;
     }
     https://learnku.com/articles/35240
```
### 子孙树
```javascript
$arr = [
    ['id'=>1,'parent_id'=>0,'type'=>5],
    ['id'=>2,'parent_id'=>1,'type'=>3],
    ['id'=>3,'parent_id'=>0,'type'=>1],
    ['id'=>4,'parent_id'=>3,'type'=>3],
];
var_dump(getSubTree($arr));

function getSubTree($data, $parent = 'parent_id', $son = 'id', $pid = 0)
    {
        $tmp = [];
        foreach ($data as $key => $value) {
            if ($value[$parent] == $pid) {
                $value['child'] = getSubTree($data, $parent, $son, $value[$son]);
                $tmp[] = $value;
            }
        }
        return $tmp;
    }
    http://www.putyy.com/article/42

```
###  Laravel 的设计哲学
```javascript
class UserController extends Controller
{
    public function index()
    {
        $users = User::all();

        return view('users.index', compact('users'));
    }
}
改为 <?php
   
   namespace App\Repositories;
   
   use App\User;
   
   class DbUserRepository
   {
       public function all(): array
       {
           return User::all()->toArray();
       }
   }
   
   class UserController extends Controller
   {
       private $users;
   
       public function __construct( )
       {
           $this->users = new DbUserRepository;
           // $this->users = new RedisRepository;
       }
   
       public function index()
       {   
           $users = $this->users->all();
           return $users;
       }
   }
   依赖正转的不合理之处在哪里呢？位于高层的控制器依赖于具体的底层数据获取服务，当底层发生变动时，就需要对应的修改高层的内部结构。
   
   我们对依赖关系进一步分析，可知控制器关注的并不是具体如何获取数据，控制器关注的是「数据的可获取性」这一抽象。因此，我们应当将依赖关系进行反转，将对依赖的具体声明职责转移到外部，让控制器仅依赖于抽象层（数据的可获取性）。这种解决方式称之为 控制反转 或 依赖倒置。通过控制反转，高层不再依赖于具体的底层，仅仅是依赖于抽象层，高层和底层实现了解耦。
   用接口来表示「数据的可获取性」这一抽象
   
   <?php
   
   namespace App\Repositories;
   
   interface UserRepositoryInterface
   {
       public function all(): array;
   }
   UserController 依赖的是「数据的可获取性」，不依赖于具体的实现
   
   class UserController extends Controller
   {
       private $users;
   
       public function __construct(UserRepositoryInterface $users)
       {
           $this->users = $users;
       }
   }
   具体的实现交给对应的仓库类即可
   
   class DbUserRepository implements UserRepositoryInterface {}
   class RedisRepository implements UserRepositoryInterface { }
   根据自己的需要注入对应的服务，这样就实现了依赖注入。
   
   $userRepository = new DbUserRepository;
   $userController = new UserController($userRepository)
   总的来说，依赖注入由四部分构成
   
   被使用的服务 - DbUserRepository 或者 RedisRepository 等
   依赖某种服务的客户端 - UserController
   声明客户端如何依赖服务的接口 - UserRepositoryInterface
   依赖注入器，用于决定注入哪项服务给客户端
   
   一个简单的服务容器的实现
   
   namespace App\Services;
   
   use Exception;
   
   class Container 
   {
       protected static $container = [];
   
       /**
        * 绑定服务
        * 
        * @param  服务名称 $name 
        * @param  Callable $resolver
        * @return void
        */
       public static function bind($name, Callable $resolver)
       {   
           static::$container[$name] = $resolver;
       }
   
       /**
        * 解析服务
        * 
        * @param  服务名称 $name
        * @return mix
        */
       public static function make($name)
       {
           if(isset(static::$container[$name])){
               $resolver = static::$container[$name];
               return $resolver();
           }
   
           throw new Exception("不存在该绑定");
      }
   
   }
   绑定服务
   
   App\Services\Container::bind('UserRepository', function(){
       return new App\Repositories\DbUserRepository;
   });
   解析服务
   
   $userRepository = App\Services\Container::make('UserRepository');
   $userController = new UserController($userRepository)
   Laravel 的服务容器的功能则更加的强大，比如，可以将接口与具体的实现进行绑定，通常在 服务提供者 中使用服务容器来进行绑定
   
   public function register()
   {
       $this->app->singleton(UserRepositoryInterface::class, function ($app) {
           return new UserRepository;
       });
   }
   
   
```
### 高并发业务场景下的秒杀解决方案
```javascript

在秒杀前将商品的库存信息加入到 Redis 缓存中。如下格式:
$redis->lpush('商品id',1);
/**
 *
 * 1.接受用户请求
 * 2.验证用户是否已经参与秒杀,商品是否存在
 * 3.根据商品id减少商品队列中的库存数量
 * 4.将用户的秒杀数据写入server层中,并返回秒杀数据对应的唯一key值
 * 5.用户点击下单,根据serve层中的缓存数据,生成订单数据并减少数据库商品的库存数据
 */
$getParams = $_POST;
$userId = $getParams['userId'];
$goodsId = $getParams['goodsId'];

$key = 'goods:miaosha:';
$userResult = $redis->get($key.$userId);
if($userResult){
    $userResult = json_decode($userResult,true);
    echo json_encode(['result'=>$userResult['result'],'key'=>$key.$userId]);// 已经参与过秒杀了
    die();
}else{
    $goodqueue = 'goods:queue:'.$goodsId;
    $result = $redis->lpop($goodqueue);// 删除商品redis队列缓存
    if($result){
        $data = json_encode(['result'=>'OK','userId'=>$userId,'goodsId'=>$goodsId]);
        $redis->set($key.$userId,$data);// 将秒杀信息写入缓存中
        echo json_encode(['result'=>'OK','userId'=>$userId,'goodsId'=>$goodsId,'key'=>$key.$userId]);
        die();
    }else{
        echo json_encode(['result'=>'FAIL','message'=>'商品不存在','goodsId'=>$goodsId]);// 商品库存不存在
        die();
    }
}/**
  * 用户下单界面
  */
 require_once __DIR__.'/redis_connect.php';
 $key = $_GET['key'];
 $data = $redis->get($key);
 /**
  * 生成订单，订单入库
  *
  */https://learnku.com/articles/35141
redis list 可以批量插入数据，不一定每次都只插入一个值.

$numberArr = range(1,100);  
//var_dump($numberArr);
$redis->lPush('goods:queue:5',...$numberArr); // 可变参数  
```
### PHP 开启 Opcache 后如何优雅地部署 PHP 代码
```javascript
提交了代码并且部署了以后，线上代码依然是旧的。所以我执行了下
/etc/init.d/php-fpm reload 就生效了。
opcache_reset (); 但是注意了 这个函数是强制清楚所有 cache 所以 如果并发较高的系统 不能直接这么搞 还有就是 它有两个清除模式，cli 下只能清除 cli 的 cache fpm 的话 必须通过 fpm 请求方式清除才行
https://github.com/gordalina/cachetool
https://learnku.com/laravel/t/35142
```
### 模型::query () 无数据
```javascript
public function getPost()
{
 return Post::query()
}

public function index()
{
   $post = $this->getPost();
    return view('index', [
    'post' => $post
    ]);
}
@foreach($post->where('category_id',2)->get() as xxx){...}
@foreach($post->where('category_id',3)->get() as xxx){...}
改(clone $post)->where(xxxxxxxxx)
https://learnku.com/laravel/t/35341


```
### JSON_encode 小数位丢失
```javascript
$a = '{"orderAmt":500.00}';
$a_json_decode = json_decode($a,true);
[                      
  "orderAmt" => 500.0, 
]                      
$a_json_encode = json_encode($a_json_decode);
"{"orderAmt":500}"
使用字符串类型的 500.00，或使用字符串拼接 JSON 
json_encode($a_json_decode, JSON_PRESERVE_ZERO_FRACTION)
=> "{"orderAmt":500.0}"

https://learnku.com/laravel/t/35311

 从 PHP 5.6.6+ 开始，json_encode 支持使用 JSON_PRESERVE_ZERO_FRACTION 选项以告知引擎确保浮点数始终编码为浮点数，但对于形如 500.00 （值为 500，精确到小数点后两位的浮点数）仅能保证最终输出 500.0
 
 即使临时配置 serialize_precision 为 10，在初始化数组时使用 number_format 函数格式化小数位数，最后在 json_encode 时填入选项 JSON_PRESERVE_ZERO_FRACTION | JSON_NUMERIC_CHECK 也仅能输出 500.0。
 
```
### 支付宝公钥证书 PHP 版本 SDK
```javascript
function getRootCertSN($str)
    {
        // return '687b59193f3f462dd5336e5abf83c5d8_02941eef3187dddf3d3b83462e1dfcf6';
        $arr = preg_split('/(?=-----BEGIN)/', $str, -1, PREG_SPLIT_NO_EMPTY);
        $str = null;
        foreach ($arr as $e) {
            $sn = getCertSN($e, true);
            if (!$sn) {
                continue;
            }
            if ($str === null) {
                $str = $sn;
            } else {
                $str .= "_" . $sn;
            }
        }
        return $str;
    }

    function getCertSN($str, $matchAlgo = false)
    {
        /*
        根据java SDK源码：AntCertificationUtil::getRootCertSN
        对证书链中RSA的项目进行过滤（猜测是gm国密算法java抛错搞不定，故意略去）
        java源码为：

        if(c.getSigAlgOID().startsWith("1.2.840.113549.1.1"))

        根据 https://www.alvestrand.no/objectid/1.2.840.113549.1.1.html
        该OID为RSA算法系。
         */
        if ($matchAlgo) {
            openssl_x509_export($str, $out, false);
            if (!preg_match('/Signature Algorithm:.*?RSA/im', $out, $m)) {
                return;
            }

        }
        $a = openssl_x509_parse($str);
        $issuer = null;
        // 注意：根据java代码输出，需要倒着排列 CN,OU,O
        foreach ($a["issuer"] as $k => $v) {
            if ($issuer === null) {
                $issuer = "$k=$v";
            } else {
                $issuer = "$k=$v," . $issuer;
            }
        }
        #    echo($issuer . $a["serialNumber"] . "\n");
        $serialNumberHex = decimalNotation($a['serialNumberHex']);
        $sn = md5($issuer . $serialNumberHex);
        return $sn;
    }

    function decimalNotation($hex)
    {
        $dec = 0;
        $len = strlen($hex);
        for ($i = 1; $i <= $len; $i++) {
            $dec = bcadd($dec, bcmul(strval(hexdec($hex[$i - 1])), bcpow('16', strval($len - $i))));
        }
        return $dec;
    }
https://learnku.com/articles/35315
```
### 字符串表达式计算
```javascript
$a = 10;
var_dump(eval('return $a > 5;'));

// 输出:
// bool(true)
system('php -r "echo 1 + 2;"');

echo exec('php -r "echo 1 + 2;"');
https://shockerli.net/post/php-expression-string/
```
### 用户登录密码改为 md5
```javascript
新建一个文件 Libraries，在 Libraries 目录下新建一个 MD5.php 文件

namespace App\Libraries; 

use Illuminate\Contracts\Hashing\Hasher; 

class MD5 implements Hasher 
{ 
    /** 
     * Hash the given value. 
     * 
     * @param string $value 
     * 
     * @return array  $options 
     * @return string 
     */ 
    public function make($value, array $options = []) 
    { 
        return md5($value); 
    } 

    /** 
     * Check the given plain value against a hash. 
     * 
     * @param string $value 
     * @param string $hashedValue 
     * @param array $options 
     * 
     * @return bool 
     */ 
    public function check($value, $hashedValue, array $options = []) 
    { 
        if(empty($hashedValue)){ 
            return true; 
        } 
        return $this->make($value) === $hashedValue; 
    } 

    /** 
     * Check if the given hash has been hashed using the given options. 
     * 
     * @param string $hashedValue 
     * @param array $options 
     * 
     * @return bool 
     */ 
    public function needsRehash($hashedValue, array $options = []) 
    { 
        return false; 
    } 
} 
 Providers 文件下面新建一个文件 MD5ServiceProvider.php
 namespace App\Providers; 
 
 use Illuminate\Auth\EloquentUserProvider; 
 class MD5ServiceProvider extends EloquentUserProvider 
 { 
 
     //继承EloquentUserProvider类，调用父类的构造函数 
     public function __construct($hasher, $model) 
     { 
         parent::__construct($hasher, $model); 
     } 
 
     /** 
      * Bootstrap the application services. 
      * 
      * @return void 
      */ 
     public function boot() 
     { 
         // 
     } 
 
     /** 
      * Register the application services. 
      * 
      * @return void 
      */ 
     public function register() 
     { 
         // 
     } 
 } 
  AuthServiceProvider.php 文件里 boot 方法里添加如下代码
 
         Auth::provider('MD5', function ($app) { 
             $model = config('auth.providers.users.model'); 
             return new MD5ServiceProvider(new MD5, $model); 
         }); 
修改 config/auth.php 里的 providers
'providers' => [
        'users' => [
            'driver' => 'MD5',//'driver' => 'eloquent',//eloquent默认加密码方式
            'model' => App\User::class,
        ],
        'admins' => [
            'driver' => 'eloquent',
            'model' => App\Admin::class,
        ],
        修改 app/Http/Controllers/Auth/RegisterController.php 里的 create，修改代码如下
        
            protected function create(array $data)
            {
                return User::create([
                    'name' => $data['name'],
                    'email' => $data['email'],
                    'password' => md5($data['password']),
                ]);
            }
            https://learnku.com/articles/35407
```
### Laravel跨库跨连接的事务操作
```javascript
Laravel 下的跨库事务操作是基于连接的 当执行 DB::beginTransaction(); 的时候 其实是和默认的数据库配置建立了连接 后面的操作 commit 或者 rollback 都是操作的这个默认数据库 如果在这中间操作了其他的数据库 对他是不生效的
同时 commit 和 rollback 都 指定连接
try {
    //开启默认数据库的事务
    DB::beginTransaction();
    //开启test数据库的事务
    DB::connection('test')->beginTransaction();
    //中间各种数据库操作
    Table1::xxxxxx();
    Table2::xxxxxx();
    if (true) {
        //一起提交
        DB::commit();
        DB::connection('test')->commit();
    } else {
        //一起回滚
        DB::rollback();
        DB::connection('test')->rollback();
    }
} catch (\Exception $exception) {
    echo "catch some errors:".$exception->getMessage();
}
https://caihongtengxu.github.io/2018/20181009/index.html
```
### array_splice无法自定义键值
```javascript
function array_insert (&$array, $position, $insert_array) {
            $first_array = array_splice ($array, 0, $position);
            $array = array_merge ($first_array, $insert_array, $array);
        }


        $arr = array(
            'tt' => 1333,
            'cc' => 333,
            'aaz' => 2333,
            'ee' => 78,
        );
        $temp["bb"] = 33;
        array_insert($arr,1,$temp);
>>> $arr
=> [
     "tt" => 1333,
     "bb" => 33,
     "cc" => 333,
     "aaz" => 2333,
     "ee" => 78,
   ]
```
### 数字转度量
```javascript
/**
 * 数字转度量
 *
 * @param int $num 数字
 * @return string|int
 */
function num2metric($num, $precision = 0) {
    $unitList = [
        'P' => 15,
        'T' => 12,
        'G' => 9,
        'M' => 6,
        'W' => 4,
        'K' => 3,
    ];

    $num = (int) $num;

    foreach($unitList as $name => $pow) {
        $size = pow(10, $pow);

        if($num >= $size) {
            return round($num / $size * 100, $precision) / 100 . $name;
        }
    }

    return $num;
}
https://www.hongfs.cn/2018/10/php/php-metric-prefix/
num2metric(1000) // 1K
num2metric('10000') // 1W
num2metric('A') // 0

```
### 获取两个坐标之间距离
```javascript
/**
 * 获取两个坐标之间距离
 *
 * @param int|float $lat1 第一个坐标纬度
 * @param int|float $lon1 第一个坐标经度
 * @param int|float $lat2 第一个坐标纬度
 * @param int|float $lon2 第二个坐标经度
 * @param string $unit 距离单位 M 法定英里 K 公里 N 海里
 * @return int|float
 */
function getDistanceBetweenPoints($lat1, $lon1, $lat2, $lon2, $unit = 'K') {
    if (($lat1 == $lat2) && ($lon1 == $lon2)) {
        return 0;
    }

    $theta = $lon1 - $lon2;
    $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));
    $dist = acos($dist);
    $dist = rad2deg($dist);
    $miles = $dist * 60 * 1.1515;
    $unit = strtoupper($unit);

    if ($unit === 'K') {
        return $miles * 1.609344;
    } else if ($unit === 'N') {
        return $miles * 0.8684;
    } else {
        return $miles;
    }
}https://www.hongfs.cn/2019/06/php/php-get-distance-between-points/
getDistanceBetweenPoints(113.276885, 23.090654, 113.320331, 23.096197);
// PHP: 4.8368890520256 公里
// 高德地图: 4491 米
//restapi.amap.com/v3/distance？key-您的key&origins=113.276885，23.090654&destination=113.320331，23.096197&type=e
```
### Laravel 上传图片
```javascript
/**
 * 后缀名验证
 *
 * @param  string  $extension  后缀名
 * @return bool
 */
protected function has_extension(string $extension)
{
    return in_array($extension, ['jpg', 'jpeg', 'png', 'gif', 'bmp']);
}

/**
 * 图片上传
 *
 * @param  \Illuminate\Http\Request  $request
 * @return \Illuminate\Http\Response
 */
public function index(Request $request)
{
    // 获取上传键值
    $name = $request->input('name', 'file');

    if($request->hasFile($name)) {
        // 文件格式上传

        $file = $request->file($name);
        $extension = $file->extension();

        if(!$this->has_extension($extension)) {
            return '格式错误';
        }

        $filename = $file->store();
    } else if(preg_match('/^(data:\s*image\/(\w+);base64,)/', $request->input($name), $matches)) {
        // base64 上传

        $extension = $matches[2];

        if(!$this->has_extension($extension)) {
            return '格式错误';
        }

        $file = $request->input($name);
        $file = preg_replace('/^(data:\s*image\/(\w+);base64,)/', '', $file);
        $file = str_replace(' ', '+', $file);

        // 生成保存文件名
        $filename = str_random(40) . '.' . $extension;
        Storage::put($filename, base64_decode($file));
    } else {
        return '格式错误';
    }
    
    return '上传成功[' . $filename . ']';
}https://www.hongfs.cn/2019/06/php/laravel/laravel-upload-image/

```
### 拼音排序
```javascript
$ composer require "overtrue/pinyin:~4.0"
 /**
     * 地区列表 - 拼音排序
     *
     * @return \Illuminate\Http\Response
     */
    public function list()
    {
        $list_tmp = DB::table('area')
                        ->select('code', 'name')
                        ->orderBy(DB::raw('convert(name using gbk)'))
                        ->get();

        $pinyin = new Pinyin();

        $list = [];

        $list_tmp->map(function($item) use(&$list, $pinyin) {
            // 去除城市名最后面的市字
            // if(substr($item->name, -3) === '市') {
            //     $item->name = substr($item->name, 0, -3);
            // }

            // 获取城市名第一个字
            $name_first = substr($item->name, 0, 3);

            // 获取拼音
            $name_pinyin = $pinyin->convert($name_first)[0];

            // 获取第一个字母并且转换为大写
            $name_pinyin = strtoupper(substr($name_pinyin, 0, 1));

            if(!isset($list[$name_pinyin])) {
                $list[$name_pinyin] = [];
            }

            $list[$name_pinyin][] = (array) $item;
        });
        {
            "code": 1,
            "data": {
                "G": [
                    {
                        "code": 5108,
                        "name": "广元市"
                    },
                    {
                        "code": 4401,
                        "name": "广州市"
                    }
                ],
                "S": [
                    {
                        "code": 4403,
                        "name": "深圳市"
                    }
                ]
            }
        }
https://www.hongfs.cn/2019/09/php/laravel/laravel-area-list-pinyin-sort/
```
### PHP读取微信客户端数据库
```javascript
  class MyDB extends SQLite3
   {
      function __construct()
      {
      //根据sqlite提供的open接口，输入密钥key，
      //$this->open('EnMicroMsg.db',SQLITE3_OPEN_READWRITE,'71ca1d4');
         $this->open('test.db');//test.db存在就链接，不存在就创建
      }
   }
   $db = new MyDB();
   if(!$db){
      echo $db->lastErrorMsg();
   } else {
      echo "Opened database successfully\n";
   }

   $sql =<<<EOF
      SELECT * from COMPANY;
EOF;

   $ret = $db->query($sql);
   while($row = $ret->fetchArray(SQLITE3_ASSOC) ){
      echo "ID = ". $row['ID'] . "\n";
      echo "NAME = ". $row['NAME'] ."\n";
      echo "ADDRESS = ". $row['ADDRESS'] ."\n";
      echo "SALARY =  ".$row['SALARY'] ."\n\n";
   }
   echo "Operation done successfully\n";
   $db->close();
https://learnku.com/laravel/t/35478
```
### PHP7.4 可能会对 Laravel 生态带来的改变
```javascript
php 7.4 alpha 版本已经发布了，新特性很多，不过我只关注了预加载（preload）特性。
我们都知道，laravel include 的文件比较多，会带来较大的磁盘 io, 预加载则直接解决了这个问题。https://learnku.com/laravel/t/30557  
fpm 基本不会成为你的并发瓶颈，数据库往往率先成为并发的瓶颈。
只有在网络通讯应用中，fpm 才有可能成为瓶颈，但是，fpm 也不能作为通讯组件来使用啊

开启 preload 后，对于需要加载很多文件的项目来说，性能直接有 13%~16% 的提升，那些加载文件过多的框架和项目将会得到和加载一个文件的项目接近的性能
这个特性，是直击 laravel 的痛点的。
我们都知道，laravel 这个框架，加载了很多文件导致性能比一般框架要慢，这个预加载功能，可以助推 laravel 的普及

php 的运行模式本来就有 fpm 和 cli 两种，其中 fpm 属于 php 的一种特色，目的是简化 web 开发，从而让开发者专注于创作，而不是处理技术细节。preload 的灵感来自于 java 的 HotSpot（jvm 的黑科技，可以做到平均 gc 时长仅为 1 毫秒），也就是在不增加开发复杂度的情况下，对性能进行 16%～16% 的透明提升，这对于有性能提升需求，但又不想改变 fpm 模式的项目来说意义是很大的。

如果你的项目规模超大（我对超大的定义是 uv / 日大于 2 亿），如果还继续使用 php 的话，那么就可以用 php 的 cli 模式自定义 http 服务，通过 epool 或者 sellect 实现 io 异步轮询，php 文件直接常驻内存，对于性能的提升（对比于 fpm）通常会有 20 到 80 倍的性能提升。跟此相关的解决方案有 workerman，swoole 等。

刚才没事跑到 thinkphp 官网上，看到了他们把 workman 作为了框架的一部分，用 workman 启动一个 httpServer，就可以切换到常驻内存模式，在编码上会有一点改变，比如 fpm 模式下的 session，文件上传，和 cli 的就不是一回事了，但是如果项目本身使用了 thinkphp 框架封装好的 seesion 或者文件上传方法，那么就不会有问题，这意味着，如果前期你为了赶进度使用了 fpm 模式，那么到了后期，你仍然有无缝切换到 cli 模式的选择权。


```
### 无限极分类
```javascript
$arrs = [
    [
        'id'=>1,
        'parent_id'=>0
    ],
    [
        'id'=>2,
        'parent_id'=>1
    ],
    [
        'id'=>3,
        'parent_id'=>2
    ],
    [
        'id'=>4,
        'parent_id'=>0
    ],
    [
        'id'=>5,
        'parent_id'=>0
    ],
];function children($id,$arrs){
      $result =[];
      foreach ($arrs as $v){
          if($id==$v['parent_id']){
              $result[]=$v;
          }
      }
      return $result;
  }
>>> children(0,$arrs)
=> [
     [
       "id" => 1,
       "parent_id" => 0,
     ],
     [
       "id" => 4,
       "parent_id" => 0,
     ],
     [
       "id" => 5,
       "parent_id" => 0,
     ],
   ]
   
   function allChildren($id,$arrs){
   
       $result = [];
       $children = children($id,$arrs);//获取儿子数组
       foreach($children as $k=>$child){
           $result[$k]=$child;
           $childResult = allChildren($child['id'],$arrs);//获取儿子的儿子的儿子无穷尽也
           foreach ($childResult as $subChild) {
               $child['children'][]=$subChild;
               $result[$k] = $child;
           }
       }
       return $result;
   }
   
   //实现类似于children($id,$arrs)方法
    public function children(){
           return $this->hasMany(get_class($this),'parent_id');
       }
   //实现了上面的allChildren($id,$arrs)方法
   public function getAllChildren()
       {
           $result = [];
           $children = $this->children;
   
           foreach ($children as $child) {
               $result[] = $child;
   
               $childResult = $child->getAllChildren();
               foreach ($childResult as $subChild) {
                   $result[] = $subChild;
               }
           }
   
           return $result;
       }
   测试
   https://learnku.com/articles/12466/unlimited-classification#reply52473
   Model::find(1)->getAllChildren();
   public function children() {
        return $this->hasMany(get_class($this), 'parent_id' );
    }

    public function allChildren() {
        return $this->children()->with( 'allChildren' );
    }
    https://github.com/betterde/tree
    $categorys =  children::with('allChildren')->first();
    $arr = [];
        array_walk_recursive($categories,function ($v, $k) use(&$arr) {
            if($k == 'id')
                $arr[] = $v;
        });   
        https://segmentfault.com/a/1190000010359094
        Laravel 的无限级分类插件 https://github.com/lazychaser/laravel-nestedset
```
### 限制请求频率中间件
```javascript
use Closure;
use Illuminate\Support\Facades\Cache;
use App\Libs\Xres;

class ThrottleRequests {

    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        $unique = $request->getClientIp() . $request->getRequestUri();
        if (Cache::has('ip_list')) {
            $ip_list = Cache::get('ip_list');
        } else {
            $ip_list = array();
        }
        $index = array_search($unique, array_column($ip_list, 'ip'));
        if (false === $index) {
            array_push($ip_list, ['ip' => $unique, 'time' => $this->time()]);
            Cache::put('ip_list', $ip_list, 1440);
        } else {
            $gap = $this->time() - $ip_list[$index]['time'];
            $ip_list[$index]['time'] = $this->time();
            Cache::put('ip_list', $ip_list, 1);
            if ($gap < 1000) {
                return Xres::error("请求频率过快", 200);
            }
        }
        return $next($request);
    }

    private function time(){
        return (int)(microtime(true)*1000);
    }
}
https://learnku.com/articles/35823
```
### Laravel MongoDB 数据库查询
```javascript
composer require jenssegers/mongodb
$capsule->getDatabaseManager()->extend('mongodb', function($config)
{
    return new Jenssegers\Mongodb\Connection($config);
});



```
### 树状数据结构存储方式
```javascript
CREATE TABLE `categories` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` char(100) NOT NULL,
  `pid` int(11) DEFAULT 0,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

CREATE TABLE `categories` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` char(100) NOT NULL,
  `lft` int(11) NOT NULL CHECK (lft> 0),
  `rgt` int(11) NOT NULL CHECK (rgt> 1),
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

lft 和 rgt 是作为集合的边界，两者差值越大，则集合越大，里面的元素就越多。
根据子集，查找父级的分类

SELECT c2.* 
  FROM categories as c1, categories as c2
  WHERE c1.lft BETWEEN c2.lft and c2.rgt 
      AND c1.title = '华为';

+----+-------------+-----+-----+
| id | title       | lft | rgt |
+----+-------------+-----+-----+
|  1 | Smartphones |   1 |  14 |
|  5 | Harmony OS  |  10 |  13 |
|  8 | 华为        |  11 |  12 |
+----+-------------+-----+-----+
根据父级，查找其底下所有的子集

SELECT c1.*
   FROM categories AS c1, categories AS c2
  WHERE c1.lft BETWEEN c2.lft AND c2.rgt
    AND c2.title = 'Smartphones';

+----+-------------+-----+-----+
| id | title       | lft | rgt |
+----+-------------+-----+-----+
|  1 | Smartphones |   1 |  14 |
|  3 | Android     |   2 |   5 |
|  4 | iOS         |   6 |   9 |
|  5 | Harmony OS  |  10 |  13 |
|  6 | 小米        |   3 |   4 |
|  7 | iPhone      |   7 |   8 |
|  8 | 华为        |  11 |  12 |
+----+-------------+-----+-----+
查看各个分类的级别

 SELECT COUNT(c2.id) AS indentation, c1.title
  FROM categories AS c1, categories AS c2
  WHERE c1.lft BETWEEN c2.lft AND c2.rgt
  GROUP BY c1.title
  ORDER BY c1.lft;

+-------------+-------------+
| indentation | title       |
+-------------+-------------+
|           1 | Smartphones |
|           2 | Android     |
|           3 | 小米        |
|           2 | iOS         |
|           3 | iPhone      |
|           2 | Harmony OS  |
|           3 | 华为        |
+-------------+-------------+
https://learnku.com/articles/33630
```
### 冬令时
```javascript
function getSeason($timezone){
    $localzone = date("e");
    date_default_timezone_set($timezone);
    $season = date("I");
    date_default_timezone_set($localzone);
    return $season;
}
function is_dst($timestamp,$timezone)
{
    $timezone = date('e'); //获取当前使用的时区
    date_default_timezone_set($timezone); //强制设置时区
    $dst = date('I',$timestamp); //判断是否夏令时
    date_default_timezone_set($timezone); //还原时区
    return $dst; //返回结果
}
print_r(is_dst(1570143661,'Europe/London'));
print_r(is_dst(time(),'America/New_York'));
print_r(getSeason('America/Chicago'));
https://3v4l.org/iWVMb

```
### 展开表达式
```javascript
<?php
function add($a, $b, $c) {
    return $a + $b + $c;
}

$operators = [2, 3];
echo add(1, ...$operators);
?>
https://www.php.net/manual/zh/migration56.new-features.php
```
### helper函数
```javascript
public function register()
{
    foreach (glob(app_path('Helpers') . '/*.php') as $file) {
        require_once $file;
    }
     $this->directoryToArray(app_path('Helpers'));
}
private function directoryToArray($directory, $recursive = false) {
  $array_items = array();
  if(!is_dir($directory)) return "$directory folder does not exist";
      if ($handle = opendir($directory)) {
          while (false !== ($file = readdir($handle))) {
              if ($file != "." && $file != "..") {
                  if (is_dir($directory. "/" . $file)) {
                      if($recursive) {
                          self::directoryToArray($directory. "/" . $file, $recursive);
                      }
                      if($this->validateExt($file)){
                          $file = $directory . "/" . $file;
                          require_once $file;
                      }
              } else {
                     if($this->validateExt($file)){
                          $file = $directory . "/" . $file;
                          require_once $file;
                      }
              }
         }
     }
     closedir($handle);
  }
}
private function validateExt($file){
  $file_path = pathinfo($file);
  if($file_path ['extension'] == 'php'){
      return true;
  }
      return false;
}
config/app.php
App\Providers\HelperServiceProvider::class,
App\Providers\AppServiceProvider::class,

function carbon($time = null, $tz = null)
{
    return new \Carbon\Carbon($time, $tz);
}

```
### 魔术方法__call
```javascript
class Family{
            protected $childName = [];
            public function fatherName(){
                return 'Dale';
            }
            public function motherName(){
                return 'Kelly';                
            }
            public function __call($name,$param){
                if($name == 'setChildName'){
                        $childNmae = [$param];
                        return $this 
                    }
            }

     }
     $family = new Family();
     $setChildName = $family->setChildName('Kobe');
在使用服务容器时，我们的目标是以下面形式调用我的方法。

$myContainer = app('myContainer');
$myContainer->myClass()->myFunction();
当然我可以用构造函数的方法来解决，但是当依赖了很多类的时候，构造函数是毁灭性的。调用一个方法会实例化N个类，十分不可取。所以我改造myClass如下。

class myClass{
    public function __call($name, $arguments)
    {
        $className = 'App\Container\\'.$name;
        if (class_exists($className)){
            $class = new \ReflectionClass($className);
            return $class->newInstanceArgs($arguments);
        }    
    }
}
这样会在调用的时候，只会实例化一个类，而且代码简洁明了https://dalebao.github.io/2019/04/27/Laravel-and-magic/
```
### 获取每年所有周
```javascript
function get_week($year)
{
    $year_start = $year . "-01-01";
    $year_end = $year . "-12-31";
    $startday = strtotime($year_start);
    if (intval(date('N', $startday)) != '1') {
        $startday = strtotime("next monday", strtotime($year_start)); //获取年第一周的日期
    }
    $year_mondy = date("Y-m-d", $startday); //获取年第一周的日期

    $endday = strtotime($year_end);
    if (intval(date('W', $endday)) == '7') {
        $endday = strtotime("last sunday", strtotime($year_end));
    }

    //如果是当前年则统计到当前周
    $now_year = date('Y');
    if ($now_year == $year) {
        $num = date('W', strtotime(date('Y-m-d')));
    }  else {
        $num = intval(date('W', $endday));
        if ($num == '1'){
            $num = intval(date('W',$endday -(7*24*3600)))+1;
        }
    }

    for ($i = 1; $i <= $num; $i++) {
        $j = $i -1;
        $start_date = date("Y-m-d", strtotime("$year_mondy $j week "));
        $end_day = date("Y-m-d", strtotime("$start_date +6 day"));
        if (!(date("Y",strtotime("$year_mondy $j week ")) > $year)){
            $week_array[$i] = array(
                substr(str_replace("-", ".", $start_date), 5),
                substr(str_replace("-", ".", $end_day), 5));
        }
    }
    return $week_array;
}https://dalebao.github.io/2019/04/27/%E8%8E%B7%E5%8F%96%E6%AF%8F%E5%B9%B4%E6%89%80%E6%9C%89%E5%91%A8/

```
### php yield
```javascript
 public function parseStr(...$param){
        $str = '';
        foreach ($param as $key => $value) {
            //处理数组
            if (is_array($value)) {
                $value = md5(json_encode($value));
            }
            $str .= $value;
        }

        return $str;
    }

    public function handle()
    {
        // 单独输出到updateChapter.log文件
        \Log::useFiles(storage_path().'/logs/data.log');
        $iTime = time();
        \Log::info('start', ['timestamp' => $iTime]);
        $i = 0;
        $ret =  $this->traverse();
        foreach ($ret as $v) {
            foreach ($v as $value) {
                $key = $this->parseStr('wx:', $value->wx_id);
                $count = (int) Redis::pfcount($key);
                // redis里的uv更大时更新，并记录更新前后数据
                if ($count > $value->uv) {
                    \Log::info('update id:'.$value->id, [$value->uv => $count]);
                    $i++;
                    (new StatisticModel(['hash_id' => $value->wx_id]))->where('id', $value->id)->update(['uv' => $count, 'update_time' => $iTime]);
                }
            }
        }
        // 记录更新时间与数量
        \Log::info('end', ['timestamp'=>time(), 'count' => $i,'interval' => time() - $iTime]);
        return true;
    }

    private function traverse()
    {
        $page = 3000;
        for ($i = 1; $i < 6; $i++) {
            $count = DB::table('wx_statistics_'.$i)->count();
            if ($count < 1) {
                // 记录进度
                \Log::info('update schedule', ['table success' => $i]);
                continue;
            }
            $num = ceil($count/$page);
            for ($j = 0; $j < $num; $j++) {
                $ret = DB::table('wx_statistics_'.$i)
                    ->select(['id', 'wx_id', 'uv'])
                    ->orderBy('id', 'asc')
                    ->skip($j*$page)
                    ->take($page)
                    ->get()
                    ->toArray();

                if (empty($ret)) {
                    continue;
                }
                yield $ret;
            }

            \Log::info('update schedule', ['table success' => $i]);
        }
        return true;
    }
http://blog.13sai.com/essay/199
```
### PHP 规范 - Symfony 代码规范
```javascript
使用 php-cs-fixer 工具来自动检查编码规范

$ cd your-project/
$ php php-cs-fixer.phar fix -v
https://learnku.com/articles/36079

```

### Laravel 限制条数后再分页
```javascript
$per_page = 15; // 每页条数
$limit_page = 30; // 限制总页数
$data = Article::orderBy('id', 'desc')->limit($per_page * $limit_page)->paginate($per_page);
此种写法并不能生效，因为 paginate 方法中内置的 limit 会替换掉我们的 limit
取出要展示的条数的最小 id

在总记录中设置 id 大于上一条件得到的最小 id

即，用 where 替换 limit 限制总条数

$last_id = Article::orderBy('id', 'desc')
    ->limit($per_page * $limit_page)
    ->pluck('id')
    ->sort()
    ->first();
$data = Article::orderBy('id', 'desc')
    ->where('id', '>', $last_id)
    ->paginate($per_page);
https://learnku.com/articles/36260
```
### php.ini 配置
```javascript

文件上传
file_uploads = On
max_file_uploads = 20
upload_max_filesize = 2M
max_execution_time = 30 值 为 0 代表没有限制


```

### PHP Traits
```javascript
“ Trait 是单继承语言（如 PHP ）中的一种代码复用机制。 Trai 的目的是减少单继承语言的一些限制，能让开发者自由的重用在不同的类层次结构下几个独立类中的方法。 Trait 的语义组合与类的定义在某种程度上减少了代码的复杂度，避免了与多继承和 Mixins 相关的一些典型问题。

Trait 与类非常相似，但它的目的仅仅是用更好、一致的方式汇聚一些方法。 Trait 本身不能被实例化。除了传统继承之外，它能水平组合行为，换言之，类的应用程序不需要继承。”
namespace App\Http\Traits;

use App\Brand;
trait BrandsTrait {
    public function brandsAll() {
        // 从品牌表中获取所有品牌.
        $brands = Brand::all();

        return $brands;
    }
}
use App\Http\Traits\BrandsTrait;

class YourController extends Controller {
        use BrandsTrait;

        public function addProduct() {
            $brands = $this->brandsAll();
        }
}
https://learnku.com/laravel/t/36211


```

### 正则表达式
```javascript
/*
给定一组手机号，必须由[0123456789]组成的，才选出来从哪找?从字符串的开始找，找到字符串的结束 ^ $ 
找谁[01235689]
找几个?11个
*/
$arr = array('13800138000'，'13487656887'，'434456'，'45454353434543');
//$patt = '/^[^47]{11}$/'; //补集方法
$patt = '/^[01235689]{11}$/';//集合方式
foreach($arr as $v){
    preg_match_all($patt，$v，$res);
    print_r($res);
}
 $str = 'tommorw is another day，o2o ，you dont bird me i dont bird you';

>>> preg_split('#\W+#',$str)
=> [
     "tommorw",
     "is",
     "another",
     "day",
     "o2o",
     "you",
     "dont",
     "bird",
     "me",
     "i",
     "dont",
     "bird",
     "you",
   ]
//查询纯数字或者纯字母的词
$str = 'hello o2o 2b9 250';
$patt = '/\b[a-zA-Z]+\b|\b[0-9]+\b/';//最少一个
preg_match_all($patt，$str，$res);
print_r($res);

//查询苹果系统的产品
$str = 'ipad，iphone，imac，ipod，iamsorry';
$patt = '/\bi(pad|phone|mac|pod)\b/';
preg_match_all($patt，$str，$res);
print_r($res);
把手机号中间的 4 位替换为 *

$str = '13800138000 , 13426060134 ';
//前3位和后4位放子表达式中，中间4位随便，保留子表达式.替换中间的4位
$patt = '/(\d{3})\d{4}(\d{4})/';
//preg_match_all($patt,$str, $res);
//print_r($res);
echo preg_replace($patt， '\1****\2'， $str);//138****8000 , 134****0134
$str = 'bob李';
$patt = '/^[\x{4e00}-\x{9fa5}]+$/u';
echo preg_match($patt，$str)?'国货':'杂货';https://learnku.com/articles/36227
```
### curl 下载文件
```javascript
function curl_download_file($url,$path)
{
    $ch=curl_init();
    curl_setopt($ch,CURLOPT_POST,0);
    curl_setopt($ch,CURLOPT_URL,$url);
    curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);
    $content=curl_exec($ch);
//    file_put_contents($path, $content);
//    $file=fopen($path,'w');
//    fwrite($file,$content);
//    fclose($file);
    header('Expires: 0'); // no cache
    header('Cache-Control: must-revalidate, post-check=0, pre-check=0');
    header('Last-Modified: ' . gmdate('D, d M Y H:i:s', time()) . ' GMT');
    header('Cache-Control: private', false);
    header('Content-Type: application/force-download');
    header('Content-Disposition: attachment; filename="' . basename($url) . '"');
    header('Content-Transfer-Encoding: binary');
    header('Content-Length: ' . strlen($content)); // provide file size
    header('Connection: close');
    echo $content;
}
curl_download_file('https://www1.hkexnews.hk/listedco/listconews/sehk/2019/1108/2019110800352_c.xlsx','test.xlsx');

```
### 更新数据后返回原来数据 
```javascript
 $article = Finance::where('state', 0)
                            ->orderBy('id', 'asc')->select('id', 'state', 'author')
                            ->first();

        $old_article = $article->toArray();

        if($article){
            $article->state = 1;
            $article->author = 'elesos'';
            $article->save();
        }

        return $old_article;
当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。可以用克隆给一个已创建的对象建立一个新实例。 
 $old_article = $article = Finance::where('state', 0)
                            ->orderBy('id', 'asc')
                            ->first();
old_article 和 article 都是指向同一块内存（或者说同一个对象实例。从 C 语言的角度理解，可以类比为他们都是保存指向同一个对象的 内存地址，即指针），那么对于 article 的修改自然也会反应到 old_article 上
$article = Finance::where('state', 0)
                            ->orderBy('id', 'asc')
                            ->first();
// 关键：复制 article 实例到 old_article。
// 若支持，此时 old_article 指向的实例与 article 不一致
$old_article = clone $article;

$article->state = 1;
$article->save();
// 如果证实可以，此处 old_article state 应为 0
echo $old_article->state;
https://learnku.com/laravel/t/36338


```
### 生成器
```javascript
最普通的方式就是一次性读取文件内容，然后再进行遍历。

<?php

function getLinesFromFile($fileName) {

    // 打开文件
    if (!$fileHandle = fopen($fileName, 'r')) {
        return;
    }

    // 一次读取每一行并保存
    $lines = [];
    while (false !== $line = fgets($fileHandle)) {
        $lines[] = $line;
    }

    fclose($fileHandle);

    return $lines;
}

$lines = getLinesFromFile('test.txt');
foreach ($lines as $line) {

}
当使用该函数读取大文件时，就会因为内存不足而报错。

PHP Fatal error:  Allowed memory size of 134217728 bytes exhausted
function getLinesFromFile($fileName) {
    if (!$fileHandle = fopen($fileName, 'r')) {
        return;
    }

    while (false !== $line = fgets($fileHandle)) {
        yield $line;
    }

    fclose($fileHandle);
}

$lines = getLinesFromFile('test.txt');
foreach ($lines as $line) {

}

yield;
yield $value;
yield $key => $value;
生成器看上去是函数，实际上是 Generator 类的实例。

function simpleGenerator()
{   
    yield;
}

echo get_class(simpleGenerator())  // Generator
既然是对象，就可以将其赋值给变量。

$gen = simpleGenerator();
Generator 对象已经实现了 Iterator 接口

$gen instanceof Iterator // true
function echoLogger() {
    while (true) {
        // 接受外部的传值
        $log = yield;
        echo 'Log: ' . $log . "\n";
    }
}

$logger = echoLogger();
$logger->send('Foo');  // Log: foo
$logger->send('Bar');  // Log: bar
https://learnku.com/articles/36331
```
### 多维数组变一维
```javascript
 public static function flatten($array, $depth = INF)
    {
        $result = [];
        foreach ($array as $item) {
            $item = $item instanceof Collection ? $item->all() : $item;
            if (! is_array($item)) {
                $result[] = $item;
            } elseif ($depth === 1) {
                $result = array_merge($result, array_values($item));
            } else {
                $result = array_merge($result, static::flatten($item, $depth - 1));
            }
        }
        return $result;
    }
https://learnku.com/articles/36348
```
### phpexcel遇到内存溢出
```javascript
class ExportService
{

    public static $outPutFile = '';

    /**
     * 导出文件
     * @param string $fileName
     * @param $data
     * @param array $formFields
     * @return mixed
     */
    public static function exportData($fileName = '', $data, $formFields = [])
    {
        $fileArr = [];
        $tmpPath = \Yii::$app->params['excelSavePath'];

        foreach (array_chunk($data, 10000) as $key => $value) {
            self::$outPutFile = '';
            $subject          = !empty($fileName) ? $fileName : 'data_';
            $subject          .= date('YmdHis');
            if (empty($value) || empty($formFields)) {
                continue;
            }

            self::$outPutFile = $tmpPath . $subject . $key . '.csv';
            if (!file_exists(self::$outPutFile)) {
                touch(self::$outPutFile);
            }
            $index  = array_keys($formFields);
            $header = array_values($formFields);
            self::outPut($header);

            foreach ($value as $k => $v) {
                $tmpData = [];
                foreach ($index as $item) {
                    $tmpData[] = isset($v[$item]) ? $v[$item] : '';
                }
                self::outPut($tmpData);
            }
            $fileArr[] = self::$outPutFile;
        }
        
        $zipFile = $tmpPath . $fileName . date('YmdHi') . '.zip';
        $zipRes = self::zipFile($fileArr, $zipFile);
        return $zipRes;
    }

    /**
     * 向文件写入数据
     * @param array $data
     */
    public static function outPut($data = [])
    {
        if (is_array($data) && !empty($data)) {
            $data = implode(',', $data);
            file_put_contents(self::$outPutFile, iconv("UTF-8", "GB2312//IGNORE", $data) . PHP_EOL, FILE_APPEND);
        }
    }

    /**
     * 压缩文件
     * @param $sourceFile
     * @param $distFile
     * @return mixed
     */
    public static function zipFile($sourceFile, $distFile)
    {
        $zip = new \ZipArchive();
        if ($zip->open($distFile, \ZipArchive::CREATE) !== true) {
            return $sourceFile;
        }

        $zip->open($distFile, \ZipArchive::CREATE);
        foreach ($sourceFile as $file) {
            $fileContent = file_get_contents($file);
            $file        = iconv('utf-8', 'GBK', basename($file));
            $zip->addFromString($file, $fileContent);
        }
        $zip->close();
        return $distFile;
    }
    
        /**
     * 下载文件
     * @param $filePath
     * @param $fileName
     */
    public static function download($filePath, $fileName)
    {
        if (!file_exists($filePath . $fileName)) {
            header('HTTP/1.1 404 NOT FOUND');
        } else {
            //以只读和二进制模式打开文件
            $file = fopen($filePath . $fileName, "rb");

            //告诉浏览器这是一个文件流格式的文件
            Header("Content-type: application/octet-stream");
            //请求范围的度量单位
            Header("Accept-Ranges: bytes");
            //Content-Length是指定包含于请求或响应中数据的字节长度
            Header("Accept-Length: " . filesize($filePath . $fileName));
            //用来告诉浏览器，文件是可以当做附件被下载，下载后的文件名称为$file_name该变量的值
            Header("Content-Disposition: attachment; filename=" . $fileName);

            //读取文件内容并直接输出到浏览器
            echo fread($file, filesize($filePath . $fileName));
            fclose($file);
            exit();
        }
    }
}		$fileName = "库存导入模板";
        $stockRes = []; // 导出的数据
        $formFields = [
            'store_id'  => '门店ID',
            'storeName' => '门店名称',
            'sku'       => 'SKU编码',
            'name'      => 'SKU名称',
            'stock'     => '库存',
            'reason'    => '原因'
        ];
        $fileRes    = ExportService::exportData($fileName, $stockRes, $formFields);
        $tmpPath    = \Yii::$app->params['excelSavePath']; // 文件路径
        $fileName   = str_replace($tmpPath, '', $fileRes);
        
        // 下载文件
        ExportService::download($tmpPath, $fileName);
        https://tsmliyun.github.io/php/%E5%85%B3%E4%BA%8EPHP%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83/

```
### 基于雪花算法的 PHP ID 生成器
```javascript
第一个 bit 为未使用的符号位。
第二部分由 41 位的时间戳（毫秒）构成，他的取值是当前时间相对于某一时间的偏移量。
第三部分和第四部分的 5 个 bit 位表示数据中心和机器 ID，其能表示的最大值为 2^5 -1 = 31；
最后部分由 12 个 bit 组成，其表示每个工作节点每毫秒生成的序列号 ID，同一毫秒内最多可生成 2^12 -1 即 4095 个 ID。
composer require godruoyi/php-snowflake
$snowflake = new \Godruoyi\Snowflake\Snowflake;

$snowflake->id();
// 1537200202186752
$snowflake = new \Godruoyi\Snowflake\Snowflake;
$snowflake->setStartTimeStamp(strtotime('2019-09-09')*1000);

$snowflake->id();
use Godruoyi\Snowflake\Snowflake;
use Godruoyi\Snowflake\LaravelSequenceResolver;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this->app->singleton('snowflake', function () {
            return (new Snowflake())
                ->setStartTimeStamp(strtotime('2019-08-08')*1000)
                ->setSequenceResolver(new LaravelSequenceResolver(
                    $this->app->get('cache')->store()
                ));
        });
    }
}
64 位的二进制最大能生成 19 位的 ID，所以在设计数据库长度的时候最好预留下长度
  public function getCurrentMicrotime()
      {
          return floor(microtime(true) * 1000) | 0;//浮点数转数字 
      }
 bindec('0111111111111111111111111111111111111111111111111111111111111111')
=> 9223372036854775807
>>> strlen(9223372036854775807)
=> 19
https://learnku.com/articles/32575
```
### Nginx 与 PHP 的通信
```javascript
 Nginx 并不是直接和 PHP 进行通信的，而是通过 PHP-FPM。Nginx 不仅仅是一个强大的 Web 服务器，也是一个强大的代理服务器，提供了很多请求协议的代理。比如 Http 协议还有 FastCgi 协议等。

当请求进入到 Nginx 中，Nginx 提供了一个 FastCgi 模块 来把 Http 请求映射为对应的 Fastcgi 请求。该模块提供了 fastcgi_param 指定来完成映射关系。它的主要作用就是把 Nginx 中的变量翻译成 PHP 中能够理解的变量

fastcgi_pass, 用来指定 FPM 进程监听的地址，Nginx 会把所有的 PHP 请求映射成 fastcgi 请求，然后发送到这个地址上。

所有的 .php 结尾的请求都交给 fastcgi 模块处理，然后把处理后的请求发送给 PHP-FPM，然后 PHP-FPM 把请求交给 worker 进程，worker 进程加载 PHP 解析器运行 PHP 处理结果。 其中 fastcgi_pass unix:/var/run/php/php7.1-fpm.sock; 这一行用来指定 fpm 的地址。
Nginx 和 PHP 的通信流程大概如下:

客户端发送请求到 Nginx
加载 nginx.conf 文件，把所有 .php 结尾的请求特殊处理
加载 FastCGI 模块，完成请求参数的解析映射，生成 FastCGI 请求
然后通过 fastcgi_pass 参数把 FastCGI 请求发送给 PHP-FPM 处理
PHP-FPM 收到请求，分配给空闲 worker 子进程
worker 子进程加载 PHP 解析器等 完成 PHP 执行获取结果
PHP-FPM 是一种 master/worker 进程架构。首先会启动一个 master 主进程，主要功能用来完成 PHP 环境的初始化，事件监听，子进程状态管理等等。然后会启动若干 worker 子进程来处理 PHP 请求。

master 进程的工作流程

1. 初始化 CGI，注册进程信号初始化全局变量。
2. 完成 PHP 环境初始化。加载 php.ini 解析配置文件，加载 PHP 模块记录函数符号表，加载 zend 扩展，设置禁用函数和类库设置，注册回收内存方法。
3. 完成 PHP-FPM 初始化。加载并解析 php-fpm.conf 文件，获取进程相关参数，初始化进程池以及事件模型等。
4. 处理子进程相关操作。fork 子进程，进行事件监听等。

worker 进程工作流程

1. 接收请求。这里是不需要初始化 PHP 运行环境的。
2. 处理请求。获取请求内容注册全局变量 ($_GET,$_POST,$_SERVER 等)，然后根据请求信息访问对应的 PHP 文件，然后将 PHP 脚本文件交给 Zend 引擎处理。
3. 处理结果。在 Zend 引擎处理完毕后将会进行回调，发送响应内容，释放内存等

测试 php-fpm 配置内容是否正确 使用 -t 参数， 还可以通过加 -c 指定 php.ini 文件，通过 -y 指定 php-fpm.conf 文件 

/usr/sbin/php-fpm7 -t
/usr/sbin/php-fpm7 -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf -t

使用 root 权限启动子进程 通过增加 -R 参数

/usr/sbin/php-fpm7 -c xxx/xxx/xxx/php.ini -y /xxx/xxx/xxx/php-fpm.conf -R

重新创建容器 并添加 --cap-add=SYS_PTRACE 给容器追加 Ptrace 功能

docker run --name website_name -p 11280:80 --cap-add=SYS_PTRACE -v /data/website/website_name:/app -d showtime/php-javabridge:v1  https://learnku.com/articles/28683
```

### Elasticsearch/Algolia 全文搜索 
```javascript
https://www.elastic.co/cn/downloads/elasticsearch
新版的 ES 是内置的 java 环境
windows 直接启动 elasticsearch.bat 

https://learnku.com/articles/30812#reply117421


```
### PHP 系统调用time()
```javascript
$year = date('Y', time());
$month = date('m', time());
系统调用就是操作系统提供给用户程序访问计算机资源的接口，更要命的是，系统调用极其耗时
class TimeWrapper
{
    private static $now_time = 0;

    /**
     * @param bool $force_refresh 是否强制刷新
     * @return int
     */
    public static function getTime($force_refresh = false)
    {
        if ($force_refresh) {
            self::$now_time = time();
        } else {
            if (!self::$now_time) {
                self::$now_time = time();
            }
        }
        return self::$now_time;
    }
}
https://learnku.com/articles/36538
```
### curl 下载进度
```javascript
class Downloader
{

	static $lastDownloaded = 0;
	static $lastTime = null;

	public static function download($url, $fileName, $date)
	{
		ini_set('memory_limit', Config::$memory_limit);	//调整最大占用内存
		$code = ['"', '*', ':', '<', '>', '？', '/', '\\', '|'];
		$fileName = preg_replace('# #','',$fileName);
		$fileName = str_replace($code, '', $fileName);
		if (!is_dir(Config::$path)) {
			mkdir(Config::$path);
		}

		$filePath = Config::$path.'/'.date('Ymd',strtotime($date)).'_'.$fileName.'.mp4';
		if (file_exists($filePath)){
			echo "\033[0;32m"."文件已存在"."\033[0m\n";
			return;
		}

		$header = array();
		$header[] = "User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36Name'";
		$header[] = "Referer:http://91porn.com";

		$ch = curl_init();
		// 从配置文件中获取根路径
		curl_setopt($ch, CURLOPT_URL, $url);
		curl_setopt($ch, CURLOPT_TIMEOUT,300);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_HTTPHEADER, $header);
		if (property_exists('Config', 'proxy')) {
			curl_setopt($ch, CURLOPT_PROXY, Config::$proxy);
		}
		// 开启进度条
		curl_setopt($ch, CURLOPT_NOPROGRESS, false);
		// 进度条的触发函数
		curl_setopt($ch, CURLOPT_PROGRESSFUNCTION, array(new self, 'progress'));
		// ps: 如果目标网页跳转，也跟着跳转
		curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);

		$data = curl_exec($ch);
		curl_close($ch);
		
		if ($data) {
			$file = fopen($filePath,"w+");
			fputs($file,$data);//写入文件
			fclose($file);
		}

		// 使用rclone上传onedrive，其中“91porn:/91porn”对应网盘名称和路径
		// $command = 'rclone move -P '.$filePath.' 91porn:/91porn';
		// system($command);

		unset($data);
	}

	/**
	* 进度条下载.https://github.com/zzjzz9266a/91porn_php
	*
	* @param $ch
	* @param $downloadSize 总下载量
	* @param $downloaded 当前下载量
	* @param $uploadSize 
	* @param $uploaded
	*/
	function progress($resource, $downloadSize = 0, $downloaded = 0, $uploadSize = 0, $uploaded = 0){
		if ($downloadSize === 0) {
			return;
		}

		if ($downloaded == $downloadSize) {
			printf("下载完成: %.1f%%, %.2f MB/%.2f MB\n", $downloaded/$downloadSize*100, $downloaded/1000000, $downloadSize/1000000);
			Downloader::$lastDownloaded = 0;
			Downloader::$lastTime = 0;
			return;
		}

		if (microtime(true)-Downloader::$lastTime <= 1) {
			return;
		}

		$speed = ($downloaded-Downloader::$lastDownloaded)/(microtime(true)-Downloader::$lastTime)/1000;

		Downloader::$lastDownloaded = $downloaded;
		Downloader::$lastTime = microtime(true);

		$downloaded = $downloaded/1000000;
		$downloadSize = $downloadSize/1000000;
		
		if ($speed < 1000) {
			$speedStr = ", 下载速度：%.2f kb/s     ";
		}else{
			$speedStr = ", 下载速度：%.2f mb/s     ";
			$speed = $speed/1000;
		}
		$progress = $downloaded/$downloadSize*100;
		printf("下载进度: %.1f%%, %.2f MB/%.2f MB".$speedStr."\r", $progress, $downloaded, $downloadSize, $speed);
	}
}

function random_ip()
{
	$a = rand(0, 255);
	$b = rand(0, 255);
	$c = rand(0, 255);
	$d = rand(0, 255);
	return $a.'.'.$b.'.'.$c.'.'.$d;
}


```
### 队列执行频率限制
```javascript
每分钟限制执行 10 次 JOB（注意是 JOB，而不是整个队列）

use Illuminate\Support\Facades\Redis;
Redis::throttle('key')->allow(10)->every(60)->then(function () {
    // 任务逻辑...
}, function () {
    // 无法获得锁...

    return $this->release(10);
});
并发，限制同一时间只执行一个 JOB

Redis::funnel('key')->limit(1)->then(function () {
    // 任务逻辑...
}, function () {
    // 无法获得锁...

    return $this->release(10);
});方法里的参数 key 是自定义的 redis key，如果需要多个 job 共用一个限制，则可以使用同一个 key
   
https://learnku.com/articles/30054
```
### 上传文件和下载
```javascript
 /*
        文件上传函数
        @param  string  $name  文件上传文件域的name值
        @param  string  $dir   文件保存路径
        @param  array   $allow 文件允许上传的类型
        return  string  $filename 文件名  如果失败 返回false
     */

    function upload($name,$dir='./upload/',$allow=array('jpg','gif','jpeg','png')){
        //echo $name;exit;
        //var_dump($_FILES);exit;
        //1.判断文件上传错误
        if($_FILES[$name]['error']>0){
            //echo '上传错误';
            switch($_FILES[$name]['error']){
                case 1:
                    echo '上传的文件超过了 php.ini 中upload_max_filesize 选项限制的值.';
                    break;
                case 2:
                    echo '上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值';
                    break;
                case 3:
                    echo '文件只有部分被上传.';
                    break;
                case 4:
                    echo '没有文件被上传.';
                    break;
                case 6:
                    echo '找不到临时文件夹.';
                    break;
                case 7:
                    echo '文件写入失败.';
                    break;
            }
            return false;
        }

        //2.判断你文件上传的类型是否是你想要的类型
        //2.1允许上传的类型

        //2.2 获取后缀名
        $suffix = pathinfo($_FILES[$name]['name'],PATHINFO_EXTENSION);
        //echo $suffix;exit;
        //2.3 判断是否是我们允许上传的类型
        //var_dump(in_array($suffix,$allow));exit;
        if(!in_array($suffix,$allow)){
            //不允许上传的类型
            echo  '大哥你的上传类型不符合';
            return false;
        }
        //3.起名字
        $filename = date('Ymd').uniqid().mt_rand(0,9999).'.'.$suffix;
        //echo $filename;exit;

        //4.判断保存路径是否存在
        //4.1 得到保存路径

        //4.2 处理保存路径和后面的斜杠
        $save_path = rtrim($dir,'/');
        $save_path .='/';

        //4.3 保存路径中的时间文件夹处理
        $save_path .=date('Y/m/d/');

        //4.4 判断保存的路径是否存在
        if(!file_exists($save_path)){
            mkdir($save_path,777,true);
        }

        //4.5 拼接一个完整的保存路径
        $path = $save_path.$filename;
        //echo $path;exit;

        //5.判断是否是httppost方式上传
        if(!is_uploaded_file($_FILES[$name]['tmp_name'])){
            echo '滚蛋！';
            return false;
        }

        //6.移动图片
        if(!move_uploaded_file($_FILES[$name]['tmp_name'],$path)){
            echo '移动失败';
            return false;
        }

        //7.返回移动成功的图片名
        return $filename;

    }
    下载文件
     <!-- 浏览器认识这样的类型,就会被解析 -->
        <a href="./action.php?name=1.html">1.html</a>
        <a href="./action.php?name=1.php">1.php</a>
        <a href="./action.php?name=1.txt">1.txt</a>
        <a href="./action.php?name=1.jpg">1.jpg</a>
    //接收一下name值.
    $name = $_GET['name'];
    
    //实现下载功能
    //强制浏览器弹出另存为对话框
    header('content-Disposition:attachment;filename="'.$name.'"');
    
    //此时只是下载了一个空文件,需要利用readfile读一遍所有的内容.便可下载.
    $path = './downlist/'.$name;
    readfile($path);
https://learnku.com/articles/36744
```
### app 接口对接
```javascript
if (empty($arr)) {
   $arr = (object) null;//$arr = new stdClass;
}
echo json_encode($arr);
$arr = ["id"=>"1","name"=>null];
$data = [
 "id"=>(int) $arr["id"],
"name"=>(string) $arr["name"],
];
echo json_encode($data);
json_encode ($result ,JSON_FORCE_OBJECT)，返回格式为 {},

```
### 异常类
```javascript
function doSomething(){
    if(something error){
         throw new SomethingException('something error');
    }
    ...
    do something
}
//调用
try{
   doSomething();
}catch(SomethingException $e){
   echo "something goes error";
}
// 调用方无法从外部得知时哪里出了问题，因为只返回了 false
function checkoutOrder($orderNumber){
  $orderModel = OrderModel::query()->where('order_number',$orderNumber)->first();
  if(!$orderModel){
     return false;
  }
  $payResut = PayService::pay($orderModel);
  if(!$payResut){
      return false;
  }
}
function checkoutOrder($orderNumber){
  $orderModel = OrderModel::query()->where('order_number',$orderNumber)->first();
  if(!$orderModel){
     throw new OrderNotFoundException($orderNumber);
  }
  $payResut = PayService::pay($orderModel);
  if(!$payResut){
      throw new PaymentException(); // 这个异常应该上面的 PayService 中抛出，为了更清晰就写在这
  }
}

// 调用
try{
    checkoutOrder('ORDER00001');
}catch(OrderNotFoundException $e){
    return response('订单不存在：'.$e->getMessage(),404);
}catch(PaymentException $e){
    return response('支付失败：'.$e->getMessage(),500);
}
app/Exceptions/Handler.php 中根据异常名、紧急程度调用第三方通知工具（钉钉、邮件等）通知项目错误。

public function report(Exception $exception){
    if ($this->shouldntReport($exception)) {
        return;
    }
    // 如果异常类中存在 report 方法，就使用自身的
    if (method_exists($exception, 'report')) {
        return $exception->report();
    }

    $msg = "系统异常：" . $exception->getMessage();
    $msg .= "\n文件：" . $exception->getFile();
    $msg .= "\n行号：" . $exception->getLine();
    $msg .= "\n参数:" . json_encode(['form_params' => request()->all()]);

    DingService::sendWarning($msg);
    parent::report($exception);
}
在 render 方法根据异常名返回不同的客户端响应：

public function render($request, Exception $exception)
{
    if ($exception instanceof OrderException) {
        return $this->handleOrderException($exception, $request);
    }
    if ($exception instanceof PaymentException) {
        return $this->handlePaymentException($exception, $request);
    }
    return parent::render($request, $exception);
}
https://learnku.com/articles/36657
```

### where or 查询
```javascript
 SELECT * FROM user
  WHERE 
    group_id = 'group id'
   AND (
     name = 'name'
     OR mobile_number = 'mobile number'
     OR email = 'email'
     OR `score` > 1000
   ) 
  DB::table('users')
     ->where('group_id', 'group id')
     ->where(function ($query) {
         $query->where('name', 'name')
               ->orWhere('mobile_number', '=', 'mobile number')
               ->orWhere('email', '=', 'email')
               ->orWhere('score', '>', '1000');
     })
     ->get();
DB::table('users')
     ->where('group_id', 'group id')
     ->where(function ($query) {
        if ($params['name']) {
          $query->orWhere('name', $params['name'])
        }

        if ($params['mobile_number']) {
          $query->orWhere('mobile_number', $params['mobile_number'])
        }

        if ($params['email']) {
          $query->orWhere('email', $params['email'])
        }

        if ($params['score']) {
          $query->orWhere('score', '>', $params['score'])
        }

     })
     ->get();
  $orWhere = [];
  if ($params['name']) {
      $orWhere[] = ['name', '=', $params['name'], 'OR'];
  }
  if ($params['mobile_number']) {
      $orWhere[] = ['mobile_number', '=', $params['mobile_number'], 'OR'];
  }
  if ($params['email']) {
      $orWhere[] = ['email', '=', $params['email'], 'OR'];
  }
  if ($params['score']) {
      $orWhere[] = ['score', '>', $params['score'], 'OR'];
  }

  DB::table('users')
     ->where('group_id', 'group id')
     ->where($orWhere)
     ->get();
   $orWhere = [];
    if ($params['name']) {
        $orWhere['name'] = $params['name'];
    }
    if ($params['mobile_number']) {
       $orWhere['mobile_number'] = $params['mobile_number'];
    }
    if ($params['email']) {
        $orWhere['email'] = $params['email'];
    }
    if ($params['score']) {
        $orWhere[] = ['score', '>', 1000, 'OR'];
    }
  DB::table('users')
     ->where('group_id', 'group id')
     ->where(function ($query) use ($orWhere) {
        $query->orWhere($orWhere);
     })
     ->get();
  https://learnku.com/articles/36743
```
### 查询封装
```javascript
select * from posts where title='xxx' and content='xxxx';

use Illuminate\Http\Request;
use Illuminate\Database\Query\Builder;

abstract class QueryFilter
{

    protected $request;
    protected $builder;

    public function __construct(Request $request)
    {
        $this->request = $request;
    }

    public function apply(Builder $builder)
    {
        $this->builder = $builder;
        $this->init();

        foreach ($this->filters() as $name => $value) {
            if($value){
                if (method_exists($this, $name)) {
                    call_user_func_array([$this, $name],[$value]);
                }
            }

        }

        return $this->builder;
    }

    protected function init()
    {
        //子类可以做一些初始化的查询
    }
    public function filters()
    {
        return $this->request->all();
    }
}
namespace App\Services\Search\Db\Filter;

class PostFilter extends QueryFilter
{

    public function title($title)
    {
        return $this->builder->where('title', 'like', "%{$title}%");
    }

    public function content($content)
    {
        return $this->builder->where('content','like', "%{$content}%");
    }
}
use DB;

DB::table('posts')->where(function($query){
    app(\App\Services\Search\Db\Filter\PostFilter::class)->apply($query);

})->get();
https://learnku.com/articles/36716
```
### redis同步到数据库
```javascript
namespace App\Models\Traits;

use Redis;
use Carbon\Carbon;

trait ViewCountsHelper {
    // 缓存相关
    protected $hash_prefix = 'topic_view_counts_';
    protected $field_prefix = 'topic_';

    public function viewCountIncrement()
    {
        // 获取今日 Redis 哈希表名称，如：topic_view_counts_2017-10-21
        $hash = $this->getHashFromDateString(Carbon::now()->toDateString());

        // 字段名称，如：topic_1
        $field = $this->getHashField();

        // 当前阅读数，如果存在就自增，否则就为 1
        $count = Redis::hGet($hash, $field);
        if ($count) {
            $count++;
        } else {
            $count = 1;
        }

        // 数据写入 Redis ，字段已存在会被更新
        Redis::hSet($hash, $field, $count);
    }

    public function syncTopicViewCounts()
    {
        // 获取昨日的哈希表名称，如：topic_view_counts_2017-10-21
        $hash = $this->getHashFromDateString(Carbon::now()->toDateString());

        // 从 Redis 中获取所有哈希表里的数据
        $counts = Redis::hGetAll($hash);

        // 如果没有任何数据直接 return
        if (count($counts) === 0) {
            return;
        }

        // 遍历，并同步到数据库中
        foreach ($counts as $topic_id => $view_count) {
            // 会将 `topic_1` 转换为 1
            $topic_id = str_replace($this->field_prefix, '', $topic_id);

            // 只有当话题存在时才更新到数据库中
            if ($topic = $this->find($topic_id)) {
                $topic->view_count = $this->attribute['view_count'] + $view_count;
                $topic->save();
            }
        }

        // 以数据库为中心的存储，既已同步，即可删除
        Redis::del($hash);
    }

    public function getViewCountAttribute($value)
    {
        // 获取今日对应的哈希表名称
        $hash = $this->getHashFromDateString(Carbon::now()->toDateString());

        // 字段名称，如：topic_1
        $field = $this->getHashField();

        // 三元运算符，优先选择 Redis 的数据，否则使用数据库中
        $count = Redis::hGet($hash, $field) ? : $value;

        // 如果存在的话，返回 数据库中的阅读数 加上 Redis 中的阅读数
        if ($count) {
            return $this->attribute['view_count'] + $count;
        } else {
            // 否则返回 0
            return 0;
        }
    }

    public function getHashFromDateString($date)
    {
        // Redis 哈希表的命名，如：topic_view_counts_2017-10-21
        return $this->hash_prefix . $date;
    }

    public function getHashField()
    {
        // 字段名称，如：topic_1
        return $this->field_prefix . $this->id;
    }
}
在需要此功能的模型中 use Traits\ViewCountsHelper 即可


namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\Topic;

class SyncTopicViewCounts extends Command
{
    protected $signature = 'topic:sync-topic-view-counts';
    protected $description = '将话题 view_count 从 Redis 同步到数据库中';

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle(Topic $topic)
    {
        $topic->syncTopicViewCounts();
        $this->info("同步成功！");
    }
}

namespace App\Http\Controllers;

use App\Models\Topic;
use Illuminate\Http\Request;

class TopicsController extends Controller
{
    public function show(Topic $topic)
    {
        $topic->viewCountIncrement(); // 自增浏览数

        dd($topic->view_count); // 获取浏览数
    }
}
https://learnku.com/articles/32615
```
### where in
```javascript
$where['status'] = 1;
$ids = [1,2];
$where[] = [function($query) use ($ids){
    $query->whereIn('id', $ids);
}];
$list = User::where($where)
    ->get();
生成 sql 如下

select * from `users` where (`status` = 1 and (`id` in (1, 2)))
https://learnku.com/articles/36964
```
### 付费文章试读
```javascript
对 HTML 进行截断：

closetags(str_limit($article->body, 1000))
闭合标签：

function closetags($html) {
    libxml_use_internal_errors(true);

    $dom = new \DOMDocument;
    $dom->loadHTML('<meta http-equiv="content-type" content="text/html; charset=utf-8">' . $html);

    // Strip wrapping <html> and <body> tags
    $mock = new \DOMDocument;
    $body = $dom->getElementsByTagName('body')->item(0);
    foreach ($body->childNodes as $child) {
        $mock->appendChild($mock->importNode($child, true));
    }

    return trim($mock->saveHTML());
}https://learnku.com/laravel/t/36859

```


[php excel](https://github.com/viest/php-ext-excel-export)

[Laravel 性能优化入门](https://learnku.com/courses/laravel-performance/6.x)


[安装 laradock 以及运行 Laravel 项目](https://learnku.com/articles/36843)


[过滤敏感词汇扩展](https://github.com/FireLustre/php-dfa-sensitive)

[Windows 环境下安装 Laravel](https://learnku.com/articles/29049#871bbd)

[Laravel-layui-admin : 支持 Laravel6.0 的 RBAC 后台系统](https://github.com/moell-peng/laravel-layui-admin)

[Laravel-Binlog 扩展](https://github.com/telanflow/laravel-binlog)

[ Laravel 自带消息模块搭建小程序实时推送消息](https://learnku.com/articles/36574)

[基于支付宝 OpenAPI 开源的 PHP 语言版本 SDK](https://github.com/shulidata/easyalipay)

[gitbook 的 Laravel 源码详解](https://www.gitbook.com/book/leoyang90/laravel-source-analysis)

[Application 类 make 方法调用栈流程图](https://cdn.learnku.com/uploads/images/201911/15/39249/so44qFVX1y.png!/fw/1240)


[快速laravel后台管理系统](https://github.com/kong-qi/kongqi_laravel_admin)

[PHP 实现 Websocket 协议](https://gitee.com/obamajs/php-websocket-base-implemention)

[Laravel-S 项目之初体验](https://learnku.com/articles/35992)

[基于laravel5.5 + H-ui开发的一款基础后台管理系统](https://github.com/tsmliyun/laravel_quick_admin)


[快速laravel后台管理系统](https://github.com/kong-qi/kongqi_laravel_admin)

[Laravel-admin 码的电子商务前后端系统](https://github.com/imnotdoubi/laravel-admin.git)

[Laravel+vue 个人博客https://github.com/sweida/laravel-blog-api/](https://learnku.com/laravel/t/32401)

[详解 laravel 源码 https://leoyang90.gitbooks.io/laravel-source-analysis/content/](https://github.com/bobo1576554465/laravel-source-analysis)

[web开发者知识体系电子书](https://www.kancloud.cn/martist/ma_zhao_liu/370443)

[ EasyWechat 和 Laravel notification 发送微信小程序模板消息](https://learnku.com/articles/35672)

[QQ 登录、微信登录、微博登录、GitHub 登录](https://learnku.com/articles/35747)

[快速定位无用路由](https://learnku.com/articles/35644)

[Laravel 上将图片上传到阿里云 OSS](https://learnku.com/laravel/t/35638)

[快速记忆php系统数组函数](https://learnku.com/articles/35592)

[附近的店铺](https://learnku.com/laravel/t/35561)

[高性能的定时调度服务Forsun的Laravel组件](https://github.com/snower/forsun-laravel)

[Laravel 查询附近的数据](https://www.hongfs.cn/2019/06/php/laravel/laravel-query-nearby-data/)

[elasticsearch中文发行版](https://github.com/medcl/elasticsearch-rtf)

[多级联动](https://www.hongfs.cn/2018/12/php/laravel/laravel-multi-level-linkage/)

[Laravel 下 Elasticsearch/Algolia 全文搜索](https://learnku.com/articles/30812)

[Phpstorm 开启 Laravel 代码提示](https://learnku.com/articles/35377)

[PHP 最优秀资源的整理汇集](https://github.com/shockerli/php-awesome)

[腾讯地图搜索](https://learnku.com/articles/35348)

[Laravel 框架 5.1 升级到 5.5](https://learnku.com/articles/34959)

[Laravel Authorization：支持 ACL、RBAC、ABAC 等模型的授权库](https://learnku.com/articles/35101)

[PSR-12 编码规范扩充](https://learnku.com/laravel/t/35080)

[Laravel 下 Elasticsearch/Algolia 全文搜索 使用案例](https://learnku.com/articles/30812)

 [轻量级全文检索引擎 TNTSearch 和中文分词](https://learnku.com/articles/6207/lightweight-full-text-retrieval-engine-tntsearch-and-chinese-word-segmentation)

[laravel下TNTSearch+jieba-php实现中文全文搜索](https://baijunyao.com/article/154)

[postman使用记录](http://www.putyy.com/article/32)

[免费开源的在线文档管理插件](https://github.com/jianyan74/rageframe2)

[诗词博客](https://gitee.com/leiyong3/laravel_blog)

[Elasticsearch 国内镜像下载站](https://thans.cn/mirror/elasticsearch.html)

[PHP抖音机器人](https://github.com/ChinaBygones/PHP-DouyinRobot)