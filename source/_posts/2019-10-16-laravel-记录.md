---
title: laravel 记录
date: 2019-10-16 19:45:15
tags:
---
### Laravel 网站不会被嵌入到其他站点中
```javascript

HTTP 响应头部中，有一个字段，叫做 X-Frame-Options，该字段可以用来指示是否允许自己的网站被嵌入到其他网站的 <iframe> 或者 <object> 标签中。该头部有三个值

DENY - 始终不允许嵌入，即使是同一个域名
SAMEORIGIN - 只能在相同域名中嵌入
ALLOW-FROM uri - 设置允许的域
通常，可以在 HTTP 代理中进行配置，比如 nginx

add_header X-Frame-Options SAMEORIGIN;
Laravel 自带了用来「只允许同域名嵌入」的中间件，我们只需要在 /app/Http/Kernel.php 中添加即可

// /app/Http/Kernel.php
protected $middleware = [
    \Illuminate\Http\Middleware\FrameGuard::class,
];
该中间件的实现如下

<?php

namespace Illuminate\Http\Middleware;

use Closure;

class FrameGuard
{
    /**
     * Handle the given request and get the response.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Symfony\Component\HttpFoundation\Response
     */
    public function handle($request, Closure $next)
    {
        $response = $next($request);

        $response->headers->set('X-Frame-Options', 'SAMEORIGIN', false);

        return $response;
    }
}
https://learnku.com/articles/35201
https://securityheaders.com/

可以直接扫描特定 URL 是否包含一些安全头信息。类似的头还有 X-Content-Type-Options、 Referrer-Policy、Feature-Policy 等。

```
### Uncaught ReflectionException: Class request does not exist
```javascript
PHP Fatal error:  Uncaught ReflectionException: Class request does not exist in /home/vagrant/learnku/vendor/laravel/framework/src/Illuminate/Container/Container.php:790
Stack trace:
在 App\Exceptions\Handler::report() 方法里，使用：

dd($exception);
```
### Laravel 下 TNTSearch+jieba-PHP 实现中文全文搜索
```javascript
TNTSearch+jieba-php 这套组合可以在不依赖第三方的情况下实现中文全文搜索；
composer require vanry/laravel-scout-tntsearch
'providers' => [
    ...
    /**
     * TNTSearch 全文搜索
     */
    Laravel\Scout\ScoutServiceProvider::class,
    Vanry\Scout\TNTSearchScoutServiceProvider::class,
],
composer require fukuball/jieba-php

php artisan vendor:publish --provider="Laravel\Scout\ScoutServiceProvider"

配置项 config/scout.php 中增加 tntsearch

'tntsearch' => [
    'storage' => storage_path('indexes'), //必须有可写权限
    'fuzziness' => env('TNTSEARCH_FUZZINESS', false),
    'searchBoolean' => env('TNTSEARCH_BOOLEAN', false),
    'asYouType' => false,

    'fuzzy' => [
        'prefix_length' => 2,
        'max_expansions' => 50,
        'distance' => 2,
    ],

    'tokenizer' => [
        'driver' => env('TNTSEARCH_TOKENIZER', 'default'),

        'jieba' => [
            'dict' => 'small',
            //'user_dict' => resource_path('dicts/mydict.txt'), //自定义词典路径
        ],

        'analysis' => [
            'result_type' => 2,
            'unit_word' => true,
            'differ_max' => true,
        ],

        'scws' => [
            'charset' => 'utf-8',
            'dict' => '/usr/local/scws/etc/dict.utf8.xdb',
            'rule' => '/usr/local/scws/etc/rules.utf8.ini',
            'multi' => 1,
            'ignore' => true,
            'duality' => false,
        ],
    ],

    'stopwords' => [
        '的',
        '了',
        '而是',
    ],
],
 env 增加配置项

SCOUT_DRIVER=tntsearch
TNTSEARCH_TOKENIZER=jieba
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Laravel\Scout\Searchable;

class Article extends Model
{
    use Searchable;

    /**
     * 索引的字段
     *
     * @return array
     */
    public function toSearchableArray()
    {
        return $this->only('id', 'title', 'content');

       // return $this->toArray();
    }
}
生成索引：

php artisan scout:import "App\Model\Article"
https://learnku.com/articles/27617#replies 
```
### 二分查找
```javascript
原理实现：有序集合从中间分为前后2部分，当要查当数值等于中间值，直接返回；当要查询数值大于中间值，则说明要查询的数值在后半部分，那么继续二分后半部分；当要查询数值小于中间数值时，说明要查询的数值在前半部分，那么继续二分前半部分。（过滤掉一半数据查询）

<?php
    /**
     * 递归实现
     * array $arr 有序数组
     * int $search 要查询的数字
     * int firstIndex 数组起始位置
     * int lastIndex 数组结束位置
     * @return 
     */
    function binarySearchRecursion(array $arr, $search, $lastIndex, $firstIndex = 0)
    {
        $len = count($arr);
        if ($len <= 0) {
            return -1;
        }
        $middle = intval(($firstIndex + $lastIndex) / 2);
        if ($search == $arr[$middle]) {//找到直接返回
            return $arr[$middle];
        } elseif ($search > $arr[$middle]) {//去后面查，数组起始位置变为$middle + 1。
            return binarySearchRecursion($arr, $search, $middle + 1, $lastIndex);
        } else {//去前面查，数组结束位置为$middle - 1。
            return binarySearchRecursion($arr, $search, $firstIndex, $middle - 1);
        }
        return -1;
    }

    /**
     * 递归实现
     * array $arr 有序数组
     * int $search 要查询的数字
     * @return 
     */
     function binarySearch($arr, $search)
     {
        $len = count($arr);
        if ($len <= 0 ) {
            return -1;
        }
        $firstIndex = 0;
        $lastIndex = $len - 1;
        while($firstIndex <= $lastIndex) {
            $middle = intval(($firstIndex + $lastIndex) / 2);
            if ($search == $arr[$middle]) {//出口
                return $arr[$middle];
            } elseif ($search > $arr[$middle]) {//去后面查，数组起始位置变为$middle + 1。
                $firstIndex = $middle + 1;
            } else {//去前面查，数组结束位置为$middle - 1。
                $lastIndex = $middle - 1;
            }
        }
        return -1;
     }
     https://learnku.com/articles/35240
```
### 子孙树
```javascript
$arr = [
    ['id'=>1,'parent_id'=>0,'type'=>5],
    ['id'=>2,'parent_id'=>1,'type'=>3],
    ['id'=>3,'parent_id'=>0,'type'=>1],
    ['id'=>4,'parent_id'=>3,'type'=>3],
];
var_dump(getSubTree($arr));

function getSubTree($data, $parent = 'parent_id', $son = 'id', $pid = 0)
    {
        $tmp = [];
        foreach ($data as $key => $value) {
            if ($value[$parent] == $pid) {
                $value['child'] = getSubTree($data, $parent, $son, $value[$son]);
                $tmp[] = $value;
            }
        }
        return $tmp;
    }
    http://www.putyy.com/article/42

```
###  Laravel 的设计哲学
```javascript
class UserController extends Controller
{
    public function index()
    {
        $users = User::all();

        return view('users.index', compact('users'));
    }
}
改为 <?php
   
   namespace App\Repositories;
   
   use App\User;
   
   class DbUserRepository
   {
       public function all(): array
       {
           return User::all()->toArray();
       }
   }
   
   class UserController extends Controller
   {
       private $users;
   
       public function __construct( )
       {
           $this->users = new DbUserRepository;
           // $this->users = new RedisRepository;
       }
   
       public function index()
       {   
           $users = $this->users->all();
           return $users;
       }
   }
   依赖正转的不合理之处在哪里呢？位于高层的控制器依赖于具体的底层数据获取服务，当底层发生变动时，就需要对应的修改高层的内部结构。
   
   我们对依赖关系进一步分析，可知控制器关注的并不是具体如何获取数据，控制器关注的是「数据的可获取性」这一抽象。因此，我们应当将依赖关系进行反转，将对依赖的具体声明职责转移到外部，让控制器仅依赖于抽象层（数据的可获取性）。这种解决方式称之为 控制反转 或 依赖倒置。通过控制反转，高层不再依赖于具体的底层，仅仅是依赖于抽象层，高层和底层实现了解耦。
   用接口来表示「数据的可获取性」这一抽象
   
   <?php
   
   namespace App\Repositories;
   
   interface UserRepositoryInterface
   {
       public function all(): array;
   }
   UserController 依赖的是「数据的可获取性」，不依赖于具体的实现
   
   class UserController extends Controller
   {
       private $users;
   
       public function __construct(UserRepositoryInterface $users)
       {
           $this->users = $users;
       }
   }
   具体的实现交给对应的仓库类即可
   
   class DbUserRepository implements UserRepositoryInterface {}
   class RedisRepository implements UserRepositoryInterface { }
   根据自己的需要注入对应的服务，这样就实现了依赖注入。
   
   $userRepository = new DbUserRepository;
   $userController = new UserController($userRepository)
   总的来说，依赖注入由四部分构成
   
   被使用的服务 - DbUserRepository 或者 RedisRepository 等
   依赖某种服务的客户端 - UserController
   声明客户端如何依赖服务的接口 - UserRepositoryInterface
   依赖注入器，用于决定注入哪项服务给客户端
   
   一个简单的服务容器的实现
   
   namespace App\Services;
   
   use Exception;
   
   class Container 
   {
       protected static $container = [];
   
       /**
        * 绑定服务
        * 
        * @param  服务名称 $name 
        * @param  Callable $resolver
        * @return void
        */
       public static function bind($name, Callable $resolver)
       {   
           static::$container[$name] = $resolver;
       }
   
       /**
        * 解析服务
        * 
        * @param  服务名称 $name
        * @return mix
        */
       public static function make($name)
       {
           if(isset(static::$container[$name])){
               $resolver = static::$container[$name];
               return $resolver();
           }
   
           throw new Exception("不存在该绑定");
      }
   
   }
   绑定服务
   
   App\Services\Container::bind('UserRepository', function(){
       return new App\Repositories\DbUserRepository;
   });
   解析服务
   
   $userRepository = App\Services\Container::make('UserRepository');
   $userController = new UserController($userRepository)
   Laravel 的服务容器的功能则更加的强大，比如，可以将接口与具体的实现进行绑定，通常在 服务提供者 中使用服务容器来进行绑定
   
   public function register()
   {
       $this->app->singleton(UserRepositoryInterface::class, function ($app) {
           return new UserRepository;
       });
   }
   
   
```
### 高并发业务场景下的秒杀解决方案
```javascript

在秒杀前将商品的库存信息加入到 Redis 缓存中。如下格式:
$redis->lpush('商品id',1);
/**
 *
 * 1.接受用户请求
 * 2.验证用户是否已经参与秒杀,商品是否存在
 * 3.根据商品id减少商品队列中的库存数量
 * 4.将用户的秒杀数据写入server层中,并返回秒杀数据对应的唯一key值
 * 5.用户点击下单,根据serve层中的缓存数据,生成订单数据并减少数据库商品的库存数据
 */
$getParams = $_POST;
$userId = $getParams['userId'];
$goodsId = $getParams['goodsId'];

$key = 'goods:miaosha:';
$userResult = $redis->get($key.$userId);
if($userResult){
    $userResult = json_decode($userResult,true);
    echo json_encode(['result'=>$userResult['result'],'key'=>$key.$userId]);// 已经参与过秒杀了
    die();
}else{
    $goodqueue = 'goods:queue:'.$goodsId;
    $result = $redis->lpop($goodqueue);// 删除商品redis队列缓存
    if($result){
        $data = json_encode(['result'=>'OK','userId'=>$userId,'goodsId'=>$goodsId]);
        $redis->set($key.$userId,$data);// 将秒杀信息写入缓存中
        echo json_encode(['result'=>'OK','userId'=>$userId,'goodsId'=>$goodsId,'key'=>$key.$userId]);
        die();
    }else{
        echo json_encode(['result'=>'FAIL','message'=>'商品不存在','goodsId'=>$goodsId]);// 商品库存不存在
        die();
    }
}/**
  * 用户下单界面
  */
 require_once __DIR__.'/redis_connect.php';
 $key = $_GET['key'];
 $data = $redis->get($key);
 /**
  * 生成订单，订单入库
  *
  */https://learnku.com/articles/35141
redis list 可以批量插入数据，不一定每次都只插入一个值.

$numberArr = range(1,100);  
//var_dump($numberArr);
$redis->lPush('goods:queue:5',...$numberArr); // 可变参数  
```
### PHP 开启 Opcache 后如何优雅地部署 PHP 代码
```javascript
提交了代码并且部署了以后，线上代码依然是旧的。所以我执行了下
/etc/init.d/php-fpm reload 就生效了。
opcache_reset (); 但是注意了 这个函数是强制清楚所有 cache 所以 如果并发较高的系统 不能直接这么搞 还有就是 它有两个清除模式，cli 下只能清除 cli 的 cache fpm 的话 必须通过 fpm 请求方式清除才行
https://github.com/gordalina/cachetool
https://learnku.com/laravel/t/35142
```
### 

[Laravel Authorization：支持 ACL、RBAC、ABAC 等模型的授权库](https://learnku.com/articles/35101)

[PSR-12 编码规范扩充](https://learnku.com/laravel/t/35080)

[Laravel 下 Elasticsearch/Algolia 全文搜索 使用案例](https://learnku.com/articles/30812)

 [轻量级全文检索引擎 TNTSearch 和中文分词](https://learnku.com/articles/6207/lightweight-full-text-retrieval-engine-tntsearch-and-chinese-word-segmentation)

[laravel下TNTSearch+jieba-php实现中文全文搜索](https://baijunyao.com/article/154)

[postman使用记录](http://www.putyy.com/article/32)

[免费开源的在线文档管理插件](https://github.com/jianyan74/rageframe2)

[诗词博客](https://gitee.com/leiyong3/laravel_blog)