---
title: php 代码段
date: 2019-07-16 13:43:21
tags:
- php
---

### S.O.I.L.D 之单一职责
```javascript
<?php

namespace Acme\Reporting;

use Auth;
use DB;
use Exception;

class SalesReporter
{   
    /**
     * 获取某个时间段的销售总额
     * 
     * @param  $startDate
     * @param  $endDate  
     * 
     * @return string
     */
    public function between($startDate, $endDate) : string
    {
        if (! Auth::check()) {
            throw new Exception('Authentication required for reporting');
        }

        $sales = $this->queryDBForSalesBetween($startDate, $endDate);
        return $this->format($sales);
    }

    /**
     * 查询销售报表数据
     * 
     * @param  $startDate 
     * @param  $endDate  
     *  
     * @return float         
     */
    protected function queryDBForSalesBetween($startDate, $endDate) : float
    {
        return DB::table('sales')->whereBetween('created_at', [$startDate, $endDate])->sum('charge') / 100;
    }

    /**
     * 数据展示
     * 
     * @param  $sales
     * @return string     
     */
    protected function format($sales) : string
    {
        return "<h1>Sales: $sales</h1>";
    }
}
测试

$report = new Acme\Reporting\SalesReporter();
$report->between(
    now()->subDays(10), 
    now()
);
该例子明显违反了单一职责:

授权方式发生变化时，如 API 授权，需要改动该类
当数据库层发生变化时候，如使用 Redis 时，需要改动该类
当展示方式发生变化时，需要改动该类
正面示例

对于上述的例子，应当作出如下的改动：

不需要关心用户授权，用户授权与本类的职责无关
数据层应当剥离出来
展示层应当剥离出来
<?php

// 展示层接口
interface SalesOutputInterface {
    public function output();
}

// 展示层实现
class HtmlOutput implements SalesOutputInterface {
    public function output($sales)
    {
        echo "<h1>{$sales}</h1>";
    }
}

// 数据层
class SalesRepository {
    public function between()
    {
        return DB::table('sales')->whereBetween('create_at', [$startDate, $endDate])->sum('charge') / 100;
    }
}

// 职责类
class SalsReporter {

    public $repo;

    public function __construct($repo)
    {
        $this->repo = $repo;
    }

    public function between($startDate, $endDate, SalesOutputInterface $formater)
    {
        $sales = $this->repo->between($startDate, $endDate);
        $formater->output($sales);
    }
}
测试

$report = new SalsReporter(new SalesRepository);
$report->between(
    now->subDays(10), 
    now(),
    new HtmlOutput
);
结合 Laravel 的依赖注入，可以进一步简化https://learnku.com/articles/27923#topnav

class SalsReporter {

    public $repo;

    public function __construct(SalesRepository $repo)
    {
        $this->repo = $repo;
    }

    public function between($startDate, $endDate, SalesOutputInterface $formater)
    {
        $sales = $this->repo->between($startDate, $endDate);
        $formater->output($sales);
    }
}
```
### 字节转换
```javascript
/**
     * 转化内存信息https://github.com/yiranzai/php-tools
     * @param      $bytes
     * @param bool $binaryPrefix
     * @return string
     */
    public static function getNiceFileSize(int $bytes, bool $binaryPrefix = true): string
    {
        if ($binaryPrefix) {
            $unit = array('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB');
            if ($bytes === 0) {
                return '0 ' . $unit[0];
            }
            return @round($bytes / (1024 ** ($i = floor(log($bytes, 1024)))), 2) . ' ' . ($unit[(int)$i] ?? 'B');
        }

        $unit = array('B', 'KB', 'MB', 'GB', 'TB', 'PB');
        if ($bytes === 0) {
            return '0 ' . $unit[0];
        }
        return @round($bytes / (1000 ** ($i = floor(log($bytes, 1000)))), 2) . ' ' . ($unit[(int)$i] ?? 'B');
    }
    /**
         * 四舍五入 格式化除法
         * @param     $divisor
         * @param     $divided
         * @param int $scale
         * @return int|string
         */
        public static function formatDiv($divisor, $divided, int $scale = 2)
        {
            if (empty((int)$divided)) {
                return sprintf('%.' . $scale . 'f', 0);
            }
            return $scale === 0 ?
                bcdiv($divisor, $divided) :
                sprintf('%.' . $scale . 'f', bcdiv($divisor, $divided, $scale + 1));
        }
        /**
             * 求两个数的最大公约数
             *
             * @param $a
             * @param $b
             * @return int
             */
            public static function gcd(int $a, int $b): int
            {
                if ($a === 0 || $b === 0) {
                    return abs(max(abs($a), abs($b)));
                }
        
                $r = $a % $b;
                return ($r !== 0) ?
                    self::gcd($b, $r) :
                    abs($b);
            }
        
            /**
             * 求一个数组的最大公约数
             *
             * @param array $array
             * @param int   $a
             * @return int
             */
            public static function gcdArray(array $array, $a = 0): int
            {
                $b = array_pop($array);
                return ($b === null) ?
                    (int)$a :
                    self::gcdArray($array, self::gcd($a, $b));
            }
            
            /**
                 * 每次都取中间的那个数，遍历数组，比它大放右边，比它小放左边  快速排序
                 *
                 * @param array $array
                 * @return array
                 */
                public static function quickSort(array $array): array
                {
                    $len = count($array);
                    if ($len <= 1) {
                        return $array;
                    }
                    $m      = $len >> 1;//取中间值 50>>1 25 51>>1 25 52>>1 26
                    $mValue = $array[$m];
                    $left   = $right = [];
                    foreach ($array as $key => $iValue) {
                        if ($key === $m) {
                            continue;
                        }
                        if ($iValue < $mValue) {
                            $left[] = $iValue;
                        } else {
                            $right[] = $iValue;
                        }
                    }
                    return array_merge(self::quickSort($left), [$mValue], self::quickSort($right));
                }
                
                public static function quick($arr){
                        if(count($arr)<=1){ //如果数组根本就一个元素就直接返回 不用在排序咯
                            return $arr;
                        }
                
                        $k=$arr[0];//定义一个初始要排序的值 默认为数组第一个
                        $x=array();//定义比要排序的值 小的数组块
                        $y=array();//定义比要排序的值 大的数组块
                        $_size=count($arr);//统计数组的大小
                        for($i=1;$i<$_size;$i++){//循环数组 记住这边要从索引1 开始
                            if($arr[$i]<=$k){//如果当前的值小于 要排序的值
                                $x[]=$arr[$i];//就把小于的值放到 小的数组块中
                            }elseif($arr[$i]>$k){//如果当前的值大于 要排序的值
                                $y[]=$arr[$i];//就把大于的值放到 大的数组块中
                            }
                        }
                        $x=Sort::quick($x);//依次递归执行 这样就会得到小的数组块
                        $y=Sort::quick($y);//依次递归执行 这样就会得到大的数组块
                        return array_merge($x,array($k),$y);//最后在合并下 小的模块+中间的模块【初始要排序的值】+大的模块 就ok~
                    }
```
### php多线程
```javascript
// 继承 Thread 的类具有创建线程的能力
class Request extends Thread
{
    private $sql;

    private $dsn;

    public function __construct($sql, $dsn)
    {
        $this->sql = $sql;
        $this->dsn = $dsn;
    }

    public function run()
    {
        $db = new PDO($this->dsn);

        $stat1 = $db->query($this->sql);

        $result = $stat1->fetchAll(PDO::FETCH_ASSOC);

        print_r($result);
    }
}

$dsn = 'sqlite:/tmp/pselect.db';
$db = new PDO($dsn);

$db->exec('create table users(id int, name varchar(255))');
$db->exec('create table books(id int, name varchar(255))');

//$db->exec("insert into users(id, name) values(1, '张三')");
//$db->exec("insert into users(id, name) values(2, '李四')");

//$db->exec("insert into books(id, name) values(1, '三国')");
//$db->exec("insert into books(id, name) values(2, '水浒')");

$sql = [
    'select * from users',
    'select * from books',
];

//$stat1 = $db->query($sql[0]);
//$stat2 = $db->query($sql[1]);

//$results1 = $stat1->fetchAll(PDO::FETCH_ASSOC);
//$results2 = $stat2->fetchAll(PDO::FETCH_ASSOC);

//print_r($results1);
//print_r($results2);

$arr = [];
for ($i = 0; $i < 2; $i++) {
    $request = new Request($sql[$i], $dsn);
    $arr[$i] = $request;
    // 创建新线程，随后线程会执行 run 方法
    if (! $request->start()) {
        die("Start thread failed\n");
    }
    echo "Thread({$i}) started\n";
}

for ($i = 0; $i < 2; $i++) {
    // join 是阻塞的，所以脚本运行时间取决于耗时最长的线程
    if (! $arr[$i]->join()) {
        die("Join failed\n");
    }
}
https://learnku.com/articles/26812
public static function select($array){
        $count=count($array);//取出数组的总长度
        for($i=0;$i<$count-1;$i++){//外部循环 依次循环
            /* 找出最小的元素 开始*/
            $min=$i;//查找到最低的元素
            for($j=$i+1;$j<$count;$j++){
                //由小到大排列
                if($array[$min]>$array[$j]){//如果当前的元素比后面的元素大
                    $min=$j;//就把最小的元素指针替换成后面元素
                }
            }
            /* 找出最小的元素 结束*/选择排序

            /*swap$array[$i]and$array[$min]即将当前内循环的最小元素放在$i位置上*/
            if($min!=$i){//如果找出的最小的元素不在当前的循环的索引位置
                $temp=$array[$min];//当前元素存储临时变量
                $array[$min]=$array[$i];//把最小位置上的元素替换成当前的元素
                $array[$i]=$temp;//把当前的元素替换成最小的元素
            }
        }
        return $array;
    }
//模式分隔符后的"i"标记这是一个大小写不敏感的搜索
if (preg_match("/php/i", "PHP is the web scripting language of choice.")) {
    echo "查找到匹配的字符串 php。";
} else {
    echo "未发现匹配的字符串 php。";
}
```
### 大文件传输解决方案
```javascript
public function sliceDownload()
    {

        $path = 'slice/'.date('Ymd')  ;

        $filename = $path .'/'. '周杰伦 - 黑色幽默 [mqms2].mp3' ;

        //获取文件资源https://learnku.com/articles/31108
        $file = Storage::disk('admin')->readStream($filename);

        //获取文件大小
        $fileSize = Storage::disk('admin')->size($filename);

        header("Content-type:application/octet-stream");//设定header头为下载
        header("Accept-Ranges:bytes");
        header("Accept-Length:".$fileSize);//响应大小
        header("Content-Disposition: attachment; filename=周杰伦 - 黑色幽默 [mqms2].mp3");//文件名

        //不设置的话要等缓冲区满之后才会响应
        ob_end_clean();//缓冲区结束
        ob_implicit_flush();//强制每当有输出的时候,即刻把输出发送到浏览器\
        header('X-Accel-Buffering: no'); // 不缓冲数据

        $limit=1024*1024;
        $count=0;

        //限制每秒的速率
        while($fileSize-$count>0){//循环读取文件数据
            $data=fread($file,$limit);
            $count+=$limit;
            echo $data;//输出文件
            sleep(1);
        }

    }
```
### PHP 生成奖状
```javascript
ob_clean();
$realname = "姓名:最闲的码农";
$schoolname = "社区:Laravel"; 

$image = imagecreatefrompng('1562926506930.png');      //书模版图片文件的路径 必须是png格式的文件
$red = imagecolorallocate($image,00,00,00); // 字体颜色
// imageTTFText("Image", "Font Size", "Rotate Text", "Left Position","Top Position", "Font Color", "Font Name", "Text To Print");
//根据文本填写的位置不同https://learnku.com/articles/31120
//"Left Position 和 Top Position 可以使用 getimagesize进行配合计算文字x和y轴坐标
imageTTFText($image, 50, 0, 628, 615, $red, 'simheittf.ttf',$realname);
imageTTFText($image, 50, 0, 628, 714, $red, 'simheittf.ttf', $schoolname);
header('Content-type: image/png;');
ImagePng($image);
imagedestroy($image);
$filename = 'certificate_aadarsh.png';
ImagePng($image, $filename);
imagedestroy($image);
```
###  Composer install 报错
```javascript
Finished: success: 62, skipped: 0, failure: 0, total: 62
Package operations: 62 installs, 0 updates, 0 removals
  - Installing kylekatarnls/update-helper (1.1.1): Loading from cache
Plugin installation failed, rolling back
  - Removing kylekatarnls/update-helper (1.1.1)

  [RuntimeException]
  Could not delete /home/vagrant/code/w2_support-/vendor/kylekatarnls/update-helper/src/   
  UpdateHelper:
  composer install --no-plugins
  我的问题解决了.!https://learnku.com/laravel/t/31137
  
```
### PHP-FPM 与 Nginx 的通信机制总结
```javascript
PHP-FPM 即 PHP-FastCGI Process Manager， 它是 FastCGI 的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种；master 进程只有一个，负责监听端口，接收来自服务器的请求，而 worker 进程则一般有多个（具体数量根据实际需要进行配置），每个进程内部都会嵌入一个 PHP 解释器，是代码真正执行的地方
https://learnku.com/articles/23694

  www.test.com
        |
        |
      Nginx
        |
        |
路由到 www.test.com/index.php
        |
        |
加载 nginx 的 fast-cgi 模块
        |
        |
fast-cgi 监听 127.0.0.1:9000 地址
        |
        |
www.test.com/index.php 请求到达 127.0.0.1:9000
        |
        |
     等待处理...
```
### Laravel 报错：PHP Fatal error: Uncaught ReflectionException: Class request does not exist
```javascript
在 App\Exceptions\Handler::report() 方法里，使用：

dd($exception);
即可打印更详细的报错信息，知道问题在哪https://learnku.com/laravel/t/31178
```
### JSON 响应出现浮点小数溢出
```javascript
调整 php.ini 中 serialize_precision (序列化精度) 的大小来解决这个问题。

默认值 serialize_precision = -1
将这个值改为 小于 17 的数字就解决了这个问题，最后一直往小调，我 14 的时候就没有问题了
https://wiki.php.net/rfc/precise_float_value https://learnku.com/articles/31194
```
### 原码、反码、补码
```javascript
正数的原码、反码、补码都一样

负数的反码 = 它的原码符号位不变，其他取反（0->1 , 1->0）

负数的补码 = 它的反码 + 1

 1 ==> 原码 [0000 0001]   反码[0000 0001]   补码[0000 0001]

-1 ==> 原码 [1000 0001]   反码[1111 1110]   补码[1111 1111]
0 的反码，补码都是 0

在计算机运算的时候，都是以补码的方式来计算的

1+1   1-1 = 1+（-1）
按位与 & ： 两位全为１，结果为 1，否则为 0

按位或 | : 两位有一个为 1，结果为 1，否则为 0

按位异或 ^ : 两位一个为 0, 一个为 1，结果为 1，否则为 0
//2&3
//2的补码 0000 0010
//3的补码 0000 0011
//2&3     0000 0010 =>2
//2|3     0000 0011 =>3
//2^3     0000 0001 =>1

//-2^2
//-2的原码 1000 0010
//-2的反码 1111 1101
//-2的补码 1111 1110

//2 的补码  0000 0010

//-2^2
//-2的补码 1111 1110
//2 的补码 0000 0010
//-2^2     1111 1100 （补码）
//-2^2     1111 1011 （反码）
//-2^2     1000 0100  （原码） => 4

https://learnku.com/articles/31179
```
### APP_KEY
```javascript
只有一个地方会用到 APP_KEY：cookies。Laravel 使用它来加密所有的 cookies，在将 cookie 返回给用户之前 Laravel 会对 cookie 进行加密，然后再返回给用户，这样客户端就无法自己修改 cookie 来伪装成管理员或者其他用户了。

所以的加密和解密都在 [Encrypter](https://learnku.com/docs/laravel/master/encryption#using-the-encrypter) 中进行处理，其中主要使用了 [openssl_encrypt](https://secure.php.net/manual/en/function.openssl-encrypt.php) 进行加密。

有很多用户都会有一个误解，那就是 APP_KEY 是用来处理用户哈希密码的。事实上不是这样的。Laravel 的密码使用了 Hash::make() 或者 bcrypt() 来进行哈希处理，其中并没有用到 APP_KEY
在 Laravel 中有两个主要的加密 Facade，分别是 Crypt（对称加密） 和 Hash（单向加密哈希）。密码是哈希，而 cookie 则是对称加密。
$key = "dont-panic";
$message = "So long and thanks for all the fish";
$key = "dont-panic";
$cipher = "AES-256-CBC";
echo openssl_encrypt($message, $cipher, $key);

// JJEK8L4G3BCfY0evXDRxUke2zqAzq6i7wL/Px4SjaEHXqt3x7hsj4+PhVQaH4ujX

$secret = "JJEK8L4G3BCfY0evXDRxUke2zqAzq6i7wL/Px4SjaEHXqt3x7hsj4+PhVQaH4ujX";
$key = "dont-panic";
$cipher = "AES-256-CBC";
echo openssl_decrypt($secret, $cipher, $key);

// So long and thanks for all the fish
Laravel 中使用了 PHP 的原生方法 password_hash()，它使用的哈希算法叫 bcrypt。

use Illuminate\Support\Facades\Hash;

$password = "dont-panic";
echo Hash::make($password);

// $2y$10$hEEF0lv4spxnvw5O4XyLZ.QjCE1tCu8HjMpWhmCS89J0EcSW0XELu
$hash = '$2y$10$hEEF0lv4spxnvw5O4XyLZ.QjCE1tCu8HjMpWhmCS89J0EcSW0XELu';
return Hash::check($input, $hash); https://learnku.com/articles/31169


// 加密算法
1. $encryptMethod = 'aes-256-cbc';
// 明文数据
2. $data = 'Hello World';

// 生成IV
3. $ivLength = openssl_cipher_iv_length($encryptMethod);
4. $iv = openssl_random_pseudo_bytes($ivLength, $isStrong);
5. if (false === $iv && false === $isStrong) {
6.     die('IV generate failed');
7. }

// 加密
8. $encrypted = openssl_encrypt($data, $encryptMethod, 'secret', 0, $iv);
// 解密
9. $decrypted = openssl_decrypt($encrypted, $encryptMethod, 'secret', 0, $iv);

```
### PHP 识别相片
```javascript
PHP 识别相片是否是颠倒的，并且重新摆正相片https://learnku.com/articles/31235
$image = imagecreatefromstring(file_get_contents($_FILES['image_upload']['tmp_name']));
$exif = exif_read_data($_FILES['image_upload']['tmp_name']);
if(!empty($exif['Orientation'])) {
    switch($exif['Orientation']) {
        case 8:
            $image = imagerotate($image,90,0);
            break;
        case 3:
            $image = imagerotate($image,180,0);
            break;
        case 6:
            $image = imagerotate($image,-90,0);
            break;
    }
}

```
### Composer 镜像限额，出现要求用户名认证
```javascript
从 GitHub 下载 Zip 代码包而不是 CDN：https://learnku.com/articles/30415

$ composer install --prefer-source
不要在框架的 composer.json 里写死了源
```
[ PHP 问答系统](https://github.com/sdfsky/tipask)

[Laravel 中使用 极光推送jpush composer包](https://learnku.com/articles/31145)

[PHP常用函数整理](https://www.qingwei.tech/programe-develops/php/622.html)

[笔记分享 | 简书2GitHub](https://github.com/alicfeng/note.samego.com)

[ PHP 中文简易分词](https://learnku.com/articles/31102)

[PHP the right way](https://michael-lik.github.io/php-the-right-way/pages/The-Basics.html)

[用PHP玩转进程之二 — 多进程PHPServer](https://www.fanhaobai.com/2018/09/process-php-multiprocess-server.html)

[后端来配置 Vue Router 的方案](https://learnku.com/articles/30763)