---
title: php 开发记录
date: 2019-11-20 11:19:09
tags:
---

### 错误处理
```javascript
try {
    $a = 5 / 0;
} catch (Exception $e) {
    $e->getMessage();
    $a = -1;  // 通过异常来处理 $a 为 0 的情况，但是实际上，捕获不到该异常
}

echo $a;
// PHP Warning:  Division by zero
PHP7 开始统一这两者，使错误也可以像异常那样抛出
PHP 中的错误可理解为 使脚本不运行不正常的情况，根据错误级别从高到低可划分为五类

Parse error 或 Syntax Error - 语法解析错误，触发该错误后，脚本完全无法运行；
Fatal Error - 致命错误，触发该错误后，后面的脚本无法继续执行；
Warning Error - 出现比较不恰当的地方，脚本可继续执行；
Notice Error - 出现不恰当的地方，但是程度比 Warning Error 低，脚本可继续执行；
Deprecated Error - 不推荐这么使用，未来可能会废弃，脚本可继续执行；
// E_ALL - 处理全部错误类型
set_error_handler('customError', E_ALL);

/**
 * @param  int $errno 错误的级别
 * @param  string $errstr  错误的信息
 * @param  string $errfile 错误的文件名(可选)
 * @param  string $errline 错误发生的行号（可选）
 */
function customError(int $errno, string $errstr, string $errfile, string $errline)
{
    echo sprintf('错误消息为 %s', $errstr);
}
当错误类型为 E_USER_DEPRECATED 时，需要添加 @

@trigger_error("foo", E_USER_DEPRECATED);
$a = 5 / 0;  // 错误消息为 Division by zero
function division($a, $b) {
    if($b == 0){
        @trigger_error("0 不能作为除数", E_USER_NOTICE);
        return -1;
    }
    return $a / $b;
}

echo division(10, 0);
开发环境推荐配置

display_errors = On
display_startup_error = On
error_reporting = -1
log_errors = On
生产环境推荐配置

display_errors = Off
display_startup_error = Off
; 报告 Notice 以外的所有错误
error_reporting = E_ALL & ~E_NOTICE
log_errors = On
https://learnku.com/articles/36521
```
### 对象的浅拷贝与深拷贝
```javascript
class Bar {
    public $name;
}

class Foo 
{
    public $bar;
    function __construct()
    {
        $this->bar = new Bar();
    }
}

$foo = new Foo();
$copyFoo = clone $foo;

var_dump($foo->bar === $copyFoo->bar);  // bool(true)
克隆的实例与原有的实例的 bar 成员都指向同一个实例 https://github.com/myclabs/DeepCopy
https://learnku.com/articles/36876
```

### php数组
```javascript
其他编程语言数组是由相同类型的元素（element）的集合所组成的数据结构，而 PHP 数组元素可以为不同类型的元素。因此说 PHP 数组不是纯粹的数组，而是哈希 (字典) 更为恰当.
注意的是字符串类型假如是有效十进制数字的话，则会转换为整型. "8"->8. 若不想转换则在数字前添加 "+" 符号.

// 02不是有效十进制数字
$arr = ['1' => 'a', '+1' => 'b', '02' => 'c'];
(array)$scalarValue 与 array ($scalarValue) 一样。而对象 (object) 类型转换为 array. 其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 '*' 做前缀。这些前缀的前后都各有一个 NULL 字符。
var_dump(array_fill(0, 0, 1)); // []
var_dump(array_fill(1, 3, 'red')); // [1=>'red', 2=>'red', 3=>'red']
$a = ['a' => 1, 'B' => 2, 3 => 'c', 'A' => 4, 'b' => 6];
print_r(array_chunk($a, 2)); // [[1, 2], ['c', 4], [6]]
print_r(array_chunk($a, 2, true)); // [['a' => 1, 'B' => 2], [3 => 'c', 'A' => 4], ['b' => 6]]

var_dump(array_slice($a, -1, 1, true)); [4 => 'f']

print_r(array_count_value([1, 'hello', 1, 'hello', 'world'])) // [1=>2, 'hello' => 2, 'world' => 1]
var_dump(array_product([])); // 1
var_dump(array_sum([])); // 0
$a = ['a' => 1, 'b' => 2, 'c' => 3];
var_dump(array_keys($a)); // ['a', 'b', 'c']
var_dump(array_keys($a, '1')); // 'a'
var_dump(array_keys($a, '1', true)); // []
var_dump(array_rand([1, 2, 3], 2)); // [1, 3]
var_dump(array_search(false, $a, true)); // false
var_dump(in_array('1', $os, true)); // false
var_dump(array_diff($array1, $array2, $array3)); // ['blue']

$arr1 = ['color' => ['favorite' => 'red', 5]];
$arr2 = ['color' => ['favorite' => 'green', 6, 7]];
var_dump(array_merge_recursive($arr1, $arr2)); // ['color' => ['favorite' => ['red', 'green'], 5, 6, 7]]
$arr1 = ['color' => ['favorite' => 'red', 5]];
$arr2 = ['color' => ['favorite' => 'green', 6, 7]];
var_dump(array_merge($arr1, $arr2)); // ['color' => ['favorite' => 'green', 6, 7]];
var_dump($arr1 + $arr2); // ['color' => ['favorite' => 'red', 5]]
$ar1 = [10, 100, 100, 0];
$ar2 = [1, 3, 2, 4];
array_multisort($ar1, $ar2); // [0, 10, 100, 100] [4, 1, 2, 3]
array_multisort($ar1, SORT_DESC, SORT_NUMERIC, $ar2, SORT_ASC, SORT_NUMERIC); // [100, 100, 10, 0] [2, 3, 1, 4]
// 排序针对的是值, 而且会保存原先索引
$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");
arsort($fruits);
print_r($fruits); // ['a' => 'orange', 'd' => 'lemon', 'b' => 'banana', 'c' => 'apple']

// 语言结构, 并非函数
$info = ['coffee', 'brown', 'caffeine'];
list($drink, $color, $power) = $info;
echo "$drink, $color, $power"; // coffee, brown, caffeine
// 可以省略不想取的
list($drink, , $power) = $info;
echo "$drink, $power"; // coffee, caffeine
// 7.0 以上是从左到右赋值, 7.0以下是从右到左赋值
list($a[0], $a[1], $a[2]) = $info;
// 7.0 以上
var_dump($a); // ['coffee', 'brown', 'caffeine']
// 7.0 以下
var_dump($a); // ['caffeine', 'brown', 'coffee']
// 7.1 支持索引数组
$info = ['a' => 'coffee', 'b' => 'brown', 'c' => 'caffeine'];
list('a' => $drink, 'c' => $power) = $info;
echo "$drink, $power"; // coffee, caffeine
$a = [1, 2, 3];
echo count($a); // 3
$b = [$a, 4, 5, 6];
echo count($b, COUNT_RECURSIVE) // 7

$a = ['php', 4.0, ['green', 'red']];
var_dump(array_reverse($a)); // [['green', 'red'], 7.1, 'php']
var_dump(array_reverse($a, true)); // [2 => ['green', 'red'], 1 => 7.1, 0 => 'php']

$sweet = ['a' => 'apple', 'b' => 'banana'];

function testPrint($item, $key, $userData) {
  echo "$key holds $item and $userData\n";
}
/**
* a holds apple and php
* b holds banana and php
* sour holds lemon and php
*/
array_walk_recursive($fruits, 'testPrint', 'php');
function odd($var)
{
  return $var & 1;
}
// 自然排序, 以人们认知方式排序,区分大小写
$arr = ['a1', 'A1', 'c2', 'c3', 'b4', 'b5', 'B1'];
natsort($arr);  // true
var_dump($arr); // ['A1', 'B1', 'a1', 'b4', 'b5', 'c2', 'c3']
// 数字比较项目, 'a1' 转换数字为 0, 所以排序顺序如下
$arr1 = ['a1', 0, 2, '1a'];
sort($arr1, SORT_NUMERIC);
var_dump($arr1);  // ['a1', 0, '1a', 2]
// 被作为字符串来比较
$fruits = array("lemon", "orange", "banana", "apple", 1);
sort($fruits, SORT_STRING);
var_dump($fruits); // [1, 'apple', 'banana', 'lemon', 'orange']
//  和 natsort() 类似对每个单元以“自然的顺序”对字符串进行排序
$arr = ['a1', 'A1', 'c2', 'c3', 'b4', 'b5', 'B1'];
sort($arr, SORT_NATURAL);  // true
var_dump($arr); // ['A1', 'B1', 'a1', 'b4', 'b5', 'c2', 'c3']
https://learnku.com/articles/36866
```
### Base64 加密算法
```javascript
https://gitee.com/obamajs/php-base64-implemention/blob/master/Base64.php
base64 的作用是把任意的字符序列转换为只包含特殊字符集的序列
每个 Base64 字符用 6 位来表示，但是一个字节是 8 位，所以 3 个字节刚好可以生成 4 个 Base64 字符，这应该很容易计算出来，下面我给大家举个例子，假如说现在有个字符串为 "123"，1 的 ASCII 为 49，那么转换为二进制就是 00110001，2 的 ASCII 为 50，那么转换为二进制就是 00110010，3 的 ASCII 为 51，那么转换为二进制就是 00110011，这三个二进制组合在一起就是这样：001100010011001000110011
按照 4 个 Base64 字符转换为 3 个 8 位的字节算法就可以了，4 个字符组合起来就是 24 位，按照 8 位一个字节，就是三个字节。
function normalToBase64Char($num)
{
    if ($num >= 0 && $num <= 25) {
        return chr(ord('A') + $num);
    } else if ($num >= 26 && $num <= 51) {
        return chr(ord('a') + ($num - 26));
    } else if ($num >= 52 && $num <= 61) {
        return chr(ord('0') + ($num - 52));
    } else if ($num == 62) {
        return '+';
    } else {
        return '/';
    }
}
function base64CharToInt($num)
{
    if ($num >= 65 && $num <= 90) {
        return ($num - 65);
    } else if ($num >= 97 && $num <= 122) {
        return ($num - 97) + 26;
    } else if ($num >= 48 && $num <= 57) {
        return ($num - 48) + 52;
    } else if ($num == 43) {
        return 62;
    } else {
        return 63;
    }
}
https://learnku.com/articles/36655
```
[PHP7 的垃圾回收机制](https://learnku.com/articles/33451)

[微博机器人](https://github.com/Hanson/weibot)









