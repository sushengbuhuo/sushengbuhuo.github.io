---
title: php 开发记录
date: 2019-11-20 11:19:09
tags:
---

### 错误处理
```javascript
try {
    $a = 5 / 0;
} catch (Exception $e) {
    $e->getMessage();
    $a = -1;  // 通过异常来处理 $a 为 0 的情况，但是实际上，捕获不到该异常
}

echo $a;
// PHP Warning:  Division by zero
PHP7 开始统一这两者，使错误也可以像异常那样抛出
PHP 中的错误可理解为 使脚本不运行不正常的情况，根据错误级别从高到低可划分为五类

Parse error 或 Syntax Error - 语法解析错误，触发该错误后，脚本完全无法运行；
Fatal Error - 致命错误，触发该错误后，后面的脚本无法继续执行；
Warning Error - 出现比较不恰当的地方，脚本可继续执行；
Notice Error - 出现不恰当的地方，但是程度比 Warning Error 低，脚本可继续执行；
Deprecated Error - 不推荐这么使用，未来可能会废弃，脚本可继续执行；
// E_ALL - 处理全部错误类型
set_error_handler('customError', E_ALL);

/**
 * @param  int $errno 错误的级别
 * @param  string $errstr  错误的信息
 * @param  string $errfile 错误的文件名(可选)
 * @param  string $errline 错误发生的行号（可选）
 */
function customError(int $errno, string $errstr, string $errfile, string $errline)
{
    echo sprintf('错误消息为 %s', $errstr);
}
当错误类型为 E_USER_DEPRECATED 时，需要添加 @

@trigger_error("foo", E_USER_DEPRECATED);
$a = 5 / 0;  // 错误消息为 Division by zero
function division($a, $b) {
    if($b == 0){
        @trigger_error("0 不能作为除数", E_USER_NOTICE);
        return -1;
    }
    return $a / $b;
}

echo division(10, 0);
开发环境推荐配置

display_errors = On
display_startup_error = On
error_reporting = -1
log_errors = On
生产环境推荐配置

display_errors = Off
display_startup_error = Off
; 报告 Notice 以外的所有错误
error_reporting = E_ALL & ~E_NOTICE
log_errors = On
https://learnku.com/articles/36521
```
### 对象的浅拷贝与深拷贝
```javascript
class Bar {
    public $name;
}

class Foo 
{
    public $bar;
    function __construct()
    {
        $this->bar = new Bar();
    }
}

$foo = new Foo();
$copyFoo = clone $foo;

var_dump($foo->bar === $copyFoo->bar);  // bool(true)
克隆的实例与原有的实例的 bar 成员都指向同一个实例 https://github.com/myclabs/DeepCopy
https://learnku.com/articles/36876
```

### php数组
```javascript
其他编程语言数组是由相同类型的元素（element）的集合所组成的数据结构，而 PHP 数组元素可以为不同类型的元素。因此说 PHP 数组不是纯粹的数组，而是哈希 (字典) 更为恰当.
注意的是字符串类型假如是有效十进制数字的话，则会转换为整型. "8"->8. 若不想转换则在数字前添加 "+" 符号.

// 02不是有效十进制数字
$arr = ['1' => 'a', '+1' => 'b', '02' => 'c'];
(array)$scalarValue 与 array ($scalarValue) 一样。而对象 (object) 类型转换为 array. 其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 '*' 做前缀。这些前缀的前后都各有一个 NULL 字符。
var_dump(array_fill(0, 0, 1)); // []
var_dump(array_fill(1, 3, 'red')); // [1=>'red', 2=>'red', 3=>'red']
$a = ['a' => 1, 'B' => 2, 3 => 'c', 'A' => 4, 'b' => 6];
print_r(array_chunk($a, 2)); // [[1, 2], ['c', 4], [6]]
print_r(array_chunk($a, 2, true)); // [['a' => 1, 'B' => 2], [3 => 'c', 'A' => 4], ['b' => 6]]

var_dump(array_slice($a, -1, 1, true)); [4 => 'f']

print_r(array_count_value([1, 'hello', 1, 'hello', 'world'])) // [1=>2, 'hello' => 2, 'world' => 1]
var_dump(array_product([])); // 1
var_dump(array_sum([])); // 0
$a = ['a' => 1, 'b' => 2, 'c' => 3];
var_dump(array_keys($a)); // ['a', 'b', 'c']
var_dump(array_keys($a, '1')); // 'a'
var_dump(array_keys($a, '1', true)); // []
var_dump(array_rand([1, 2, 3], 2)); // [1, 3]
var_dump(array_search(false, $a, true)); // false
var_dump(in_array('1', $os, true)); // false
var_dump(array_diff($array1, $array2, $array3)); // ['blue']

$arr1 = ['color' => ['favorite' => 'red', 5]];
$arr2 = ['color' => ['favorite' => 'green', 6, 7]];
var_dump(array_merge_recursive($arr1, $arr2)); // ['color' => ['favorite' => ['red', 'green'], 5, 6, 7]]
$arr1 = ['color' => ['favorite' => 'red', 5]];
$arr2 = ['color' => ['favorite' => 'green', 6, 7]];
var_dump(array_merge($arr1, $arr2)); // ['color' => ['favorite' => 'green', 6, 7]];
var_dump($arr1 + $arr2); // ['color' => ['favorite' => 'red', 5]]
$ar1 = [10, 100, 100, 0];
$ar2 = [1, 3, 2, 4];
array_multisort($ar1, $ar2); // [0, 10, 100, 100] [4, 1, 2, 3]
array_multisort($ar1, SORT_DESC, SORT_NUMERIC, $ar2, SORT_ASC, SORT_NUMERIC); // [100, 100, 10, 0] [2, 3, 1, 4]
// 排序针对的是值, 而且会保存原先索引
$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");
arsort($fruits);
print_r($fruits); // ['a' => 'orange', 'd' => 'lemon', 'b' => 'banana', 'c' => 'apple']

// 语言结构, 并非函数
$info = ['coffee', 'brown', 'caffeine'];
list($drink, $color, $power) = $info;
echo "$drink, $color, $power"; // coffee, brown, caffeine
// 可以省略不想取的
list($drink, , $power) = $info;
echo "$drink, $power"; // coffee, caffeine
// 7.0 以上是从左到右赋值, 7.0以下是从右到左赋值
list($a[0], $a[1], $a[2]) = $info;
// 7.0 以上
var_dump($a); // ['coffee', 'brown', 'caffeine']
// 7.0 以下
var_dump($a); // ['caffeine', 'brown', 'coffee']
// 7.1 支持索引数组
$info = ['a' => 'coffee', 'b' => 'brown', 'c' => 'caffeine'];
list('a' => $drink, 'c' => $power) = $info;
echo "$drink, $power"; // coffee, caffeine
$a = [1, 2, 3];
echo count($a); // 3
$b = [$a, 4, 5, 6];
echo count($b, COUNT_RECURSIVE) // 7

$a = ['php', 4.0, ['green', 'red']];
var_dump(array_reverse($a)); // [['green', 'red'], 7.1, 'php']
var_dump(array_reverse($a, true)); // [2 => ['green', 'red'], 1 => 7.1, 0 => 'php']

$sweet = ['a' => 'apple', 'b' => 'banana'];

function testPrint($item, $key, $userData) {
  echo "$key holds $item and $userData\n";
}
/**
* a holds apple and php
* b holds banana and php
* sour holds lemon and php
*/
array_walk_recursive($fruits, 'testPrint', 'php');
function odd($var)
{
  return $var & 1;
}
// 自然排序, 以人们认知方式排序,区分大小写
$arr = ['a1', 'A1', 'c2', 'c3', 'b4', 'b5', 'B1'];
natsort($arr);  // true
var_dump($arr); // ['A1', 'B1', 'a1', 'b4', 'b5', 'c2', 'c3']
// 数字比较项目, 'a1' 转换数字为 0, 所以排序顺序如下
$arr1 = ['a1', 0, 2, '1a'];
sort($arr1, SORT_NUMERIC);
var_dump($arr1);  // ['a1', 0, '1a', 2]
// 被作为字符串来比较
$fruits = array("lemon", "orange", "banana", "apple", 1);
sort($fruits, SORT_STRING);
var_dump($fruits); // [1, 'apple', 'banana', 'lemon', 'orange']
//  和 natsort() 类似对每个单元以“自然的顺序”对字符串进行排序
$arr = ['a1', 'A1', 'c2', 'c3', 'b4', 'b5', 'B1'];
sort($arr, SORT_NATURAL);  // true
var_dump($arr); // ['A1', 'B1', 'a1', 'b4', 'b5', 'c2', 'c3']
https://learnku.com/articles/36866
```
### Base64 加密算法
```javascript
https://gitee.com/obamajs/php-base64-implemention/blob/master/Base64.php
base64 的作用是把任意的字符序列转换为只包含特殊字符集的序列
每个 Base64 字符用 6 位来表示，但是一个字节是 8 位，所以 3 个字节刚好可以生成 4 个 Base64 字符，这应该很容易计算出来，下面我给大家举个例子，假如说现在有个字符串为 "123"，1 的 ASCII 为 49，那么转换为二进制就是 00110001，2 的 ASCII 为 50，那么转换为二进制就是 00110010，3 的 ASCII 为 51，那么转换为二进制就是 00110011，这三个二进制组合在一起就是这样：001100010011001000110011
按照 4 个 Base64 字符转换为 3 个 8 位的字节算法就可以了，4 个字符组合起来就是 24 位，按照 8 位一个字节，就是三个字节。
function normalToBase64Char($num)
{
    if ($num >= 0 && $num <= 25) {
        return chr(ord('A') + $num);
    } else if ($num >= 26 && $num <= 51) {
        return chr(ord('a') + ($num - 26));
    } else if ($num >= 52 && $num <= 61) {
        return chr(ord('0') + ($num - 52));
    } else if ($num == 62) {
        return '+';
    } else {
        return '/';
    }
}
function base64CharToInt($num)
{
    if ($num >= 65 && $num <= 90) {
        return ($num - 65);
    } else if ($num >= 97 && $num <= 122) {
        return ($num - 97) + 26;
    } else if ($num >= 48 && $num <= 57) {
        return ($num - 48) + 52;
    } else if ($num == 43) {
        return 62;
    } else {
        return 63;
    }
}
https://learnku.com/articles/36655
```
### 一致性 hash 算法
```javascript
// 一致性哈希算法
class ConsistentHashing
{
    protected $nodes = array();    //真实节点
    protected $position = array();  //虚拟节点
    protected $mul = 64;  // 每个节点对应64个虚拟节点

    /**
     * 把字符串转为32位符号整数
     */
    public function hash($str)
    {
        return sprintf('%u', crc32($str));
    }

    /**
     * 核心功能
     */
    public function lookup($key)
    {
        $point = $this->hash($key);

        //先取圆环上最小的一个节点,当成结果
        $node = current($this->position);

        // 循环获取相近的节点
        foreach ($this->position as $key => $val) {
            if ($point <= $key) {
                $node = $val;
                break;
            }
        }

        reset($this->position);    //把数组的内部指针指向第一个元素，便于下次查询从头查找

        return $node;
    }

    /**
     * 添加节点
     */
    public function addNode($node)
    {
        if(isset($this->nodes[$node])) return;

        // 添加节点和虚拟节点
        for ($i = 0; $i < $this->mul; $i++) {
            $pos = $this->hash($node . '-' . $i);
            $this->position[$pos] = $node;
            $this->nodes[$node][] = $pos;
        }

        // 重新排序
        $this->sortPos();
    }

    /**
     * 删除节点
     */
    public function delNode($node)
    {
        if (!isset($this->nodes[$node])) return;

        // 循环删除虚拟节点
        foreach ($this->nodes[$node] as $val) {
            unset($this->position[$val]);
        }

        // 删除节点
        unset($this->nodes[$node]);
    }

    /**
     * 排序
     */
    public function sortPos()
    {
        ksort($this->position, SORT_REGULAR);
    }
}

// 测试
$con = new ConsistentHashing();

$con->addNode('a');
$con->addNode('b');
$con->addNode('c');
$con->addNode('d');

$key1 = 'www.zhihu.com';
$key2 = 'www.baidu.com';
$key3 = 'www.google.com';
$key4 = 'www.testabc.com';

echo 'key' . $key1 . '落在' . $con->lookup($key1) . '号节点上！<br>';
echo 'key' . $key2 . '落在' . $con->lookup($key2) . '号节点上！<br>';
echo 'key' . $key3 . '落在' . $con->lookup($key3) . '号节点上！<br>';
echo 'key' . $key4 . '落在' . $con->lookup($key4) . '号节点上！<br>';
https://learnku.com/articles/30269
```

### 异常处理
```javascript
try {
    $a = 5 % 0;
} catch (Exception $e) {
    echo $e->getMessage();
    $a = -1;  // 通过异常来处理 $a 为 0 的情况，但是实际上，捕获不到该异常
}

echo $a;  // 无法执行
try {
    $a = 5 % 0;
    // 注意，DivisionByZeroError 错误只能捕捉到 % 运算，无法捕捉 / 运算
} catch (DivisionByZeroError $e) {
    echo $e->getMessage();
    $a = -1;  
}

echo $a; // -1
异常将错误处理与常规代码进行分离，能够让业务流程更加清晰。

try {
    // 业务流程
} catch (FileNotFoundException $e) {

} catch (FileTypeException $e) {

} catch (Exception $e) {

}
// 只处理 404 异常
public function actionType($username)
{
    try {
        $user = $client->get(sprintf("/api/user/%s", $username));
    } catch (RequestException $e) {
        if (404 === $e->getResponse()->getStatusCode()) {
            return "create";
        }

        throw $e;
    }

    return "update";
}
set_exception_handler(function($exception){
    echo '发生了未知错误';
    log($exception->getMessage());
});https://learnku.com/articles/37029

```
### 秒读 Excel 百万数据
```javascript
class ReaderCsv
{

    /**
     * 数组键值
     * @var int
     */
    protected $row = 0;

    /**
     * Excel源数据
     * @var array
     */
    protected $excelData = [];

    /**
     * 文件路径
     * @var
     */
    protected $path;

    /**
     * ReaderCsv constructor.
     * @param $path
     */
    public function __construct($path)
    {
        $this->path = $path;
    }

    /**
     * 读取CSV文件
     */
    public function readCsv()
    {
        //数组键值
        $row = $this->row;

        //Excel数组
        $excelData = [];

        //打开文件
        $file = fopen($this->path, 'r');

        //从文件指针中读入一行并解析 CSV 字段
        //fgetcsv 解析读入的行并找出 CSV 格式的字段然后返回一个包含这些字段的数组。
        while ($data = fgetcsv($file)) {
            //统计一行数据有多少列
            $columnSize = count($data);

            for ($i = 0; $i < $columnSize; $i++) {
                //转换字符的编码 && 赋值Excel源数据
                $excelData[$row][$i] = mb_convert_encoding(
                    $data[$i],
                    'UTF-8',
                    'gb2312'
                );
            }
            $row++;
        }

        $this->row = $row;

        //关闭一个已打开的文件指针
        fclose($file);

        $this->excelData = $excelData;
    }

    /**
     * 获取Excel源数据
     * @return array
     */
    public function getExcelData()
    {
        return $this->excelData;
    }

    /**
     * 获取总行数
     * @return int
     */
        public function getRow()
    {
        return $this->row;
    }
}
//传入文件路径
$readerCsv = new ReaderCsv($filePath);

//读取csv文件
$readerCsv->readCsv();

//获取Excel数据
$excelData = $readerCsv->getExcelData();
https://learnku.com/articles/37002
https://phpspreadsheet.readthedocs.io/en/latest/
https://github.com/rap2hpoutre/fast-excel
https://github.com/viest/php-ext-xlswriter
```
### 关键词提取高亮
```javascript

$content = '<p>周杰伦传世之作《晴天》</p>:从前从前，<div><img class="img" src="htt://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=3137f6103c4e251ff6faecaac6efa272/38dbb6fd5266d0167927ca029b2bd40735fa35d9.jpg"></div>有个人<strong>爱你</strong>很久，<p>风渐渐，把你吹得好远</p>';
echo $content;
$tag = [
    ['name' => '周杰伦','url'=>'https://baike.baidu.com/item/%E5%91%A8%E6%9D%B0%E4%BC%A6/129156?fr=aladdin'],
    ['name'=>'晴天','url'=>'https://baike.baidu.com/item/%E6%99%B4%E5%A4%A9/5429222'],
    ];
preg_match_all('/<a[^>]*>.*?<\/a>|<\/?[a-zA-Z]+[^>]*>|<!--.*?-->/', $content, $match);
echo '<pre>';
$html = $match[0];
$no_html = preg_split('/<a[^>]*>.*?<\/a>|<\/?[a-zA-Z]+[^>]*>|<!--.*?-->/', $content);

print_r($html);

print_r($no_html);
$tags  = [[],[],[]];
foreach ($tag as $k=>$v){
    $tags[0][] = '#'.$v['name'].'#';
    $tags[1][] =  '#'.md5($v['name']). '#';
    $tags[2][] = "<a href={$v['url']}>{$v['name']}</a>";
}
print_r($tags);
foreach ($tags[0] as $k=>$v){
    foreach ($no_html as $key=>$value){
        if (!trim($value)) continue;
        if(preg_match($v,$value)){
            $no_html[$key] = preg_replace($v,$tags[1][$k],$value,1);
            break;
        }
    }
}print_r($no_html);
foreach ($no_html as $key=>$value){
    if (!trim($value)) continue;
    $no_html[$key] = str_replace($tags[1],$tags[2],$value);
}
$res = [];
$num = count($no_html);
print_r($no_html);
for ($i=0;$i<$num;$i++){
    $res[] = $no_html[$i];
    if (isset($html[$i])){
        $res[]=$html[$i];
    }
}

echo implode('',$res);
<p><a href=https://baike.baidu.com/item/%E5%91%A8%E6%9D%B0%E4%BC%A6/129156?fr=aladdin>周杰伦</a>传世之作《<a href=https://baike.baidu.com/item/%E6%99%B4%E5%A4%A9/5429222>晴天</a>》</p>:从前从前，<div><img class="img" src="htt://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=3137f6103c4e251ff6faecaac6efa272/38dbb6fd5266d0167927ca029b2bd40735fa35d9.jpg"></div>有个人<strong>爱你</strong>很久，<p>风渐渐，把你吹得好远</p>

/**
     * 对字符串执行指定次数替换
     * @param  Mixed $search   查找目标值
     * @param  Mixed $replace  替换值
     * @param  Mixed $subject  执行替换的字符串／数组
     * @param  Int   $limit    允许替换的次数，默认为-1，不限次数
     * @return Mixed
     */
    function str_replace_limit($search, $replace, $subject, $limit=-1){
        if(is_array($search)){
            foreach($search as $k=>$v){
                $search[$k] = '`'. preg_quote($search[$k], '`'). '`';
            }
        }else{
            $search = '`'. preg_quote($search, '`'). '`';
        }
        return preg_replace($search, $replace, $subject, $limit);
    }
```
### PHP 反射
```javascript
ReflectionClass
ReflectionFunction
ReflectionMethod
ReflectionParameter
class  Printer
{
}

class  Student
{
    private $name;
    private $year;

    public function __construct($name, $year)
    {
        $this->name = $name;
        $this->year = $year;
    }

    public function getValue()
    {
        return $this->name;
    }

    public function setBase(Printer $printer, $name, $year = 10)
    {
        $this->name = $name;
        $this->year = $year;
    }
}
$refl_class = new ReflectionClass(Student::class);
$object = $refl_class->newInstanceArgs(["obama", 100]);
echo get_class($object) . "\n";"Student"
echo $object->getValue();obama
$refl_method = $refl_class->getMethod("setBase");
echo get_class($refl_method) . "\n";
$parameters = $refl_method->getParameters();
foreach ($parameters as $parameter) {
    echo $parameter->getName() . "\n";
    if ($parameter->getClass() != null) {
         echo $parameter->getClass()->getName() . "\n";
    }
    if ($parameter->isDefaultValueAvailable()) {
        echo $parameter->getDefaultValue() . "\n";
    }
}
printer
Printer
name
year
10
https://learnku.com/articles/37162
```
### 经度和纬度计算距离两地距离
```javascript
function getDistance($lng1, $lat1, $lng2, $lat2)
{
    // 将角度转为狐度https://www.qqdeveloper.com/2019/09/26/longitude-and-langitude/
    //deg2rad()函数将角度转换为弧度
    $radLat1 = deg2rad($lat1);
    $radLat2 = deg2rad($lat2);
    $radLng1 = deg2rad($lng1);
    $radLng2 = deg2rad($lng2);
    $a       = $radLat1 - $radLat2;
    $b       = $radLng1 - $radLng2;
    $s       = 2 * asin(sqrt(pow(sin($a / 2), 2) + cos($radLat1) * cos($radLat2) * pow(sin($b / 2), 2))) * 6378.137 * 1000;
    return $s;
}

```
### 雪花算法
```javascript
1bit:一般是符号位，不做处理
41bit:用来记录时间戳，这里可以记录 69 年，如果设置好起始时间比如今年是 2018 年，那么可以用到 2089 年，到时候怎么办？要是这个系统能用 69 年，我相信这个系统早都重构了好多次了。
10bit:10bit 用来记录机器 ID，总共可以记录 1024 台机器，一般用前 5 位代表数据中心，后面 5 位是某个数据中心的机器 ID
12bit:循环位，用来对同一个毫秒之内产生不同的 ID，12 位可以最多记录 4095 个，也就是在同一个机器同一毫秒最多记录 4095 个，多余的需要进行等待下毫秒。上面只是一个将 64bit 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：

服务目前 QPS10 万，预计几年之内会发展到百万。
当前机器三地部署，上海，北京，深圳都有。
当前机器 10 台左右，预计未来会增加至百台。
适用场景:当我们需要无序不能被猜测的 ID，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 ID，用雪花算法别人就无法猜测你每天的订单量是多少。
PHP uniqid()函数可用于生成不重复的唯一标识符，该函数基于微秒级当前时间戳。在高并发或者间隔时长极短（如循环代码）的情况下，会出现大量重复数据。即使使用了第二个参数，也会重复，最好的方案是结合 md5 函数来生成唯一 ID。
$units = array();
for($i=0;$i<1000000;$i++){
    $units[] = uniqid();
}
$values  = array_count_values($units);
$duplicates = [];
foreach($values as $k=>$v){
    if($v>1){
        $duplicates[$k]=$v;
    }
}
echo '<pre>';
print_r($duplicates);
$units = array();
for($i=0;$i<1000000;$i++){
    $units[] = uniqid('',true);
}
$values  = array_count_values($units);
$duplicates = [];
foreach($values as $k=>$v){
    if($v>1){
        $duplicates[$k]=$v;
    }
}
echo '<pre>';
print_r($duplicates);
$units = array();
for($i=0;$i<1000000;$i++){
    $units[]=md5(uniqid(md5(microtime(true)),true));
}
$values  = array_count_values($units);
$duplicates = [];
foreach($values as $k=>$v){
    if($v>1){
        $duplicates[$k]=$v;
    }
}
echo '<pre>';
print_r($duplicates);
使用 session_create_id()函数生成唯一标识符，经过实际测试发现，即使循环调用 session_create_id()一亿次，都没有出现过重复。
php session_create_id()是 php 7.1 新增的函数，用来生成 session id，低版本无法使用。
https://www.qqdeveloper.com/2019/09/12/snowflake/
https://www.qqdeveloper.com/2019/09/16/php-unique-id/
```
### 跨域认证解决方案jwt
```javascript
(图一)Session与Cookie认证与鉴权
1.客户端向服务端发送一个http请求。
2.服务端在收到客户端的请求时，生成一个唯一的 sessionid，这里需要将该生成的 session 存储在服务端,这个 sessionid 存储具体的 session 内容，默认的是文件存储，当然我们可以修改具体的存储方式，例如数据库存储。 3.客户端在接受到这个 sessionid 时，存在 cookie 里面，每次请求时携带该 sessionid。 4.服务端在接收到客户端的请求之后，根据客户端发送的 sessionid 来进行认证与授权。
这里也推荐一下自己之前分享的一篇有关 session 于 cookie 的知识点。session 与 cookie 详解


(图二)传统的token授权
1.客户端向服务端发送一个http请求。
2.服务端在收到客户端的请求之后，生成一个唯一 token，这里需要将该生成的 token 存储在服务端，至于怎么存，可以和上面 session 与 cookie 的方式一致。也可以存在缓存数据库中，如 redis，memcached。 3.服务端将该 token 返回给客户端，客户端存在本地，可以存请求头 header 中，也可以存在 cookie 中，同时也可以存在 localstorage 中。 4.向服务端发送请求时，携带该 token，服务端进行认证或者授权。


(图三)JWT认证模式
1.客户端向服务端发送一个http请求。
2.服务端根据 jwt 的生成规则，生成一个 token，并返回给客户端，这里服务端是不需要存储的。 3.客户端在接受到该 token 时，存在客户端。 4.客户端向服务端发送请求时，服务端对请求的 token 进行解析，如果发现解析出来的数据和生成的数据是一致的代表是一个合法的 token，则进行相应的操作。
基于 session 都是需要服务端存储的，而 JWT 是不需要服务端来存储的。针对以上几点，总结如下：
一、缺点 1.容易遇到跨域问题。不同域名下是无法通过 session 直接来做到认证和鉴权的。 2.分布式部署的系统，需要使用共享 session 机制 3.容易出现 csrf 问题。

二、优点 1.方便灵活，服务器端直接创建一个 sessionid，下发给客户端，客户端请求携带 sessionid 即可。
2.session 存储在服务端，更加安全。 3.便于服务端清除 session，让用户重新授权一次。
JWT 是基于客户端存储的一种认证方式，然而 session 是基于服务端存储的一种认证方式。JWT 虽然不用服务端存储了，也可以避免跨域、csrf 等情况。但也存在如下几个不太好的地方。 1.无法清除认证 token。由于 JWT 生成的 token 都是存储在客户端的，不能有服务端去主动清除，只有直到失效时间到了才能清除。除非服务端的逻辑做了改变。 2.存储在客户端，相对服务端，安全性更低一些。当 JWT 生成的 token 被破解，我们不便于清除该 token。
composer require firebase/php-jwt
private $key = 'jwtKey';

    // 生成JWT
    public function createJwt()
    {
        $time  = time();
        $key   = $this->key;
        $token = [
            'iss' => 'https://www.qqdeveloper.com',// 签发人
            'exp' => $time + 86400,// 过期时间(这里的有效期时间为1天)
            'sub' => '主题内容',// 主题
            'aud' => '受众内容',// 受众
            'nbf' => $time,// 生效时间
            'iat' => $time,// 签发时间
            'jti' => 123,// 编号
            // 额外自定义的数据
            'data' => [
                'userName' => '编程浪子走四方'
            ]];
        // 调用生成加密方法('Payloadn内容','加密的键',['加密算法'],['加密的可以'],['JWT的header头'])
        $jwt = JWT::encode($token, $key);
        return json(['data' => $jwt]);
    }

    // 解析JWT
    public function analysisJwt()
    {
        try {
            $key = $this->key;
            $jwt = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9leGFtcGxlLm9yZyIsImV4cCI6MTU2ODA5NjE4MCwic3ViIjoiXHU0ZTNiXHU5ODk4XHU1MTg1XHU1YmI5IiwiYXVkIjoiXHU1M2Q3XHU0ZjE3XHU1MTg1XHU1YmI5IiwibmJmIjoxNTY4MDA5NzgwLCJpYXQiOjE1NjgwMDk3ODAsImp0aSI6MTIzLCJkYXRhIjp7InVzZXJOYW1lIjoiXHU3ZjE2XHU3YTBiXHU2ZDZhXHU1YjUwXHU4ZDcwXHU1NmRiXHU2NWI5In19.kHb_9Np0zjE25YE9czUEGvmFPYtqMJT9tuZzJTuMZl0';
            // 调用解密方法('JWT内容','解密的键,和加密时的加密键一直','加密算法')
            $decoded = JWT::decode($jwt, $key, array('HS256'));
            return json(['message' => $decoded]);
        } catch (\Exception $exception) {
            return json(['message' => $exception->getMessage()]);
        }

    }
}
https://www.qqdeveloper.com/2019/09/09/Jwt/

```
### 加密算法
```javascript
MD5 结果是 128 位摘要，SHa1 是 160 位摘要。那么 MD5 的速度更快，而 SHA1 的强度更高。

常用的对称加密算法有：AES 和 DES。
DES：比较老的算法，一共有三个参数入口（原文，密钥，加密模式）。而 3DES 只是 DES 的一种模式，是以 DES 为基础更安全的变形，对数据进行了三次加密，也是被指定为 AES 的过渡算法。
AES:高级加密标准，新一代标准，加密速度更快，安全性更高（不用说优先选择）
$content = "123456";
// 该函数是获取有哪些加密方式
$encryptMethod = openssl_get_cipher_methods();
$method1 = "AES-256-ECB";
$key = "123";

$encrypt2 = openssl_encrypt($content,$method1,$key);
echo $encrypt2."\n";
$decrypt2 = openssl_decrypt($encrypt2,$method1,$key);
echo $decrypt2."\n";

$method2 = "DES-EDE3-CFB";
$encrypt3 = openssl_encrypt($content,$method2,$key);
echo $encrypt3."\n";
$decrypt3 = openssl_decrypt($encrypt3,$method2,$key);
echo $decrypt3."\n";
公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多。
1.A 要向 B 发送信息，A 和 B 都要产生一对用于加密的公钥和私钥。

2.A 的私钥保密，A 的公钥告诉 B；B 的私钥保密，B 的公钥告诉 A。

3.A 要给 B 发送信息时，A 用 B 的公钥加密信息，因为 A 知道 B 的公钥。

4.A 将这个消息发给 B（已经用 B 的公钥加密消息）。

5.B 收到这个消息后，B 用自己的私钥解密 A 的消息。其他所有收到这个报文的人都无法解密，因为只有 B 才有 B 的私钥。
// 公钥内容
$publicKey = "-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA448HrtB/ORfECv/owcAB
fN/PfAy2G7BGPkIy96QuFQhgf7pTF+X4x4wRZgRtdmhnMgtpessx6UXaNzRaDsa8
IWozFTrNu3P7xcJxdcWbdlHdMYASmp4xOe6ct/tGURI8HBn4yjxTES4IFAoPxNCt
dgs31dsJnq0uUa3C1VTWbPtdZX+GX/GOsl2hbJOhn/WrRlOIGzI2oSjhdaPXGD1w
xXKCZM1RhcjQoWQLnFerlOeqNRhW+qgoJ7nRD+PhEajA0LhUMHvyeFR+A37DuFdI
KBD58b2EnBZmYyZL7umeNjjhruSyeD1Y5qOvuKOoL7vQOVzAdVwokcMqDmXurR4s
kQIDAQAB
-----END PUBLIC KEY-----
";
// 私钥内容
$privateKey = "-----BEGIN PRIVATE KEY-----
MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDjjweu0H85F8QK
/+jBwAF83898DLYbsEY+QjL3pC4VCGB/ulMX5fjHjBFmBG12aGcyC2l6yzHpRdo3
NFoOxrwhajMVOs27c/vFwnF1xZt2Ud0xgBKanjE57py3+0ZREjwcGfjKPFMRLggU
Cg/E0K12CzfV2wmerS5RrcLVVNZs+11lf4Zf8Y6yXaFsk6Gf9atGU4gbMjahKOF1
o9cYPXDFcoJkzVGFyNChZAucV6uU56o1GFb6qCgnudEP4+ERqMDQuFQwe/J4VH4D
fsO4V0goEPnxvYScFmZjJkvu6Z42OOGu5LJ4PVjmo6+4o6gvu9A5XMB1XCiRwyoO
Ze6tHiyRAgMBAAECggEBALtXC1ouKC8Wk70ChdrMee0WTLixtlMBQjMLSO57abzD
Er7U5IeuOqv9cm1sg7mRpjObFZGUK1kCuu3r2aCEmGliBwAZUzpZ+BMNS19L+frk
1pdj+uz0A07QVJFa+r7PplD0SNAl7bUdEmV9CxJbQhMGlUcodrj9lj6EMPx0Rbud
gBLJbZCK+h8lNgbGYce+J0+CDDnTapsPKFP/DvwZwgE4CkpVciEtbH2RzU45qRVI
If7/3YBB3q+eD4GrIuBgmLUT7bs2vKn/RXxN8YARoEwUqj/Gg2iXQeSPtW0iWuV/
cbCT6Sfb1J7KGXiEDKrsNH+e29TcXsIDbrMHSyj3IeECgYEA8gtQJbHDhcXjDSx1
5SWKpWdhFNEp/ggdFj8hAroVBHPmGelvkY6i4OZ/IGulzIrJY2uxXwU91KMuoZ5/
IdOQSZiehsba1PCn9ZAVY/KZZvfAYX96tUKUmnar1GyhhcSAljPK2zKqYbGnJbnI
TVMpSthdNgEi/XNrEWrpXFWimI0CgYEA8K3nhWBt4xG87x9ifEpJjFlf/8hlmKr9
8SMi4qm/ja3huL4si1VVkO8flqqhkkr+HqtBKOe+bYMZBUDtYnv/netMeQuCdvJY
sfXPeSguXgGhjxP6gNswMYnzOykoGyPT84gOXBuY2M8X9nB6SkAQ+OL/sf0ltQdP
4mdQNQBKjRUCgYEA5sLmbKmoMZfSurKSzB8Yqk1/fytTj8AIizcwr7rdYttkm3u1
RN7qZuUaerxm3DXNfx4jguYqZtoVET1dE9DylVgOe4yHAdFXMIVn/1xB6Kt4HPw+
7yVFLGbLt8DB1hjcR1elpYoOawnGw+72CtKoYZUaeOxogZ9Sis6VIdT7KdkCgYEA
tkmw0fcwI0xbAe2OZT7Kp89Fg3BfapsPzORk1rHkkEVDce4vxLQ0I5rJHQ9NYoUE
JWxl5LppI36oo68CXJY4C36cpA1QmhCBlv/rTQNe4vpvR/PExnW88bhfDc7lPnEL
ZicFYUPRp1xq9M9KABS4Bhm/uipWtd685WiEejAnRuUCgYA4ddYkl6XwA/HQ1Kyr
iwAllDdusuGW62DMeXC2h2qw8yCvG38YAQu8lRDCFm0JW/sD2sgVCtt9c147ZFoB
mUghpFOZRZvbxEdPzIyb4Gn0wN+3Jwjrl9uPiY82q92G0E253PKug2EJYapa411/
fxrEXMi/X+VwggoEnOqXsbyrHA==
-----END PRIVATE KEY-----
";

// 加密字符串
$content = "123456";

/**
 * 使用公钥加密，私钥解密
 */
$encrypt = "";
openssl_public_encrypt($content,$encrypt,$publicKey);
echo "加密之后的数据为:\n";
var_dump($encrypt);

$decrypt = "";
openssl_private_decrypt($encrypt,$decrypt,$privateKey);
echo "解密之后的数据为:\n";
var_dump($decrypt);
/**
 * 使用私钥加密，公钥解密
 */
$encrypt1 = "";
openssl_private_encrypt($content,$encrypt1,$privateKey);
echo "加密之后的数据为:\n";
var_dump($encrypt1);
$decrypt1 = "";
openssl_public_decrypt($encrypt1,$decrypt1,$publicKey);
echo "解密之后的数据为:\n";
var_dump($decrypt1);
https://www.qqdeveloper.com/2019/08/28/data-encrypt/
```
### 常用排序算法之桶排序
```javascript
桶排序其实就是一种归纳排序，他将要进行排序的数组分到有限的桶里面，然后对桶进行归纳排序，可以理解成他是一个归纳结果。
小哼的班上只有 5 个同学，这 5 个同学分别考了 5 分、3 分、 5 分、2 分和 8 分，哎考得真是惨不忍睹（满分是 10
分）。接下来将分数进行从小到大排序， 排序后是 2 3 5 5 8。

思路分析
  首先，他的总分是 10 分，也就是说有 11 种情况，所以我们需要 11 个桶，开始的时候我们都不给这些桶加水，也就是每个桶是 0，每个桶都标号从 0 开始到 10 结束。

  然后呢我们可以看到有 5 个同学，所以，我们可以通过循环拿到这五个同学的分数，拿到分数后，比如我先拿到的是 8 分，那么我们就给标号为 8 的桶加 1 刻度水（当然也不一定是刻度为单位，也可以是升，毫升什么的，这里是方便理解），这样下来，标号为 2 的桶里有 1 刻度水，标号为 3 的桶里有 1 刻度水，标号为 5 的桶里有 2 刻度水，标号为 8 的桶里有 1 刻度水。

  最后，我们对这些桶里面的水进行统计，从前往后，有一刻度水的就打印这个桶编号 1 次，两刻度水的就打印桶编号 2 次
 public function index()
    {
        //需要进行排序的数组
        $arr = array(5, 3, 5, 2, 8);
        //声明一个空数组
        $list = array();
        //将空数组赋值0
        for ($i = 0; $i <= 10; $i++) {
            $list[$i] = 0;
        }
        //按照相应的进行重新赋值
        for ($j = 0; $j < sizeof($arr); $j++) {
            $list[$arr[$j]]++;
        }
        //打印排序后的结果
        for ($i = 1; $i <= 10; $i++) {
            for ($j = 1; $j <= $list[$i]; $j++) {
                var_dump($i);
            }
        }
    }
https://learnku.com/articles/37185
$data = [5,3,5,2,8];
$count = array_count_values($data);
$res = [];
for ($i = 0; $i < 11; $i++) {
    if (isset($count[$i])) {
        for ($j = 0; $j < $count[$i]; $j++) {
            $res[] = $i;
        }
    }
}
```



[PHP7 的垃圾回收机制](https://learnku.com/articles/33451)

[微博机器人](https://github.com/Hanson/weibot)


[在谷歌浏览器输入 URL 回车之后发生了什么](https://4ark.me/post/b6c7c0a2.html)

[电商秒杀超卖解决方案](https://www.qqdeveloper.com/2019/10/10/chaomai/)

[高并发设计笔记](https://learnku.com/articles/37060)


